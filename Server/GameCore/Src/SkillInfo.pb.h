// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SkillInfo.proto

#ifndef PROTOBUF_SkillInfo_2eproto__INCLUDED
#define PROTOBUF_SkillInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "EquipmentInfo.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SkillInfo_2eproto();
void protobuf_AssignDesc_SkillInfo_2eproto();
void protobuf_ShutdownFile_SkillInfo_2eproto();

class SkillInfo;
class SkillFamily;
class AllSkills;

enum SkillInfo_SkillType {
  SkillInfo_SkillType_STATUS = 0
};
bool SkillInfo_SkillType_IsValid(int value);
const SkillInfo_SkillType SkillInfo_SkillType_SkillType_MIN = SkillInfo_SkillType_STATUS;
const SkillInfo_SkillType SkillInfo_SkillType_SkillType_MAX = SkillInfo_SkillType_STATUS;
const int SkillInfo_SkillType_SkillType_ARRAYSIZE = SkillInfo_SkillType_SkillType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillInfo_SkillType_descriptor();
inline const ::std::string& SkillInfo_SkillType_Name(SkillInfo_SkillType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillInfo_SkillType_descriptor(), value);
}
inline bool SkillInfo_SkillType_Parse(
    const ::std::string& name, SkillInfo_SkillType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillInfo_SkillType>(
    SkillInfo_SkillType_descriptor(), name, value);
}
enum SkillInfo_TrackType {
  SkillInfo_TrackType_HORLINE = 0,
  SkillInfo_TrackType_VERLINE = 1
};
bool SkillInfo_TrackType_IsValid(int value);
const SkillInfo_TrackType SkillInfo_TrackType_TrackType_MIN = SkillInfo_TrackType_HORLINE;
const SkillInfo_TrackType SkillInfo_TrackType_TrackType_MAX = SkillInfo_TrackType_VERLINE;
const int SkillInfo_TrackType_TrackType_ARRAYSIZE = SkillInfo_TrackType_TrackType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillInfo_TrackType_descriptor();
inline const ::std::string& SkillInfo_TrackType_Name(SkillInfo_TrackType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillInfo_TrackType_descriptor(), value);
}
inline bool SkillInfo_TrackType_Parse(
    const ::std::string& name, SkillInfo_TrackType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillInfo_TrackType>(
    SkillInfo_TrackType_descriptor(), name, value);
}
enum SkillInfo_LaunchType {
  SkillInfo_LaunchType_SINGLELINE = 0,
  SkillInfo_LaunchType_MULLINE = 1,
  SkillInfo_LaunchType_SECTORLINE = 2,
  SkillInfo_LaunchType_CONTINUOUSLINE = 3,
  SkillInfo_LaunchType_FALLDOWN = 4,
  SkillInfo_LaunchType_MELEE = 5,
  SkillInfo_LaunchType_JUMP = 6,
  SkillInfo_LaunchType_AROUNDSELF = 7,
  SkillInfo_LaunchType_GOSTRAIGHT = 8,
  SkillInfo_LaunchType_LEAP = 9,
  SkillInfo_LaunchType_ROTATION = 10,
  SkillInfo_LaunchType_BACKSTAB = 11,
  SkillInfo_LaunchType_SEPARATION = 12,
  SkillInfo_LaunchType_BLINK = 13
};
bool SkillInfo_LaunchType_IsValid(int value);
const SkillInfo_LaunchType SkillInfo_LaunchType_LaunchType_MIN = SkillInfo_LaunchType_SINGLELINE;
const SkillInfo_LaunchType SkillInfo_LaunchType_LaunchType_MAX = SkillInfo_LaunchType_BLINK;
const int SkillInfo_LaunchType_LaunchType_ARRAYSIZE = SkillInfo_LaunchType_LaunchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillInfo_LaunchType_descriptor();
inline const ::std::string& SkillInfo_LaunchType_Name(SkillInfo_LaunchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillInfo_LaunchType_descriptor(), value);
}
inline bool SkillInfo_LaunchType_Parse(
    const ::std::string& name, SkillInfo_LaunchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillInfo_LaunchType>(
    SkillInfo_LaunchType_descriptor(), name, value);
}
enum SkillInfo_TargetType {
  SkillInfo_TargetType_NOTARGET = 0,
  SkillInfo_TargetType_SELF = 1,
  SkillInfo_TargetType_FRIEND = 2,
  SkillInfo_TargetType_ENEMY = 4
};
bool SkillInfo_TargetType_IsValid(int value);
const SkillInfo_TargetType SkillInfo_TargetType_TargetType_MIN = SkillInfo_TargetType_NOTARGET;
const SkillInfo_TargetType SkillInfo_TargetType_TargetType_MAX = SkillInfo_TargetType_ENEMY;
const int SkillInfo_TargetType_TargetType_ARRAYSIZE = SkillInfo_TargetType_TargetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillInfo_TargetType_descriptor();
inline const ::std::string& SkillInfo_TargetType_Name(SkillInfo_TargetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillInfo_TargetType_descriptor(), value);
}
inline bool SkillInfo_TargetType_Parse(
    const ::std::string& name, SkillInfo_TargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillInfo_TargetType>(
    SkillInfo_TargetType_descriptor(), name, value);
}
enum SkillInfo_StatusType {
  SkillInfo_StatusType_BEGIN = 0,
  SkillInfo_StatusType_MOVE = 1,
  SkillInfo_StatusType_HIT = 2,
  SkillInfo_StatusType_IDLE = 3
};
bool SkillInfo_StatusType_IsValid(int value);
const SkillInfo_StatusType SkillInfo_StatusType_StatusType_MIN = SkillInfo_StatusType_BEGIN;
const SkillInfo_StatusType SkillInfo_StatusType_StatusType_MAX = SkillInfo_StatusType_IDLE;
const int SkillInfo_StatusType_StatusType_ARRAYSIZE = SkillInfo_StatusType_StatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillInfo_StatusType_descriptor();
inline const ::std::string& SkillInfo_StatusType_Name(SkillInfo_StatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillInfo_StatusType_descriptor(), value);
}
inline bool SkillInfo_StatusType_Parse(
    const ::std::string& name, SkillInfo_StatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillInfo_StatusType>(
    SkillInfo_StatusType_descriptor(), name, value);
}
enum SkillInfo_AreaType {
  SkillInfo_AreaType_ONE = 0,
  SkillInfo_AreaType_SQUARE = 1,
  SkillInfo_AreaType_LIST = 2
};
bool SkillInfo_AreaType_IsValid(int value);
const SkillInfo_AreaType SkillInfo_AreaType_AreaType_MIN = SkillInfo_AreaType_ONE;
const SkillInfo_AreaType SkillInfo_AreaType_AreaType_MAX = SkillInfo_AreaType_LIST;
const int SkillInfo_AreaType_AreaType_ARRAYSIZE = SkillInfo_AreaType_AreaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillInfo_AreaType_descriptor();
inline const ::std::string& SkillInfo_AreaType_Name(SkillInfo_AreaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillInfo_AreaType_descriptor(), value);
}
inline bool SkillInfo_AreaType_Parse(
    const ::std::string& name, SkillInfo_AreaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillInfo_AreaType>(
    SkillInfo_AreaType_descriptor(), name, value);
}
enum SkillInfo_ShockType {
  SkillInfo_ShockType_NONE = 0,
  SkillInfo_ShockType_PREPARE_OVER = 1,
  SkillInfo_ShockType_ON_HIT = 2,
  SkillInfo_ShockType_MOVETIME_OVER = 3
};
bool SkillInfo_ShockType_IsValid(int value);
const SkillInfo_ShockType SkillInfo_ShockType_ShockType_MIN = SkillInfo_ShockType_NONE;
const SkillInfo_ShockType SkillInfo_ShockType_ShockType_MAX = SkillInfo_ShockType_MOVETIME_OVER;
const int SkillInfo_ShockType_ShockType_ARRAYSIZE = SkillInfo_ShockType_ShockType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillInfo_ShockType_descriptor();
inline const ::std::string& SkillInfo_ShockType_Name(SkillInfo_ShockType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillInfo_ShockType_descriptor(), value);
}
inline bool SkillInfo_ShockType_Parse(
    const ::std::string& name, SkillInfo_ShockType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillInfo_ShockType>(
    SkillInfo_ShockType_descriptor(), name, value);
}
enum SkillInfo_OffsetType {
  SkillInfo_OffsetType_NO_OFFSET = 0,
  SkillInfo_OffsetType_FRONT = 1
};
bool SkillInfo_OffsetType_IsValid(int value);
const SkillInfo_OffsetType SkillInfo_OffsetType_OffsetType_MIN = SkillInfo_OffsetType_NO_OFFSET;
const SkillInfo_OffsetType SkillInfo_OffsetType_OffsetType_MAX = SkillInfo_OffsetType_FRONT;
const int SkillInfo_OffsetType_OffsetType_ARRAYSIZE = SkillInfo_OffsetType_OffsetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillInfo_OffsetType_descriptor();
inline const ::std::string& SkillInfo_OffsetType_Name(SkillInfo_OffsetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillInfo_OffsetType_descriptor(), value);
}
inline bool SkillInfo_OffsetType_Parse(
    const ::std::string& name, SkillInfo_OffsetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillInfo_OffsetType>(
    SkillInfo_OffsetType_descriptor(), name, value);
}
// ===================================================================

class SkillInfo : public ::google::protobuf::Message {
 public:
  SkillInfo();
  virtual ~SkillInfo();
  
  SkillInfo(const SkillInfo& from);
  
  inline SkillInfo& operator=(const SkillInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillInfo& default_instance();
  
  void Swap(SkillInfo* other);
  
  // implements Message ----------------------------------------------
  
  SkillInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillInfo& from);
  void MergeFrom(const SkillInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef SkillInfo_SkillType SkillType;
  static const SkillType STATUS = SkillInfo_SkillType_STATUS;
  static inline bool SkillType_IsValid(int value) {
    return SkillInfo_SkillType_IsValid(value);
  }
  static const SkillType SkillType_MIN =
    SkillInfo_SkillType_SkillType_MIN;
  static const SkillType SkillType_MAX =
    SkillInfo_SkillType_SkillType_MAX;
  static const int SkillType_ARRAYSIZE =
    SkillInfo_SkillType_SkillType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SkillType_descriptor() {
    return SkillInfo_SkillType_descriptor();
  }
  static inline const ::std::string& SkillType_Name(SkillType value) {
    return SkillInfo_SkillType_Name(value);
  }
  static inline bool SkillType_Parse(const ::std::string& name,
      SkillType* value) {
    return SkillInfo_SkillType_Parse(name, value);
  }
  
  typedef SkillInfo_TrackType TrackType;
  static const TrackType HORLINE = SkillInfo_TrackType_HORLINE;
  static const TrackType VERLINE = SkillInfo_TrackType_VERLINE;
  static inline bool TrackType_IsValid(int value) {
    return SkillInfo_TrackType_IsValid(value);
  }
  static const TrackType TrackType_MIN =
    SkillInfo_TrackType_TrackType_MIN;
  static const TrackType TrackType_MAX =
    SkillInfo_TrackType_TrackType_MAX;
  static const int TrackType_ARRAYSIZE =
    SkillInfo_TrackType_TrackType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrackType_descriptor() {
    return SkillInfo_TrackType_descriptor();
  }
  static inline const ::std::string& TrackType_Name(TrackType value) {
    return SkillInfo_TrackType_Name(value);
  }
  static inline bool TrackType_Parse(const ::std::string& name,
      TrackType* value) {
    return SkillInfo_TrackType_Parse(name, value);
  }
  
  typedef SkillInfo_LaunchType LaunchType;
  static const LaunchType SINGLELINE = SkillInfo_LaunchType_SINGLELINE;
  static const LaunchType MULLINE = SkillInfo_LaunchType_MULLINE;
  static const LaunchType SECTORLINE = SkillInfo_LaunchType_SECTORLINE;
  static const LaunchType CONTINUOUSLINE = SkillInfo_LaunchType_CONTINUOUSLINE;
  static const LaunchType FALLDOWN = SkillInfo_LaunchType_FALLDOWN;
  static const LaunchType MELEE = SkillInfo_LaunchType_MELEE;
  static const LaunchType JUMP = SkillInfo_LaunchType_JUMP;
  static const LaunchType AROUNDSELF = SkillInfo_LaunchType_AROUNDSELF;
  static const LaunchType GOSTRAIGHT = SkillInfo_LaunchType_GOSTRAIGHT;
  static const LaunchType LEAP = SkillInfo_LaunchType_LEAP;
  static const LaunchType ROTATION = SkillInfo_LaunchType_ROTATION;
  static const LaunchType BACKSTAB = SkillInfo_LaunchType_BACKSTAB;
  static const LaunchType SEPARATION = SkillInfo_LaunchType_SEPARATION;
  static const LaunchType BLINK = SkillInfo_LaunchType_BLINK;
  static inline bool LaunchType_IsValid(int value) {
    return SkillInfo_LaunchType_IsValid(value);
  }
  static const LaunchType LaunchType_MIN =
    SkillInfo_LaunchType_LaunchType_MIN;
  static const LaunchType LaunchType_MAX =
    SkillInfo_LaunchType_LaunchType_MAX;
  static const int LaunchType_ARRAYSIZE =
    SkillInfo_LaunchType_LaunchType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaunchType_descriptor() {
    return SkillInfo_LaunchType_descriptor();
  }
  static inline const ::std::string& LaunchType_Name(LaunchType value) {
    return SkillInfo_LaunchType_Name(value);
  }
  static inline bool LaunchType_Parse(const ::std::string& name,
      LaunchType* value) {
    return SkillInfo_LaunchType_Parse(name, value);
  }
  
  typedef SkillInfo_TargetType TargetType;
  static const TargetType NOTARGET = SkillInfo_TargetType_NOTARGET;
  static const TargetType SELF = SkillInfo_TargetType_SELF;
  static const TargetType FRIEND = SkillInfo_TargetType_FRIEND;
  static const TargetType ENEMY = SkillInfo_TargetType_ENEMY;
  static inline bool TargetType_IsValid(int value) {
    return SkillInfo_TargetType_IsValid(value);
  }
  static const TargetType TargetType_MIN =
    SkillInfo_TargetType_TargetType_MIN;
  static const TargetType TargetType_MAX =
    SkillInfo_TargetType_TargetType_MAX;
  static const int TargetType_ARRAYSIZE =
    SkillInfo_TargetType_TargetType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TargetType_descriptor() {
    return SkillInfo_TargetType_descriptor();
  }
  static inline const ::std::string& TargetType_Name(TargetType value) {
    return SkillInfo_TargetType_Name(value);
  }
  static inline bool TargetType_Parse(const ::std::string& name,
      TargetType* value) {
    return SkillInfo_TargetType_Parse(name, value);
  }
  
  typedef SkillInfo_StatusType StatusType;
  static const StatusType BEGIN = SkillInfo_StatusType_BEGIN;
  static const StatusType MOVE = SkillInfo_StatusType_MOVE;
  static const StatusType HIT = SkillInfo_StatusType_HIT;
  static const StatusType IDLE = SkillInfo_StatusType_IDLE;
  static inline bool StatusType_IsValid(int value) {
    return SkillInfo_StatusType_IsValid(value);
  }
  static const StatusType StatusType_MIN =
    SkillInfo_StatusType_StatusType_MIN;
  static const StatusType StatusType_MAX =
    SkillInfo_StatusType_StatusType_MAX;
  static const int StatusType_ARRAYSIZE =
    SkillInfo_StatusType_StatusType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StatusType_descriptor() {
    return SkillInfo_StatusType_descriptor();
  }
  static inline const ::std::string& StatusType_Name(StatusType value) {
    return SkillInfo_StatusType_Name(value);
  }
  static inline bool StatusType_Parse(const ::std::string& name,
      StatusType* value) {
    return SkillInfo_StatusType_Parse(name, value);
  }
  
  typedef SkillInfo_AreaType AreaType;
  static const AreaType ONE = SkillInfo_AreaType_ONE;
  static const AreaType SQUARE = SkillInfo_AreaType_SQUARE;
  static const AreaType LIST = SkillInfo_AreaType_LIST;
  static inline bool AreaType_IsValid(int value) {
    return SkillInfo_AreaType_IsValid(value);
  }
  static const AreaType AreaType_MIN =
    SkillInfo_AreaType_AreaType_MIN;
  static const AreaType AreaType_MAX =
    SkillInfo_AreaType_AreaType_MAX;
  static const int AreaType_ARRAYSIZE =
    SkillInfo_AreaType_AreaType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AreaType_descriptor() {
    return SkillInfo_AreaType_descriptor();
  }
  static inline const ::std::string& AreaType_Name(AreaType value) {
    return SkillInfo_AreaType_Name(value);
  }
  static inline bool AreaType_Parse(const ::std::string& name,
      AreaType* value) {
    return SkillInfo_AreaType_Parse(name, value);
  }
  
  typedef SkillInfo_ShockType ShockType;
  static const ShockType NONE = SkillInfo_ShockType_NONE;
  static const ShockType PREPARE_OVER = SkillInfo_ShockType_PREPARE_OVER;
  static const ShockType ON_HIT = SkillInfo_ShockType_ON_HIT;
  static const ShockType MOVETIME_OVER = SkillInfo_ShockType_MOVETIME_OVER;
  static inline bool ShockType_IsValid(int value) {
    return SkillInfo_ShockType_IsValid(value);
  }
  static const ShockType ShockType_MIN =
    SkillInfo_ShockType_ShockType_MIN;
  static const ShockType ShockType_MAX =
    SkillInfo_ShockType_ShockType_MAX;
  static const int ShockType_ARRAYSIZE =
    SkillInfo_ShockType_ShockType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ShockType_descriptor() {
    return SkillInfo_ShockType_descriptor();
  }
  static inline const ::std::string& ShockType_Name(ShockType value) {
    return SkillInfo_ShockType_Name(value);
  }
  static inline bool ShockType_Parse(const ::std::string& name,
      ShockType* value) {
    return SkillInfo_ShockType_Parse(name, value);
  }
  
  typedef SkillInfo_OffsetType OffsetType;
  static const OffsetType NO_OFFSET = SkillInfo_OffsetType_NO_OFFSET;
  static const OffsetType FRONT = SkillInfo_OffsetType_FRONT;
  static inline bool OffsetType_IsValid(int value) {
    return SkillInfo_OffsetType_IsValid(value);
  }
  static const OffsetType OffsetType_MIN =
    SkillInfo_OffsetType_OffsetType_MIN;
  static const OffsetType OffsetType_MAX =
    SkillInfo_OffsetType_OffsetType_MAX;
  static const int OffsetType_ARRAYSIZE =
    SkillInfo_OffsetType_OffsetType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OffsetType_descriptor() {
    return SkillInfo_OffsetType_descriptor();
  }
  static inline const ::std::string& OffsetType_Name(OffsetType value) {
    return SkillInfo_OffsetType_Name(value);
  }
  static inline bool OffsetType_Parse(const ::std::string& name,
      OffsetType* value) {
    return SkillInfo_OffsetType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // optional .SkillInfo.SkillType skillType = 4;
  inline bool has_skillType() const;
  inline void clear_skillType();
  static const int kSkillTypeFieldNumber = 4;
  inline ::SkillInfo_SkillType skillType() const;
  inline void set_skillType(::SkillInfo_SkillType value);
  
  // optional int32 cd = 5;
  inline bool has_cd() const;
  inline void clear_cd();
  static const int kCdFieldNumber = 5;
  inline ::google::protobuf::int32 cd() const;
  inline void set_cd(::google::protobuf::int32 value);
  
  // optional int32 prepareTime = 6;
  inline bool has_prepareTime() const;
  inline void clear_prepareTime();
  static const int kPrepareTimeFieldNumber = 6;
  inline ::google::protobuf::int32 prepareTime() const;
  inline void set_prepareTime(::google::protobuf::int32 value);
  
  // optional int32 hp = 7;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 7;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);
  
  // optional int32 mp = 8;
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMpFieldNumber = 8;
  inline ::google::protobuf::int32 mp() const;
  inline void set_mp(::google::protobuf::int32 value);
  
  // optional int64 gold = 9;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 9;
  inline ::google::protobuf::int64 gold() const;
  inline void set_gold(::google::protobuf::int64 value);
  
  // optional int32 energy = 10;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 10;
  inline ::google::protobuf::int32 energy() const;
  inline void set_energy(::google::protobuf::int32 value);
  
  // optional int32 dist = 11;
  inline bool has_dist() const;
  inline void clear_dist();
  static const int kDistFieldNumber = 11;
  inline ::google::protobuf::int32 dist() const;
  inline void set_dist(::google::protobuf::int32 value);
  
  // optional int32 targetType = 12;
  inline bool has_targetType() const;
  inline void clear_targetType();
  static const int kTargetTypeFieldNumber = 12;
  inline ::google::protobuf::int32 targetType() const;
  inline void set_targetType(::google::protobuf::int32 value);
  
  // optional int32 speed = 13;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 13;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);
  
  // optional int32 moveTime = 14;
  inline bool has_moveTime() const;
  inline void clear_moveTime();
  static const int kMoveTimeFieldNumber = 14;
  inline ::google::protobuf::int32 moveTime() const;
  inline void set_moveTime(::google::protobuf::int32 value);
  
  // optional .SkillInfo.TrackType trackType = 15;
  inline bool has_trackType() const;
  inline void clear_trackType();
  static const int kTrackTypeFieldNumber = 15;
  inline ::SkillInfo_TrackType trackType() const;
  inline void set_trackType(::SkillInfo_TrackType value);
  
  // optional bool canPenetrate = 16;
  inline bool has_canPenetrate() const;
  inline void clear_canPenetrate();
  static const int kCanPenetrateFieldNumber = 16;
  inline bool canPenetrate() const;
  inline void set_canPenetrate(bool value);
  
  // optional int32 radius = 17;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 17;
  inline ::google::protobuf::int32 radius() const;
  inline void set_radius(::google::protobuf::int32 value);
  
  // repeated int32 dStatusID = 18;
  inline int dStatusID_size() const;
  inline void clear_dStatusID();
  static const int kDStatusIDFieldNumber = 18;
  inline ::google::protobuf::int32 dStatusID(int index) const;
  inline void set_dStatusID(int index, ::google::protobuf::int32 value);
  inline void add_dStatusID(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dStatusID() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dStatusID();
  
  // optional int32 fStatusID = 19;
  inline bool has_fStatusID() const;
  inline void clear_fStatusID();
  static const int kFStatusIDFieldNumber = 19;
  inline ::google::protobuf::int32 fStatusID() const;
  inline void set_fStatusID(::google::protobuf::int32 value);
  
  // optional int32 aStatusID = 20;
  inline bool has_aStatusID() const;
  inline void clear_aStatusID();
  static const int kAStatusIDFieldNumber = 20;
  inline ::google::protobuf::int32 aStatusID() const;
  inline void set_aStatusID(::google::protobuf::int32 value);
  
  // optional int32 unitCount = 21;
  inline bool has_unitCount() const;
  inline void clear_unitCount();
  static const int kUnitCountFieldNumber = 21;
  inline ::google::protobuf::int32 unitCount() const;
  inline void set_unitCount(::google::protobuf::int32 value);
  
  // optional string fireAction = 22;
  inline bool has_fireAction() const;
  inline void clear_fireAction();
  static const int kFireActionFieldNumber = 22;
  inline const ::std::string& fireAction() const;
  inline void set_fireAction(const ::std::string& value);
  inline void set_fireAction(const char* value);
  inline void set_fireAction(const char* value, size_t size);
  inline ::std::string* mutable_fireAction();
  inline ::std::string* release_fireAction();
  
  // optional .SkillInfo.LaunchType launchType = 23;
  inline bool has_launchType() const;
  inline void clear_launchType();
  static const int kLaunchTypeFieldNumber = 23;
  inline ::SkillInfo_LaunchType launchType() const;
  inline void set_launchType(::SkillInfo_LaunchType value);
  
  // optional int32 hitTime = 24;
  inline bool has_hitTime() const;
  inline void clear_hitTime();
  static const int kHitTimeFieldNumber = 24;
  inline ::google::protobuf::int32 hitTime() const;
  inline void set_hitTime(::google::protobuf::int32 value);
  
  // optional .SkillInfo.AreaType areaType = 25;
  inline bool has_areaType() const;
  inline void clear_areaType();
  static const int kAreaTypeFieldNumber = 25;
  inline ::SkillInfo_AreaType areaType() const;
  inline void set_areaType(::SkillInfo_AreaType value);
  
  // optional int32 prepareAction = 26;
  inline bool has_prepareAction() const;
  inline void clear_prepareAction();
  static const int kPrepareActionFieldNumber = 26;
  inline ::google::protobuf::int32 prepareAction() const;
  inline void set_prepareAction(::google::protobuf::int32 value);
  
  // optional int32 moveAction = 27;
  inline bool has_moveAction() const;
  inline void clear_moveAction();
  static const int kMoveActionFieldNumber = 27;
  inline ::google::protobuf::int32 moveAction() const;
  inline void set_moveAction(::google::protobuf::int32 value);
  
  // optional int32 hitAction = 28;
  inline bool has_hitAction() const;
  inline void clear_hitAction();
  static const int kHitActionFieldNumber = 28;
  inline ::google::protobuf::int32 hitAction() const;
  inline void set_hitAction(::google::protobuf::int32 value);
  
  // optional int32 maxHit = 29;
  inline bool has_maxHit() const;
  inline void clear_maxHit();
  static const int kMaxHitFieldNumber = 29;
  inline ::google::protobuf::int32 maxHit() const;
  inline void set_maxHit(::google::protobuf::int32 value);
  
  // optional int32 next = 30;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 30;
  inline ::google::protobuf::int32 next() const;
  inline void set_next(::google::protobuf::int32 value);
  
  // optional int32 interval = 31;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 31;
  inline ::google::protobuf::int32 interval() const;
  inline void set_interval(::google::protobuf::int32 value);
  
  // optional int32 level = 32;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 32;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // optional int32 moveActionTime = 33;
  inline bool has_moveActionTime() const;
  inline void clear_moveActionTime();
  static const int kMoveActionTimeFieldNumber = 33;
  inline ::google::protobuf::int32 moveActionTime() const;
  inline void set_moveActionTime(::google::protobuf::int32 value);
  
  // optional int32 prepareActionTime = 34;
  inline bool has_prepareActionTime() const;
  inline void clear_prepareActionTime();
  static const int kPrepareActionTimeFieldNumber = 34;
  inline ::google::protobuf::int32 prepareActionTime() const;
  inline void set_prepareActionTime(::google::protobuf::int32 value);
  
  // optional int32 picture = 35;
  inline bool has_picture() const;
  inline void clear_picture();
  static const int kPictureFieldNumber = 35;
  inline ::google::protobuf::int32 picture() const;
  inline void set_picture(::google::protobuf::int32 value);
  
  // optional int32 requireLevel = 36;
  inline bool has_requireLevel() const;
  inline void clear_requireLevel();
  static const int kRequireLevelFieldNumber = 36;
  inline ::google::protobuf::int32 requireLevel() const;
  inline void set_requireLevel(::google::protobuf::int32 value);
  
  // optional bool isBeginFollowed = 37;
  inline bool has_isBeginFollowed() const;
  inline void clear_isBeginFollowed();
  static const int kIsBeginFollowedFieldNumber = 37;
  inline bool isBeginFollowed() const;
  inline void set_isBeginFollowed(bool value);
  
  // optional bool isHitFollowed = 38;
  inline bool has_isHitFollowed() const;
  inline void clear_isHitFollowed();
  static const int kIsHitFollowedFieldNumber = 38;
  inline bool isHitFollowed() const;
  inline void set_isHitFollowed(bool value);
  
  // optional bool raiseHit = 39;
  inline bool has_raiseHit() const;
  inline void clear_raiseHit();
  static const int kRaiseHitFieldNumber = 39;
  inline bool raiseHit() const;
  inline void set_raiseHit(bool value);
  
  // optional int32 fireActionTime = 40;
  inline bool has_fireActionTime() const;
  inline void clear_fireActionTime();
  static const int kFireActionTimeFieldNumber = 40;
  inline ::google::protobuf::int32 fireActionTime() const;
  inline void set_fireActionTime(::google::protobuf::int32 value);
  
  // optional int32 beginAudio = 41;
  inline bool has_beginAudio() const;
  inline void clear_beginAudio();
  static const int kBeginAudioFieldNumber = 41;
  inline ::google::protobuf::int32 beginAudio() const;
  inline void set_beginAudio(::google::protobuf::int32 value);
  
  // optional int32 hitAudio = 42;
  inline bool has_hitAudio() const;
  inline void clear_hitAudio();
  static const int kHitAudioFieldNumber = 42;
  inline ::google::protobuf::int32 hitAudio() const;
  inline void set_hitAudio(::google::protobuf::int32 value);
  
  // optional bool isMoveFollowed = 43;
  inline bool has_isMoveFollowed() const;
  inline void clear_isMoveFollowed();
  static const int kIsMoveFollowedFieldNumber = 43;
  inline bool isMoveFollowed() const;
  inline void set_isMoveFollowed(bool value);
  
  // optional .SkillInfo.ShockType shockType = 44;
  inline bool has_shockType() const;
  inline void clear_shockType();
  static const int kShockTypeFieldNumber = 44;
  inline ::SkillInfo_ShockType shockType() const;
  inline void set_shockType(::SkillInfo_ShockType value);
  
  // optional int32 hitNums = 45;
  inline bool has_hitNums() const;
  inline void clear_hitNums();
  static const int kHitNumsFieldNumber = 45;
  inline ::google::protobuf::int32 hitNums() const;
  inline void set_hitNums(::google::protobuf::int32 value);
  
  // optional .SkillInfo.OffsetType aOffsetType = 46;
  inline bool has_aOffsetType() const;
  inline void clear_aOffsetType();
  static const int kAOffsetTypeFieldNumber = 46;
  inline ::SkillInfo_OffsetType aOffsetType() const;
  inline void set_aOffsetType(::SkillInfo_OffsetType value);
  
  // optional .SkillInfo.OffsetType dOffsetType = 47;
  inline bool has_dOffsetType() const;
  inline void clear_dOffsetType();
  static const int kDOffsetTypeFieldNumber = 47;
  inline ::SkillInfo_OffsetType dOffsetType() const;
  inline void set_dOffsetType(::SkillInfo_OffsetType value);
  
  // optional int32 offsetTime = 48;
  inline bool has_offsetTime() const;
  inline void clear_offsetTime();
  static const int kOffsetTimeFieldNumber = 48;
  inline ::google::protobuf::int32 offsetTime() const;
  inline void set_offsetTime(::google::protobuf::int32 value);
  
  // optional float offsetDist = 49;
  inline bool has_offsetDist() const;
  inline void clear_offsetDist();
  static const int kOffsetDistFieldNumber = 49;
  inline float offsetDist() const;
  inline void set_offsetDist(float value);
  
  // optional int32 offsetDelay = 50;
  inline bool has_offsetDelay() const;
  inline void clear_offsetDelay();
  static const int kOffsetDelayFieldNumber = 50;
  inline ::google::protobuf::int32 offsetDelay() const;
  inline void set_offsetDelay(::google::protobuf::int32 value);
  
  // optional int32 goods = 51;
  inline bool has_goods() const;
  inline void clear_goods();
  static const int kGoodsFieldNumber = 51;
  inline ::google::protobuf::int32 goods() const;
  inline void set_goods(::google::protobuf::int32 value);
  
  // optional int32 count = 52;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 52;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SkillInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_skillType();
  inline void clear_has_skillType();
  inline void set_has_cd();
  inline void clear_has_cd();
  inline void set_has_prepareTime();
  inline void clear_has_prepareTime();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_mp();
  inline void clear_has_mp();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_dist();
  inline void clear_has_dist();
  inline void set_has_targetType();
  inline void clear_has_targetType();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_moveTime();
  inline void clear_has_moveTime();
  inline void set_has_trackType();
  inline void clear_has_trackType();
  inline void set_has_canPenetrate();
  inline void clear_has_canPenetrate();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_fStatusID();
  inline void clear_has_fStatusID();
  inline void set_has_aStatusID();
  inline void clear_has_aStatusID();
  inline void set_has_unitCount();
  inline void clear_has_unitCount();
  inline void set_has_fireAction();
  inline void clear_has_fireAction();
  inline void set_has_launchType();
  inline void clear_has_launchType();
  inline void set_has_hitTime();
  inline void clear_has_hitTime();
  inline void set_has_areaType();
  inline void clear_has_areaType();
  inline void set_has_prepareAction();
  inline void clear_has_prepareAction();
  inline void set_has_moveAction();
  inline void clear_has_moveAction();
  inline void set_has_hitAction();
  inline void clear_has_hitAction();
  inline void set_has_maxHit();
  inline void clear_has_maxHit();
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_interval();
  inline void clear_has_interval();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_moveActionTime();
  inline void clear_has_moveActionTime();
  inline void set_has_prepareActionTime();
  inline void clear_has_prepareActionTime();
  inline void set_has_picture();
  inline void clear_has_picture();
  inline void set_has_requireLevel();
  inline void clear_has_requireLevel();
  inline void set_has_isBeginFollowed();
  inline void clear_has_isBeginFollowed();
  inline void set_has_isHitFollowed();
  inline void clear_has_isHitFollowed();
  inline void set_has_raiseHit();
  inline void clear_has_raiseHit();
  inline void set_has_fireActionTime();
  inline void clear_has_fireActionTime();
  inline void set_has_beginAudio();
  inline void clear_has_beginAudio();
  inline void set_has_hitAudio();
  inline void clear_has_hitAudio();
  inline void set_has_isMoveFollowed();
  inline void clear_has_isMoveFollowed();
  inline void set_has_shockType();
  inline void clear_has_shockType();
  inline void set_has_hitNums();
  inline void clear_has_hitNums();
  inline void set_has_aOffsetType();
  inline void clear_has_aOffsetType();
  inline void set_has_dOffsetType();
  inline void clear_has_dOffsetType();
  inline void set_has_offsetTime();
  inline void clear_has_offsetTime();
  inline void set_has_offsetDist();
  inline void clear_has_offsetDist();
  inline void set_has_offsetDelay();
  inline void clear_has_offsetDelay();
  inline void set_has_goods();
  inline void clear_has_goods();
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  int skillType_;
  ::std::string* desc_;
  ::google::protobuf::int32 cd_;
  ::google::protobuf::int32 prepareTime_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 mp_;
  ::google::protobuf::int64 gold_;
  ::google::protobuf::int32 energy_;
  ::google::protobuf::int32 dist_;
  ::google::protobuf::int32 targetType_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 moveTime_;
  int trackType_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dStatusID_;
  ::google::protobuf::int32 radius_;
  ::google::protobuf::int32 fStatusID_;
  ::google::protobuf::int32 aStatusID_;
  ::google::protobuf::int32 unitCount_;
  ::std::string* fireAction_;
  int launchType_;
  ::google::protobuf::int32 hitTime_;
  int areaType_;
  ::google::protobuf::int32 prepareAction_;
  ::google::protobuf::int32 moveAction_;
  ::google::protobuf::int32 hitAction_;
  ::google::protobuf::int32 maxHit_;
  ::google::protobuf::int32 next_;
  ::google::protobuf::int32 interval_;
  ::google::protobuf::int32 level_;
  bool canPenetrate_;
  bool isBeginFollowed_;
  bool isHitFollowed_;
  bool raiseHit_;
  ::google::protobuf::int32 moveActionTime_;
  ::google::protobuf::int32 prepareActionTime_;
  ::google::protobuf::int32 picture_;
  ::google::protobuf::int32 requireLevel_;
  ::google::protobuf::int32 fireActionTime_;
  ::google::protobuf::int32 beginAudio_;
  ::google::protobuf::int32 hitAudio_;
  bool isMoveFollowed_;
  int shockType_;
  ::google::protobuf::int32 hitNums_;
  int aOffsetType_;
  int dOffsetType_;
  ::google::protobuf::int32 offsetTime_;
  float offsetDist_;
  ::google::protobuf::int32 offsetDelay_;
  ::google::protobuf::int32 goods_;
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(52 + 31) / 32];
  
  friend void  protobuf_AddDesc_SkillInfo_2eproto();
  friend void protobuf_AssignDesc_SkillInfo_2eproto();
  friend void protobuf_ShutdownFile_SkillInfo_2eproto();
  
  void InitAsDefaultInstance();
  static SkillInfo* default_instance_;
};
// -------------------------------------------------------------------

class SkillFamily : public ::google::protobuf::Message {
 public:
  SkillFamily();
  virtual ~SkillFamily();
  
  SkillFamily(const SkillFamily& from);
  
  inline SkillFamily& operator=(const SkillFamily& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillFamily& default_instance();
  
  void Swap(SkillFamily* other);
  
  // implements Message ----------------------------------------------
  
  SkillFamily* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillFamily& from);
  void MergeFrom(const SkillFamily& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .SkillInfo skills = 1;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 1;
  inline const ::SkillInfo& skills(int index) const;
  inline ::SkillInfo* mutable_skills(int index);
  inline ::SkillInfo* add_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::SkillInfo >&
      skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::SkillInfo >*
      mutable_skills();
  
  // @@protoc_insertion_point(class_scope:SkillFamily)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::SkillInfo > skills_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SkillInfo_2eproto();
  friend void protobuf_AssignDesc_SkillInfo_2eproto();
  friend void protobuf_ShutdownFile_SkillInfo_2eproto();
  
  void InitAsDefaultInstance();
  static SkillFamily* default_instance_;
};
// -------------------------------------------------------------------

class AllSkills : public ::google::protobuf::Message {
 public:
  AllSkills();
  virtual ~AllSkills();
  
  AllSkills(const AllSkills& from);
  
  inline AllSkills& operator=(const AllSkills& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllSkills& default_instance();
  
  void Swap(AllSkills* other);
  
  // implements Message ----------------------------------------------
  
  AllSkills* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllSkills& from);
  void MergeFrom(const AllSkills& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .SkillFamily skills = 1;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 1;
  inline const ::SkillFamily& skills(int index) const;
  inline ::SkillFamily* mutable_skills(int index);
  inline ::SkillFamily* add_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::SkillFamily >&
      skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::SkillFamily >*
      mutable_skills();
  
  // @@protoc_insertion_point(class_scope:AllSkills)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::SkillFamily > skills_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SkillInfo_2eproto();
  friend void protobuf_AssignDesc_SkillInfo_2eproto();
  friend void protobuf_ShutdownFile_SkillInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AllSkills* default_instance_;
};
// ===================================================================


// ===================================================================

// SkillInfo

// optional int32 id = 1;
inline bool SkillInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SkillInfo::id() const {
  return id_;
}
inline void SkillInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool SkillInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SkillInfo::name() const {
  return *name_;
}
inline void SkillInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SkillInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SkillInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SkillInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string desc = 3;
inline bool SkillInfo::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkillInfo::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkillInfo::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkillInfo::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& SkillInfo::desc() const {
  return *desc_;
}
inline void SkillInfo::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void SkillInfo::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void SkillInfo::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillInfo::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* SkillInfo::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .SkillInfo.SkillType skillType = 4;
inline bool SkillInfo::has_skillType() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkillInfo::set_has_skillType() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkillInfo::clear_has_skillType() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkillInfo::clear_skillType() {
  skillType_ = 0;
  clear_has_skillType();
}
inline ::SkillInfo_SkillType SkillInfo::skillType() const {
  return static_cast< ::SkillInfo_SkillType >(skillType_);
}
inline void SkillInfo::set_skillType(::SkillInfo_SkillType value) {
  GOOGLE_DCHECK(::SkillInfo_SkillType_IsValid(value));
  set_has_skillType();
  skillType_ = value;
}

// optional int32 cd = 5;
inline bool SkillInfo::has_cd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SkillInfo::set_has_cd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SkillInfo::clear_has_cd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SkillInfo::clear_cd() {
  cd_ = 0;
  clear_has_cd();
}
inline ::google::protobuf::int32 SkillInfo::cd() const {
  return cd_;
}
inline void SkillInfo::set_cd(::google::protobuf::int32 value) {
  set_has_cd();
  cd_ = value;
}

// optional int32 prepareTime = 6;
inline bool SkillInfo::has_prepareTime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SkillInfo::set_has_prepareTime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SkillInfo::clear_has_prepareTime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SkillInfo::clear_prepareTime() {
  prepareTime_ = 0;
  clear_has_prepareTime();
}
inline ::google::protobuf::int32 SkillInfo::prepareTime() const {
  return prepareTime_;
}
inline void SkillInfo::set_prepareTime(::google::protobuf::int32 value) {
  set_has_prepareTime();
  prepareTime_ = value;
}

// optional int32 hp = 7;
inline bool SkillInfo::has_hp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SkillInfo::set_has_hp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SkillInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SkillInfo::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 SkillInfo::hp() const {
  return hp_;
}
inline void SkillInfo::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional int32 mp = 8;
inline bool SkillInfo::has_mp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SkillInfo::set_has_mp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SkillInfo::clear_has_mp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SkillInfo::clear_mp() {
  mp_ = 0;
  clear_has_mp();
}
inline ::google::protobuf::int32 SkillInfo::mp() const {
  return mp_;
}
inline void SkillInfo::set_mp(::google::protobuf::int32 value) {
  set_has_mp();
  mp_ = value;
}

// optional int64 gold = 9;
inline bool SkillInfo::has_gold() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SkillInfo::set_has_gold() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SkillInfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SkillInfo::clear_gold() {
  gold_ = GOOGLE_LONGLONG(0);
  clear_has_gold();
}
inline ::google::protobuf::int64 SkillInfo::gold() const {
  return gold_;
}
inline void SkillInfo::set_gold(::google::protobuf::int64 value) {
  set_has_gold();
  gold_ = value;
}

// optional int32 energy = 10;
inline bool SkillInfo::has_energy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SkillInfo::set_has_energy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SkillInfo::clear_has_energy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SkillInfo::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline ::google::protobuf::int32 SkillInfo::energy() const {
  return energy_;
}
inline void SkillInfo::set_energy(::google::protobuf::int32 value) {
  set_has_energy();
  energy_ = value;
}

// optional int32 dist = 11;
inline bool SkillInfo::has_dist() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SkillInfo::set_has_dist() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SkillInfo::clear_has_dist() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SkillInfo::clear_dist() {
  dist_ = 0;
  clear_has_dist();
}
inline ::google::protobuf::int32 SkillInfo::dist() const {
  return dist_;
}
inline void SkillInfo::set_dist(::google::protobuf::int32 value) {
  set_has_dist();
  dist_ = value;
}

// optional int32 targetType = 12;
inline bool SkillInfo::has_targetType() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SkillInfo::set_has_targetType() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SkillInfo::clear_has_targetType() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SkillInfo::clear_targetType() {
  targetType_ = 0;
  clear_has_targetType();
}
inline ::google::protobuf::int32 SkillInfo::targetType() const {
  return targetType_;
}
inline void SkillInfo::set_targetType(::google::protobuf::int32 value) {
  set_has_targetType();
  targetType_ = value;
}

// optional int32 speed = 13;
inline bool SkillInfo::has_speed() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SkillInfo::set_has_speed() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SkillInfo::clear_has_speed() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SkillInfo::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 SkillInfo::speed() const {
  return speed_;
}
inline void SkillInfo::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
}

// optional int32 moveTime = 14;
inline bool SkillInfo::has_moveTime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SkillInfo::set_has_moveTime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SkillInfo::clear_has_moveTime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SkillInfo::clear_moveTime() {
  moveTime_ = 0;
  clear_has_moveTime();
}
inline ::google::protobuf::int32 SkillInfo::moveTime() const {
  return moveTime_;
}
inline void SkillInfo::set_moveTime(::google::protobuf::int32 value) {
  set_has_moveTime();
  moveTime_ = value;
}

// optional .SkillInfo.TrackType trackType = 15;
inline bool SkillInfo::has_trackType() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SkillInfo::set_has_trackType() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SkillInfo::clear_has_trackType() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SkillInfo::clear_trackType() {
  trackType_ = 0;
  clear_has_trackType();
}
inline ::SkillInfo_TrackType SkillInfo::trackType() const {
  return static_cast< ::SkillInfo_TrackType >(trackType_);
}
inline void SkillInfo::set_trackType(::SkillInfo_TrackType value) {
  GOOGLE_DCHECK(::SkillInfo_TrackType_IsValid(value));
  set_has_trackType();
  trackType_ = value;
}

// optional bool canPenetrate = 16;
inline bool SkillInfo::has_canPenetrate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SkillInfo::set_has_canPenetrate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SkillInfo::clear_has_canPenetrate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SkillInfo::clear_canPenetrate() {
  canPenetrate_ = false;
  clear_has_canPenetrate();
}
inline bool SkillInfo::canPenetrate() const {
  return canPenetrate_;
}
inline void SkillInfo::set_canPenetrate(bool value) {
  set_has_canPenetrate();
  canPenetrate_ = value;
}

// optional int32 radius = 17;
inline bool SkillInfo::has_radius() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SkillInfo::set_has_radius() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SkillInfo::clear_has_radius() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SkillInfo::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline ::google::protobuf::int32 SkillInfo::radius() const {
  return radius_;
}
inline void SkillInfo::set_radius(::google::protobuf::int32 value) {
  set_has_radius();
  radius_ = value;
}

// repeated int32 dStatusID = 18;
inline int SkillInfo::dStatusID_size() const {
  return dStatusID_.size();
}
inline void SkillInfo::clear_dStatusID() {
  dStatusID_.Clear();
}
inline ::google::protobuf::int32 SkillInfo::dStatusID(int index) const {
  return dStatusID_.Get(index);
}
inline void SkillInfo::set_dStatusID(int index, ::google::protobuf::int32 value) {
  dStatusID_.Set(index, value);
}
inline void SkillInfo::add_dStatusID(::google::protobuf::int32 value) {
  dStatusID_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SkillInfo::dStatusID() const {
  return dStatusID_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SkillInfo::mutable_dStatusID() {
  return &dStatusID_;
}

// optional int32 fStatusID = 19;
inline bool SkillInfo::has_fStatusID() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SkillInfo::set_has_fStatusID() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SkillInfo::clear_has_fStatusID() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SkillInfo::clear_fStatusID() {
  fStatusID_ = 0;
  clear_has_fStatusID();
}
inline ::google::protobuf::int32 SkillInfo::fStatusID() const {
  return fStatusID_;
}
inline void SkillInfo::set_fStatusID(::google::protobuf::int32 value) {
  set_has_fStatusID();
  fStatusID_ = value;
}

// optional int32 aStatusID = 20;
inline bool SkillInfo::has_aStatusID() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SkillInfo::set_has_aStatusID() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SkillInfo::clear_has_aStatusID() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SkillInfo::clear_aStatusID() {
  aStatusID_ = 0;
  clear_has_aStatusID();
}
inline ::google::protobuf::int32 SkillInfo::aStatusID() const {
  return aStatusID_;
}
inline void SkillInfo::set_aStatusID(::google::protobuf::int32 value) {
  set_has_aStatusID();
  aStatusID_ = value;
}

// optional int32 unitCount = 21;
inline bool SkillInfo::has_unitCount() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SkillInfo::set_has_unitCount() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SkillInfo::clear_has_unitCount() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SkillInfo::clear_unitCount() {
  unitCount_ = 0;
  clear_has_unitCount();
}
inline ::google::protobuf::int32 SkillInfo::unitCount() const {
  return unitCount_;
}
inline void SkillInfo::set_unitCount(::google::protobuf::int32 value) {
  set_has_unitCount();
  unitCount_ = value;
}

// optional string fireAction = 22;
inline bool SkillInfo::has_fireAction() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SkillInfo::set_has_fireAction() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SkillInfo::clear_has_fireAction() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SkillInfo::clear_fireAction() {
  if (fireAction_ != &::google::protobuf::internal::kEmptyString) {
    fireAction_->clear();
  }
  clear_has_fireAction();
}
inline const ::std::string& SkillInfo::fireAction() const {
  return *fireAction_;
}
inline void SkillInfo::set_fireAction(const ::std::string& value) {
  set_has_fireAction();
  if (fireAction_ == &::google::protobuf::internal::kEmptyString) {
    fireAction_ = new ::std::string;
  }
  fireAction_->assign(value);
}
inline void SkillInfo::set_fireAction(const char* value) {
  set_has_fireAction();
  if (fireAction_ == &::google::protobuf::internal::kEmptyString) {
    fireAction_ = new ::std::string;
  }
  fireAction_->assign(value);
}
inline void SkillInfo::set_fireAction(const char* value, size_t size) {
  set_has_fireAction();
  if (fireAction_ == &::google::protobuf::internal::kEmptyString) {
    fireAction_ = new ::std::string;
  }
  fireAction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillInfo::mutable_fireAction() {
  set_has_fireAction();
  if (fireAction_ == &::google::protobuf::internal::kEmptyString) {
    fireAction_ = new ::std::string;
  }
  return fireAction_;
}
inline ::std::string* SkillInfo::release_fireAction() {
  clear_has_fireAction();
  if (fireAction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fireAction_;
    fireAction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .SkillInfo.LaunchType launchType = 23;
inline bool SkillInfo::has_launchType() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SkillInfo::set_has_launchType() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SkillInfo::clear_has_launchType() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SkillInfo::clear_launchType() {
  launchType_ = 0;
  clear_has_launchType();
}
inline ::SkillInfo_LaunchType SkillInfo::launchType() const {
  return static_cast< ::SkillInfo_LaunchType >(launchType_);
}
inline void SkillInfo::set_launchType(::SkillInfo_LaunchType value) {
  GOOGLE_DCHECK(::SkillInfo_LaunchType_IsValid(value));
  set_has_launchType();
  launchType_ = value;
}

// optional int32 hitTime = 24;
inline bool SkillInfo::has_hitTime() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SkillInfo::set_has_hitTime() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SkillInfo::clear_has_hitTime() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SkillInfo::clear_hitTime() {
  hitTime_ = 0;
  clear_has_hitTime();
}
inline ::google::protobuf::int32 SkillInfo::hitTime() const {
  return hitTime_;
}
inline void SkillInfo::set_hitTime(::google::protobuf::int32 value) {
  set_has_hitTime();
  hitTime_ = value;
}

// optional .SkillInfo.AreaType areaType = 25;
inline bool SkillInfo::has_areaType() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SkillInfo::set_has_areaType() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SkillInfo::clear_has_areaType() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SkillInfo::clear_areaType() {
  areaType_ = 0;
  clear_has_areaType();
}
inline ::SkillInfo_AreaType SkillInfo::areaType() const {
  return static_cast< ::SkillInfo_AreaType >(areaType_);
}
inline void SkillInfo::set_areaType(::SkillInfo_AreaType value) {
  GOOGLE_DCHECK(::SkillInfo_AreaType_IsValid(value));
  set_has_areaType();
  areaType_ = value;
}

// optional int32 prepareAction = 26;
inline bool SkillInfo::has_prepareAction() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SkillInfo::set_has_prepareAction() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SkillInfo::clear_has_prepareAction() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SkillInfo::clear_prepareAction() {
  prepareAction_ = 0;
  clear_has_prepareAction();
}
inline ::google::protobuf::int32 SkillInfo::prepareAction() const {
  return prepareAction_;
}
inline void SkillInfo::set_prepareAction(::google::protobuf::int32 value) {
  set_has_prepareAction();
  prepareAction_ = value;
}

// optional int32 moveAction = 27;
inline bool SkillInfo::has_moveAction() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SkillInfo::set_has_moveAction() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SkillInfo::clear_has_moveAction() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SkillInfo::clear_moveAction() {
  moveAction_ = 0;
  clear_has_moveAction();
}
inline ::google::protobuf::int32 SkillInfo::moveAction() const {
  return moveAction_;
}
inline void SkillInfo::set_moveAction(::google::protobuf::int32 value) {
  set_has_moveAction();
  moveAction_ = value;
}

// optional int32 hitAction = 28;
inline bool SkillInfo::has_hitAction() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SkillInfo::set_has_hitAction() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SkillInfo::clear_has_hitAction() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SkillInfo::clear_hitAction() {
  hitAction_ = 0;
  clear_has_hitAction();
}
inline ::google::protobuf::int32 SkillInfo::hitAction() const {
  return hitAction_;
}
inline void SkillInfo::set_hitAction(::google::protobuf::int32 value) {
  set_has_hitAction();
  hitAction_ = value;
}

// optional int32 maxHit = 29;
inline bool SkillInfo::has_maxHit() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SkillInfo::set_has_maxHit() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SkillInfo::clear_has_maxHit() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SkillInfo::clear_maxHit() {
  maxHit_ = 0;
  clear_has_maxHit();
}
inline ::google::protobuf::int32 SkillInfo::maxHit() const {
  return maxHit_;
}
inline void SkillInfo::set_maxHit(::google::protobuf::int32 value) {
  set_has_maxHit();
  maxHit_ = value;
}

// optional int32 next = 30;
inline bool SkillInfo::has_next() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SkillInfo::set_has_next() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SkillInfo::clear_has_next() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SkillInfo::clear_next() {
  next_ = 0;
  clear_has_next();
}
inline ::google::protobuf::int32 SkillInfo::next() const {
  return next_;
}
inline void SkillInfo::set_next(::google::protobuf::int32 value) {
  set_has_next();
  next_ = value;
}

// optional int32 interval = 31;
inline bool SkillInfo::has_interval() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void SkillInfo::set_has_interval() {
  _has_bits_[0] |= 0x40000000u;
}
inline void SkillInfo::clear_has_interval() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void SkillInfo::clear_interval() {
  interval_ = 0;
  clear_has_interval();
}
inline ::google::protobuf::int32 SkillInfo::interval() const {
  return interval_;
}
inline void SkillInfo::set_interval(::google::protobuf::int32 value) {
  set_has_interval();
  interval_ = value;
}

// optional int32 level = 32;
inline bool SkillInfo::has_level() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void SkillInfo::set_has_level() {
  _has_bits_[0] |= 0x80000000u;
}
inline void SkillInfo::clear_has_level() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void SkillInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 SkillInfo::level() const {
  return level_;
}
inline void SkillInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 moveActionTime = 33;
inline bool SkillInfo::has_moveActionTime() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void SkillInfo::set_has_moveActionTime() {
  _has_bits_[1] |= 0x00000001u;
}
inline void SkillInfo::clear_has_moveActionTime() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void SkillInfo::clear_moveActionTime() {
  moveActionTime_ = 0;
  clear_has_moveActionTime();
}
inline ::google::protobuf::int32 SkillInfo::moveActionTime() const {
  return moveActionTime_;
}
inline void SkillInfo::set_moveActionTime(::google::protobuf::int32 value) {
  set_has_moveActionTime();
  moveActionTime_ = value;
}

// optional int32 prepareActionTime = 34;
inline bool SkillInfo::has_prepareActionTime() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void SkillInfo::set_has_prepareActionTime() {
  _has_bits_[1] |= 0x00000002u;
}
inline void SkillInfo::clear_has_prepareActionTime() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void SkillInfo::clear_prepareActionTime() {
  prepareActionTime_ = 0;
  clear_has_prepareActionTime();
}
inline ::google::protobuf::int32 SkillInfo::prepareActionTime() const {
  return prepareActionTime_;
}
inline void SkillInfo::set_prepareActionTime(::google::protobuf::int32 value) {
  set_has_prepareActionTime();
  prepareActionTime_ = value;
}

// optional int32 picture = 35;
inline bool SkillInfo::has_picture() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void SkillInfo::set_has_picture() {
  _has_bits_[1] |= 0x00000004u;
}
inline void SkillInfo::clear_has_picture() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void SkillInfo::clear_picture() {
  picture_ = 0;
  clear_has_picture();
}
inline ::google::protobuf::int32 SkillInfo::picture() const {
  return picture_;
}
inline void SkillInfo::set_picture(::google::protobuf::int32 value) {
  set_has_picture();
  picture_ = value;
}

// optional int32 requireLevel = 36;
inline bool SkillInfo::has_requireLevel() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void SkillInfo::set_has_requireLevel() {
  _has_bits_[1] |= 0x00000008u;
}
inline void SkillInfo::clear_has_requireLevel() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void SkillInfo::clear_requireLevel() {
  requireLevel_ = 0;
  clear_has_requireLevel();
}
inline ::google::protobuf::int32 SkillInfo::requireLevel() const {
  return requireLevel_;
}
inline void SkillInfo::set_requireLevel(::google::protobuf::int32 value) {
  set_has_requireLevel();
  requireLevel_ = value;
}

// optional bool isBeginFollowed = 37;
inline bool SkillInfo::has_isBeginFollowed() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void SkillInfo::set_has_isBeginFollowed() {
  _has_bits_[1] |= 0x00000010u;
}
inline void SkillInfo::clear_has_isBeginFollowed() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void SkillInfo::clear_isBeginFollowed() {
  isBeginFollowed_ = false;
  clear_has_isBeginFollowed();
}
inline bool SkillInfo::isBeginFollowed() const {
  return isBeginFollowed_;
}
inline void SkillInfo::set_isBeginFollowed(bool value) {
  set_has_isBeginFollowed();
  isBeginFollowed_ = value;
}

// optional bool isHitFollowed = 38;
inline bool SkillInfo::has_isHitFollowed() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void SkillInfo::set_has_isHitFollowed() {
  _has_bits_[1] |= 0x00000020u;
}
inline void SkillInfo::clear_has_isHitFollowed() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void SkillInfo::clear_isHitFollowed() {
  isHitFollowed_ = false;
  clear_has_isHitFollowed();
}
inline bool SkillInfo::isHitFollowed() const {
  return isHitFollowed_;
}
inline void SkillInfo::set_isHitFollowed(bool value) {
  set_has_isHitFollowed();
  isHitFollowed_ = value;
}

// optional bool raiseHit = 39;
inline bool SkillInfo::has_raiseHit() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void SkillInfo::set_has_raiseHit() {
  _has_bits_[1] |= 0x00000040u;
}
inline void SkillInfo::clear_has_raiseHit() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void SkillInfo::clear_raiseHit() {
  raiseHit_ = false;
  clear_has_raiseHit();
}
inline bool SkillInfo::raiseHit() const {
  return raiseHit_;
}
inline void SkillInfo::set_raiseHit(bool value) {
  set_has_raiseHit();
  raiseHit_ = value;
}

// optional int32 fireActionTime = 40;
inline bool SkillInfo::has_fireActionTime() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void SkillInfo::set_has_fireActionTime() {
  _has_bits_[1] |= 0x00000080u;
}
inline void SkillInfo::clear_has_fireActionTime() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void SkillInfo::clear_fireActionTime() {
  fireActionTime_ = 0;
  clear_has_fireActionTime();
}
inline ::google::protobuf::int32 SkillInfo::fireActionTime() const {
  return fireActionTime_;
}
inline void SkillInfo::set_fireActionTime(::google::protobuf::int32 value) {
  set_has_fireActionTime();
  fireActionTime_ = value;
}

// optional int32 beginAudio = 41;
inline bool SkillInfo::has_beginAudio() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void SkillInfo::set_has_beginAudio() {
  _has_bits_[1] |= 0x00000100u;
}
inline void SkillInfo::clear_has_beginAudio() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void SkillInfo::clear_beginAudio() {
  beginAudio_ = 0;
  clear_has_beginAudio();
}
inline ::google::protobuf::int32 SkillInfo::beginAudio() const {
  return beginAudio_;
}
inline void SkillInfo::set_beginAudio(::google::protobuf::int32 value) {
  set_has_beginAudio();
  beginAudio_ = value;
}

// optional int32 hitAudio = 42;
inline bool SkillInfo::has_hitAudio() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void SkillInfo::set_has_hitAudio() {
  _has_bits_[1] |= 0x00000200u;
}
inline void SkillInfo::clear_has_hitAudio() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void SkillInfo::clear_hitAudio() {
  hitAudio_ = 0;
  clear_has_hitAudio();
}
inline ::google::protobuf::int32 SkillInfo::hitAudio() const {
  return hitAudio_;
}
inline void SkillInfo::set_hitAudio(::google::protobuf::int32 value) {
  set_has_hitAudio();
  hitAudio_ = value;
}

// optional bool isMoveFollowed = 43;
inline bool SkillInfo::has_isMoveFollowed() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void SkillInfo::set_has_isMoveFollowed() {
  _has_bits_[1] |= 0x00000400u;
}
inline void SkillInfo::clear_has_isMoveFollowed() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void SkillInfo::clear_isMoveFollowed() {
  isMoveFollowed_ = false;
  clear_has_isMoveFollowed();
}
inline bool SkillInfo::isMoveFollowed() const {
  return isMoveFollowed_;
}
inline void SkillInfo::set_isMoveFollowed(bool value) {
  set_has_isMoveFollowed();
  isMoveFollowed_ = value;
}

// optional .SkillInfo.ShockType shockType = 44;
inline bool SkillInfo::has_shockType() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void SkillInfo::set_has_shockType() {
  _has_bits_[1] |= 0x00000800u;
}
inline void SkillInfo::clear_has_shockType() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void SkillInfo::clear_shockType() {
  shockType_ = 0;
  clear_has_shockType();
}
inline ::SkillInfo_ShockType SkillInfo::shockType() const {
  return static_cast< ::SkillInfo_ShockType >(shockType_);
}
inline void SkillInfo::set_shockType(::SkillInfo_ShockType value) {
  GOOGLE_DCHECK(::SkillInfo_ShockType_IsValid(value));
  set_has_shockType();
  shockType_ = value;
}

// optional int32 hitNums = 45;
inline bool SkillInfo::has_hitNums() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void SkillInfo::set_has_hitNums() {
  _has_bits_[1] |= 0x00001000u;
}
inline void SkillInfo::clear_has_hitNums() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void SkillInfo::clear_hitNums() {
  hitNums_ = 0;
  clear_has_hitNums();
}
inline ::google::protobuf::int32 SkillInfo::hitNums() const {
  return hitNums_;
}
inline void SkillInfo::set_hitNums(::google::protobuf::int32 value) {
  set_has_hitNums();
  hitNums_ = value;
}

// optional .SkillInfo.OffsetType aOffsetType = 46;
inline bool SkillInfo::has_aOffsetType() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void SkillInfo::set_has_aOffsetType() {
  _has_bits_[1] |= 0x00002000u;
}
inline void SkillInfo::clear_has_aOffsetType() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void SkillInfo::clear_aOffsetType() {
  aOffsetType_ = 0;
  clear_has_aOffsetType();
}
inline ::SkillInfo_OffsetType SkillInfo::aOffsetType() const {
  return static_cast< ::SkillInfo_OffsetType >(aOffsetType_);
}
inline void SkillInfo::set_aOffsetType(::SkillInfo_OffsetType value) {
  GOOGLE_DCHECK(::SkillInfo_OffsetType_IsValid(value));
  set_has_aOffsetType();
  aOffsetType_ = value;
}

// optional .SkillInfo.OffsetType dOffsetType = 47;
inline bool SkillInfo::has_dOffsetType() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void SkillInfo::set_has_dOffsetType() {
  _has_bits_[1] |= 0x00004000u;
}
inline void SkillInfo::clear_has_dOffsetType() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void SkillInfo::clear_dOffsetType() {
  dOffsetType_ = 0;
  clear_has_dOffsetType();
}
inline ::SkillInfo_OffsetType SkillInfo::dOffsetType() const {
  return static_cast< ::SkillInfo_OffsetType >(dOffsetType_);
}
inline void SkillInfo::set_dOffsetType(::SkillInfo_OffsetType value) {
  GOOGLE_DCHECK(::SkillInfo_OffsetType_IsValid(value));
  set_has_dOffsetType();
  dOffsetType_ = value;
}

// optional int32 offsetTime = 48;
inline bool SkillInfo::has_offsetTime() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void SkillInfo::set_has_offsetTime() {
  _has_bits_[1] |= 0x00008000u;
}
inline void SkillInfo::clear_has_offsetTime() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void SkillInfo::clear_offsetTime() {
  offsetTime_ = 0;
  clear_has_offsetTime();
}
inline ::google::protobuf::int32 SkillInfo::offsetTime() const {
  return offsetTime_;
}
inline void SkillInfo::set_offsetTime(::google::protobuf::int32 value) {
  set_has_offsetTime();
  offsetTime_ = value;
}

// optional float offsetDist = 49;
inline bool SkillInfo::has_offsetDist() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void SkillInfo::set_has_offsetDist() {
  _has_bits_[1] |= 0x00010000u;
}
inline void SkillInfo::clear_has_offsetDist() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void SkillInfo::clear_offsetDist() {
  offsetDist_ = 0;
  clear_has_offsetDist();
}
inline float SkillInfo::offsetDist() const {
  return offsetDist_;
}
inline void SkillInfo::set_offsetDist(float value) {
  set_has_offsetDist();
  offsetDist_ = value;
}

// optional int32 offsetDelay = 50;
inline bool SkillInfo::has_offsetDelay() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void SkillInfo::set_has_offsetDelay() {
  _has_bits_[1] |= 0x00020000u;
}
inline void SkillInfo::clear_has_offsetDelay() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void SkillInfo::clear_offsetDelay() {
  offsetDelay_ = 0;
  clear_has_offsetDelay();
}
inline ::google::protobuf::int32 SkillInfo::offsetDelay() const {
  return offsetDelay_;
}
inline void SkillInfo::set_offsetDelay(::google::protobuf::int32 value) {
  set_has_offsetDelay();
  offsetDelay_ = value;
}

// optional int32 goods = 51;
inline bool SkillInfo::has_goods() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void SkillInfo::set_has_goods() {
  _has_bits_[1] |= 0x00040000u;
}
inline void SkillInfo::clear_has_goods() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void SkillInfo::clear_goods() {
  goods_ = 0;
  clear_has_goods();
}
inline ::google::protobuf::int32 SkillInfo::goods() const {
  return goods_;
}
inline void SkillInfo::set_goods(::google::protobuf::int32 value) {
  set_has_goods();
  goods_ = value;
}

// optional int32 count = 52;
inline bool SkillInfo::has_count() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void SkillInfo::set_has_count() {
  _has_bits_[1] |= 0x00080000u;
}
inline void SkillInfo::clear_has_count() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void SkillInfo::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 SkillInfo::count() const {
  return count_;
}
inline void SkillInfo::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// SkillFamily

// repeated .SkillInfo skills = 1;
inline int SkillFamily::skills_size() const {
  return skills_.size();
}
inline void SkillFamily::clear_skills() {
  skills_.Clear();
}
inline const ::SkillInfo& SkillFamily::skills(int index) const {
  return skills_.Get(index);
}
inline ::SkillInfo* SkillFamily::mutable_skills(int index) {
  return skills_.Mutable(index);
}
inline ::SkillInfo* SkillFamily::add_skills() {
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SkillInfo >&
SkillFamily::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::SkillInfo >*
SkillFamily::mutable_skills() {
  return &skills_;
}

// -------------------------------------------------------------------

// AllSkills

// repeated .SkillFamily skills = 1;
inline int AllSkills::skills_size() const {
  return skills_.size();
}
inline void AllSkills::clear_skills() {
  skills_.Clear();
}
inline const ::SkillFamily& AllSkills::skills(int index) const {
  return skills_.Get(index);
}
inline ::SkillFamily* AllSkills::mutable_skills(int index) {
  return skills_.Mutable(index);
}
inline ::SkillFamily* AllSkills::add_skills() {
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SkillFamily >&
AllSkills::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::SkillFamily >*
AllSkills::mutable_skills() {
  return &skills_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SkillInfo_SkillType>() {
  return ::SkillInfo_SkillType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SkillInfo_TrackType>() {
  return ::SkillInfo_TrackType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SkillInfo_LaunchType>() {
  return ::SkillInfo_LaunchType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SkillInfo_TargetType>() {
  return ::SkillInfo_TargetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SkillInfo_StatusType>() {
  return ::SkillInfo_StatusType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SkillInfo_AreaType>() {
  return ::SkillInfo_AreaType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SkillInfo_ShockType>() {
  return ::SkillInfo_ShockType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SkillInfo_OffsetType>() {
  return ::SkillInfo_OffsetType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SkillInfo_2eproto__INCLUDED
