// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GuideInfo.proto

#ifndef PROTOBUF_GuideInfo_2eproto__INCLUDED
#define PROTOBUF_GuideInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GuideInfo_2eproto();
void protobuf_AssignDesc_GuideInfo_2eproto();
void protobuf_ShutdownFile_GuideInfo_2eproto();

class GuideNode;
class AllGuideNode;
class GuidePass;
class AllGuidePass;

enum GuideNode_EndCondition {
  GuideNode_EndCondition_NONE = 0,
  GuideNode_EndCondition_CLICK = 1,
  GuideNode_EndCondition_OPEN_UI = 2,
  GuideNode_EndCondition_END_OPEN_FUNC = 3,
  GuideNode_EndCondition_PRESS = 4,
  GuideNode_EndCondition_OVER_TALK = 5,
  GuideNode_EndCondition_IMMEDIATELY = 6,
  GuideNode_EndCondition_IN_PEACE_SCENE = 100
};
bool GuideNode_EndCondition_IsValid(int value);
const GuideNode_EndCondition GuideNode_EndCondition_EndCondition_MIN = GuideNode_EndCondition_NONE;
const GuideNode_EndCondition GuideNode_EndCondition_EndCondition_MAX = GuideNode_EndCondition_IN_PEACE_SCENE;
const int GuideNode_EndCondition_EndCondition_ARRAYSIZE = GuideNode_EndCondition_EndCondition_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuideNode_EndCondition_descriptor();
inline const ::std::string& GuideNode_EndCondition_Name(GuideNode_EndCondition value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuideNode_EndCondition_descriptor(), value);
}
inline bool GuideNode_EndCondition_Parse(
    const ::std::string& name, GuideNode_EndCondition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuideNode_EndCondition>(
    GuideNode_EndCondition_descriptor(), name, value);
}
enum GuideNode_DoEvent {
  GuideNode_DoEvent_NONE_EVENT = 0,
  GuideNode_DoEvent_OPEN_FUNC = 1,
  GuideNode_DoEvent_FULL_ENERGY = 2,
  GuideNode_DoEvent_PAUSE = 3,
  GuideNode_DoEvent_ADD_SKILL = 4,
  GuideNode_DoEvent_TALK = 5,
  GuideNode_DoEvent_OPENUI = 6,
  GuideNode_DoEvent_TIMEDO = 7
};
bool GuideNode_DoEvent_IsValid(int value);
const GuideNode_DoEvent GuideNode_DoEvent_DoEvent_MIN = GuideNode_DoEvent_NONE_EVENT;
const GuideNode_DoEvent GuideNode_DoEvent_DoEvent_MAX = GuideNode_DoEvent_TIMEDO;
const int GuideNode_DoEvent_DoEvent_ARRAYSIZE = GuideNode_DoEvent_DoEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuideNode_DoEvent_descriptor();
inline const ::std::string& GuideNode_DoEvent_Name(GuideNode_DoEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuideNode_DoEvent_descriptor(), value);
}
inline bool GuideNode_DoEvent_Parse(
    const ::std::string& name, GuideNode_DoEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuideNode_DoEvent>(
    GuideNode_DoEvent_descriptor(), name, value);
}
enum GuideNode_MaskType {
  GuideNode_MaskType_CIRCLE = 0,
  GuideNode_MaskType_SQUARE = 1,
  GuideNode_MaskType_NONE_MASK = 2
};
bool GuideNode_MaskType_IsValid(int value);
const GuideNode_MaskType GuideNode_MaskType_MaskType_MIN = GuideNode_MaskType_CIRCLE;
const GuideNode_MaskType GuideNode_MaskType_MaskType_MAX = GuideNode_MaskType_NONE_MASK;
const int GuideNode_MaskType_MaskType_ARRAYSIZE = GuideNode_MaskType_MaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuideNode_MaskType_descriptor();
inline const ::std::string& GuideNode_MaskType_Name(GuideNode_MaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuideNode_MaskType_descriptor(), value);
}
inline bool GuideNode_MaskType_Parse(
    const ::std::string& name, GuideNode_MaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuideNode_MaskType>(
    GuideNode_MaskType_descriptor(), name, value);
}
enum GuidePass_TriggerType {
  GuidePass_TriggerType_NONE = 0,
  GuidePass_TriggerType_LOAD_SCENE = 1,
  GuidePass_TriggerType_OVER_GUIDE = 2,
  GuidePass_TriggerType_OPEN_FUNC = 3,
  GuidePass_TriggerType_GAIN_GOODS = 4,
  GuidePass_TriggerType_GAIN_EQUIPMENT = 5,
  GuidePass_TriggerType_LEARN_SKILL = 6,
  GuidePass_TriggerType_APPLY_MISSION = 7,
  GuidePass_TriggerType_COMPLETE_MISSION = 8,
  GuidePass_TriggerType_PROFESSION = 9,
  GuidePass_TriggerType_OPEN_NPC_GROUP = 10,
  GuidePass_TriggerType_IN_SCENE = 11,
  GuidePass_TriggerType_LEVEL_UP = 12,
  GuidePass_TriggerType_MISSION_OVER = 13,
  GuidePass_TriggerType_ATTACK_NPC = 14,
  GuidePass_TriggerType_BOSS_DEAD = 15
};
bool GuidePass_TriggerType_IsValid(int value);
const GuidePass_TriggerType GuidePass_TriggerType_TriggerType_MIN = GuidePass_TriggerType_NONE;
const GuidePass_TriggerType GuidePass_TriggerType_TriggerType_MAX = GuidePass_TriggerType_BOSS_DEAD;
const int GuidePass_TriggerType_TriggerType_ARRAYSIZE = GuidePass_TriggerType_TriggerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuidePass_TriggerType_descriptor();
inline const ::std::string& GuidePass_TriggerType_Name(GuidePass_TriggerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuidePass_TriggerType_descriptor(), value);
}
inline bool GuidePass_TriggerType_Parse(
    const ::std::string& name, GuidePass_TriggerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuidePass_TriggerType>(
    GuidePass_TriggerType_descriptor(), name, value);
}
// ===================================================================

class GuideNode : public ::google::protobuf::Message {
 public:
  GuideNode();
  virtual ~GuideNode();
  
  GuideNode(const GuideNode& from);
  
  inline GuideNode& operator=(const GuideNode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuideNode& default_instance();
  
  void Swap(GuideNode* other);
  
  // implements Message ----------------------------------------------
  
  GuideNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuideNode& from);
  void MergeFrom(const GuideNode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GuideNode_EndCondition EndCondition;
  static const EndCondition NONE = GuideNode_EndCondition_NONE;
  static const EndCondition CLICK = GuideNode_EndCondition_CLICK;
  static const EndCondition OPEN_UI = GuideNode_EndCondition_OPEN_UI;
  static const EndCondition END_OPEN_FUNC = GuideNode_EndCondition_END_OPEN_FUNC;
  static const EndCondition PRESS = GuideNode_EndCondition_PRESS;
  static const EndCondition OVER_TALK = GuideNode_EndCondition_OVER_TALK;
  static const EndCondition IMMEDIATELY = GuideNode_EndCondition_IMMEDIATELY;
  static const EndCondition IN_PEACE_SCENE = GuideNode_EndCondition_IN_PEACE_SCENE;
  static inline bool EndCondition_IsValid(int value) {
    return GuideNode_EndCondition_IsValid(value);
  }
  static const EndCondition EndCondition_MIN =
    GuideNode_EndCondition_EndCondition_MIN;
  static const EndCondition EndCondition_MAX =
    GuideNode_EndCondition_EndCondition_MAX;
  static const int EndCondition_ARRAYSIZE =
    GuideNode_EndCondition_EndCondition_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EndCondition_descriptor() {
    return GuideNode_EndCondition_descriptor();
  }
  static inline const ::std::string& EndCondition_Name(EndCondition value) {
    return GuideNode_EndCondition_Name(value);
  }
  static inline bool EndCondition_Parse(const ::std::string& name,
      EndCondition* value) {
    return GuideNode_EndCondition_Parse(name, value);
  }
  
  typedef GuideNode_DoEvent DoEvent;
  static const DoEvent NONE_EVENT = GuideNode_DoEvent_NONE_EVENT;
  static const DoEvent OPEN_FUNC = GuideNode_DoEvent_OPEN_FUNC;
  static const DoEvent FULL_ENERGY = GuideNode_DoEvent_FULL_ENERGY;
  static const DoEvent PAUSE = GuideNode_DoEvent_PAUSE;
  static const DoEvent ADD_SKILL = GuideNode_DoEvent_ADD_SKILL;
  static const DoEvent TALK = GuideNode_DoEvent_TALK;
  static const DoEvent OPENUI = GuideNode_DoEvent_OPENUI;
  static const DoEvent TIMEDO = GuideNode_DoEvent_TIMEDO;
  static inline bool DoEvent_IsValid(int value) {
    return GuideNode_DoEvent_IsValid(value);
  }
  static const DoEvent DoEvent_MIN =
    GuideNode_DoEvent_DoEvent_MIN;
  static const DoEvent DoEvent_MAX =
    GuideNode_DoEvent_DoEvent_MAX;
  static const int DoEvent_ARRAYSIZE =
    GuideNode_DoEvent_DoEvent_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DoEvent_descriptor() {
    return GuideNode_DoEvent_descriptor();
  }
  static inline const ::std::string& DoEvent_Name(DoEvent value) {
    return GuideNode_DoEvent_Name(value);
  }
  static inline bool DoEvent_Parse(const ::std::string& name,
      DoEvent* value) {
    return GuideNode_DoEvent_Parse(name, value);
  }
  
  typedef GuideNode_MaskType MaskType;
  static const MaskType CIRCLE = GuideNode_MaskType_CIRCLE;
  static const MaskType SQUARE = GuideNode_MaskType_SQUARE;
  static const MaskType NONE_MASK = GuideNode_MaskType_NONE_MASK;
  static inline bool MaskType_IsValid(int value) {
    return GuideNode_MaskType_IsValid(value);
  }
  static const MaskType MaskType_MIN =
    GuideNode_MaskType_MaskType_MIN;
  static const MaskType MaskType_MAX =
    GuideNode_MaskType_MaskType_MAX;
  static const int MaskType_ARRAYSIZE =
    GuideNode_MaskType_MaskType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MaskType_descriptor() {
    return GuideNode_MaskType_descriptor();
  }
  static inline const ::std::string& MaskType_Name(MaskType value) {
    return GuideNode_MaskType_Name(value);
  }
  static inline bool MaskType_Parse(const ::std::string& name,
      MaskType* value) {
    return GuideNode_MaskType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 next = 2;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 2;
  inline ::google::protobuf::int32 next() const;
  inline void set_next(::google::protobuf::int32 value);
  
  // optional int32 effectID = 3;
  inline bool has_effectID() const;
  inline void clear_effectID();
  static const int kEffectIDFieldNumber = 3;
  inline ::google::protobuf::int32 effectID() const;
  inline void set_effectID(::google::protobuf::int32 value);
  
  // optional int32 ui = 4;
  inline bool has_ui() const;
  inline void clear_ui();
  static const int kUiFieldNumber = 4;
  inline ::google::protobuf::int32 ui() const;
  inline void set_ui(::google::protobuf::int32 value);
  
  // optional int32 param = 5;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 5;
  inline ::google::protobuf::int32 param() const;
  inline void set_param(::google::protobuf::int32 value);
  
  // optional float x = 6;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 6;
  inline float x() const;
  inline void set_x(float value);
  
  // optional float y = 7;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 7;
  inline float y() const;
  inline void set_y(float value);
  
  // optional int32 index = 8;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 8;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);
  
  // optional .GuideNode.EndCondition endCondition = 9;
  inline bool has_endCondition() const;
  inline void clear_endCondition();
  static const int kEndConditionFieldNumber = 9;
  inline ::GuideNode_EndCondition endCondition() const;
  inline void set_endCondition(::GuideNode_EndCondition value);
  
  // optional .GuideNode.DoEvent doEvent = 10;
  inline bool has_doEvent() const;
  inline void clear_doEvent();
  static const int kDoEventFieldNumber = 10;
  inline ::GuideNode_DoEvent doEvent() const;
  inline void set_doEvent(::GuideNode_DoEvent value);
  
  // optional float scaleX = 11;
  inline bool has_scaleX() const;
  inline void clear_scaleX();
  static const int kScaleXFieldNumber = 11;
  inline float scaleX() const;
  inline void set_scaleX(float value);
  
  // optional float scaleY = 12;
  inline bool has_scaleY() const;
  inline void clear_scaleY();
  static const int kScaleYFieldNumber = 12;
  inline float scaleY() const;
  inline void set_scaleY(float value);
  
  // optional .GuideNode.MaskType maskType = 13;
  inline bool has_maskType() const;
  inline void clear_maskType();
  static const int kMaskTypeFieldNumber = 13;
  inline ::GuideNode_MaskType maskType() const;
  inline void set_maskType(::GuideNode_MaskType value);
  
  // optional float maskSX = 14;
  inline bool has_maskSX() const;
  inline void clear_maskSX();
  static const int kMaskSXFieldNumber = 14;
  inline float maskSX() const;
  inline void set_maskSX(float value);
  
  // optional float maskSY = 15;
  inline bool has_maskSY() const;
  inline void clear_maskSY();
  static const int kMaskSYFieldNumber = 15;
  inline float maskSY() const;
  inline void set_maskSY(float value);
  
  // optional float maskPX = 16;
  inline bool has_maskPX() const;
  inline void clear_maskPX();
  static const int kMaskPXFieldNumber = 16;
  inline float maskPX() const;
  inline void set_maskPX(float value);
  
  // optional float maskPY = 17;
  inline bool has_maskPY() const;
  inline void clear_maskPY();
  static const int kMaskPYFieldNumber = 17;
  inline float maskPY() const;
  inline void set_maskPY(float value);
  
  // optional float tipsX = 18;
  inline bool has_tipsX() const;
  inline void clear_tipsX();
  static const int kTipsXFieldNumber = 18;
  inline float tipsX() const;
  inline void set_tipsX(float value);
  
  // optional float tipsY = 19;
  inline bool has_tipsY() const;
  inline void clear_tipsY();
  static const int kTipsYFieldNumber = 19;
  inline float tipsY() const;
  inline void set_tipsY(float value);
  
  // optional float z = 20;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 20;
  inline float z() const;
  inline void set_z(float value);
  
  // optional float pauseTime = 21;
  inline bool has_pauseTime() const;
  inline void clear_pauseTime();
  static const int kPauseTimeFieldNumber = 21;
  inline float pauseTime() const;
  inline void set_pauseTime(float value);
  
  // @@protoc_insertion_point(class_scope:GuideNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_effectID();
  inline void clear_has_effectID();
  inline void set_has_ui();
  inline void clear_has_ui();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_endCondition();
  inline void clear_has_endCondition();
  inline void set_has_doEvent();
  inline void clear_has_doEvent();
  inline void set_has_scaleX();
  inline void clear_has_scaleX();
  inline void set_has_scaleY();
  inline void clear_has_scaleY();
  inline void set_has_maskType();
  inline void clear_has_maskType();
  inline void set_has_maskSX();
  inline void clear_has_maskSX();
  inline void set_has_maskSY();
  inline void clear_has_maskSY();
  inline void set_has_maskPX();
  inline void clear_has_maskPX();
  inline void set_has_maskPY();
  inline void clear_has_maskPY();
  inline void set_has_tipsX();
  inline void clear_has_tipsX();
  inline void set_has_tipsY();
  inline void clear_has_tipsY();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_pauseTime();
  inline void clear_has_pauseTime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 next_;
  ::google::protobuf::int32 effectID_;
  ::google::protobuf::int32 ui_;
  ::google::protobuf::int32 param_;
  float x_;
  float y_;
  ::google::protobuf::int32 index_;
  int endCondition_;
  int doEvent_;
  float scaleX_;
  float scaleY_;
  int maskType_;
  float maskSX_;
  float maskSY_;
  float maskPX_;
  float maskPY_;
  float tipsX_;
  float tipsY_;
  float z_;
  float pauseTime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  friend void  protobuf_AddDesc_GuideInfo_2eproto();
  friend void protobuf_AssignDesc_GuideInfo_2eproto();
  friend void protobuf_ShutdownFile_GuideInfo_2eproto();
  
  void InitAsDefaultInstance();
  static GuideNode* default_instance_;
};
// -------------------------------------------------------------------

class AllGuideNode : public ::google::protobuf::Message {
 public:
  AllGuideNode();
  virtual ~AllGuideNode();
  
  AllGuideNode(const AllGuideNode& from);
  
  inline AllGuideNode& operator=(const AllGuideNode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllGuideNode& default_instance();
  
  void Swap(AllGuideNode* other);
  
  // implements Message ----------------------------------------------
  
  AllGuideNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllGuideNode& from);
  void MergeFrom(const AllGuideNode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .GuideNode guideNodes = 1;
  inline int guideNodes_size() const;
  inline void clear_guideNodes();
  static const int kGuideNodesFieldNumber = 1;
  inline const ::GuideNode& guideNodes(int index) const;
  inline ::GuideNode* mutable_guideNodes(int index);
  inline ::GuideNode* add_guideNodes();
  inline const ::google::protobuf::RepeatedPtrField< ::GuideNode >&
      guideNodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::GuideNode >*
      mutable_guideNodes();
  
  // @@protoc_insertion_point(class_scope:AllGuideNode)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::GuideNode > guideNodes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_GuideInfo_2eproto();
  friend void protobuf_AssignDesc_GuideInfo_2eproto();
  friend void protobuf_ShutdownFile_GuideInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AllGuideNode* default_instance_;
};
// -------------------------------------------------------------------

class GuidePass : public ::google::protobuf::Message {
 public:
  GuidePass();
  virtual ~GuidePass();
  
  GuidePass(const GuidePass& from);
  
  inline GuidePass& operator=(const GuidePass& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuidePass& default_instance();
  
  void Swap(GuidePass* other);
  
  // implements Message ----------------------------------------------
  
  GuidePass* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuidePass& from);
  void MergeFrom(const GuidePass& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GuidePass_TriggerType TriggerType;
  static const TriggerType NONE = GuidePass_TriggerType_NONE;
  static const TriggerType LOAD_SCENE = GuidePass_TriggerType_LOAD_SCENE;
  static const TriggerType OVER_GUIDE = GuidePass_TriggerType_OVER_GUIDE;
  static const TriggerType OPEN_FUNC = GuidePass_TriggerType_OPEN_FUNC;
  static const TriggerType GAIN_GOODS = GuidePass_TriggerType_GAIN_GOODS;
  static const TriggerType GAIN_EQUIPMENT = GuidePass_TriggerType_GAIN_EQUIPMENT;
  static const TriggerType LEARN_SKILL = GuidePass_TriggerType_LEARN_SKILL;
  static const TriggerType APPLY_MISSION = GuidePass_TriggerType_APPLY_MISSION;
  static const TriggerType COMPLETE_MISSION = GuidePass_TriggerType_COMPLETE_MISSION;
  static const TriggerType PROFESSION = GuidePass_TriggerType_PROFESSION;
  static const TriggerType OPEN_NPC_GROUP = GuidePass_TriggerType_OPEN_NPC_GROUP;
  static const TriggerType IN_SCENE = GuidePass_TriggerType_IN_SCENE;
  static const TriggerType LEVEL_UP = GuidePass_TriggerType_LEVEL_UP;
  static const TriggerType MISSION_OVER = GuidePass_TriggerType_MISSION_OVER;
  static const TriggerType ATTACK_NPC = GuidePass_TriggerType_ATTACK_NPC;
  static const TriggerType BOSS_DEAD = GuidePass_TriggerType_BOSS_DEAD;
  static inline bool TriggerType_IsValid(int value) {
    return GuidePass_TriggerType_IsValid(value);
  }
  static const TriggerType TriggerType_MIN =
    GuidePass_TriggerType_TriggerType_MIN;
  static const TriggerType TriggerType_MAX =
    GuidePass_TriggerType_TriggerType_MAX;
  static const int TriggerType_ARRAYSIZE =
    GuidePass_TriggerType_TriggerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TriggerType_descriptor() {
    return GuidePass_TriggerType_descriptor();
  }
  static inline const ::std::string& TriggerType_Name(TriggerType value) {
    return GuidePass_TriggerType_Name(value);
  }
  static inline bool TriggerType_Parse(const ::std::string& name,
      TriggerType* value) {
    return GuidePass_TriggerType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // repeated .GuidePass.TriggerType triggerType = 2;
  inline int triggerType_size() const;
  inline void clear_triggerType();
  static const int kTriggerTypeFieldNumber = 2;
  inline ::GuidePass_TriggerType triggerType(int index) const;
  inline void set_triggerType(int index, ::GuidePass_TriggerType value);
  inline void add_triggerType(::GuidePass_TriggerType value);
  inline const ::google::protobuf::RepeatedField<int>& triggerType() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_triggerType();
  
  // repeated int32 param = 3;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 3;
  inline ::google::protobuf::int32 param(int index) const;
  inline void set_param(int index, ::google::protobuf::int32 value);
  inline void add_param(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      param() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_param();
  
  // optional int32 firstNode = 4;
  inline bool has_firstNode() const;
  inline void clear_firstNode();
  static const int kFirstNodeFieldNumber = 4;
  inline ::google::protobuf::int32 firstNode() const;
  inline void set_firstNode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:GuidePass)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_firstNode();
  inline void clear_has_firstNode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField<int> triggerType_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 firstNode_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > param_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_GuideInfo_2eproto();
  friend void protobuf_AssignDesc_GuideInfo_2eproto();
  friend void protobuf_ShutdownFile_GuideInfo_2eproto();
  
  void InitAsDefaultInstance();
  static GuidePass* default_instance_;
};
// -------------------------------------------------------------------

class AllGuidePass : public ::google::protobuf::Message {
 public:
  AllGuidePass();
  virtual ~AllGuidePass();
  
  AllGuidePass(const AllGuidePass& from);
  
  inline AllGuidePass& operator=(const AllGuidePass& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllGuidePass& default_instance();
  
  void Swap(AllGuidePass* other);
  
  // implements Message ----------------------------------------------
  
  AllGuidePass* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllGuidePass& from);
  void MergeFrom(const AllGuidePass& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .GuidePass guidePasses = 1;
  inline int guidePasses_size() const;
  inline void clear_guidePasses();
  static const int kGuidePassesFieldNumber = 1;
  inline const ::GuidePass& guidePasses(int index) const;
  inline ::GuidePass* mutable_guidePasses(int index);
  inline ::GuidePass* add_guidePasses();
  inline const ::google::protobuf::RepeatedPtrField< ::GuidePass >&
      guidePasses() const;
  inline ::google::protobuf::RepeatedPtrField< ::GuidePass >*
      mutable_guidePasses();
  
  // @@protoc_insertion_point(class_scope:AllGuidePass)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::GuidePass > guidePasses_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_GuideInfo_2eproto();
  friend void protobuf_AssignDesc_GuideInfo_2eproto();
  friend void protobuf_ShutdownFile_GuideInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AllGuidePass* default_instance_;
};
// ===================================================================


// ===================================================================

// GuideNode

// optional int32 id = 1;
inline bool GuideNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuideNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuideNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuideNode::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GuideNode::id() const {
  return id_;
}
inline void GuideNode::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 next = 2;
inline bool GuideNode::has_next() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuideNode::set_has_next() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuideNode::clear_has_next() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuideNode::clear_next() {
  next_ = 0;
  clear_has_next();
}
inline ::google::protobuf::int32 GuideNode::next() const {
  return next_;
}
inline void GuideNode::set_next(::google::protobuf::int32 value) {
  set_has_next();
  next_ = value;
}

// optional int32 effectID = 3;
inline bool GuideNode::has_effectID() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuideNode::set_has_effectID() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuideNode::clear_has_effectID() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuideNode::clear_effectID() {
  effectID_ = 0;
  clear_has_effectID();
}
inline ::google::protobuf::int32 GuideNode::effectID() const {
  return effectID_;
}
inline void GuideNode::set_effectID(::google::protobuf::int32 value) {
  set_has_effectID();
  effectID_ = value;
}

// optional int32 ui = 4;
inline bool GuideNode::has_ui() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuideNode::set_has_ui() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuideNode::clear_has_ui() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuideNode::clear_ui() {
  ui_ = 0;
  clear_has_ui();
}
inline ::google::protobuf::int32 GuideNode::ui() const {
  return ui_;
}
inline void GuideNode::set_ui(::google::protobuf::int32 value) {
  set_has_ui();
  ui_ = value;
}

// optional int32 param = 5;
inline bool GuideNode::has_param() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuideNode::set_has_param() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuideNode::clear_has_param() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuideNode::clear_param() {
  param_ = 0;
  clear_has_param();
}
inline ::google::protobuf::int32 GuideNode::param() const {
  return param_;
}
inline void GuideNode::set_param(::google::protobuf::int32 value) {
  set_has_param();
  param_ = value;
}

// optional float x = 6;
inline bool GuideNode::has_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuideNode::set_has_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuideNode::clear_has_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuideNode::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float GuideNode::x() const {
  return x_;
}
inline void GuideNode::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 7;
inline bool GuideNode::has_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GuideNode::set_has_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GuideNode::clear_has_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GuideNode::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float GuideNode::y() const {
  return y_;
}
inline void GuideNode::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional int32 index = 8;
inline bool GuideNode::has_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GuideNode::set_has_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GuideNode::clear_has_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GuideNode::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 GuideNode::index() const {
  return index_;
}
inline void GuideNode::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional .GuideNode.EndCondition endCondition = 9;
inline bool GuideNode::has_endCondition() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GuideNode::set_has_endCondition() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GuideNode::clear_has_endCondition() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GuideNode::clear_endCondition() {
  endCondition_ = 0;
  clear_has_endCondition();
}
inline ::GuideNode_EndCondition GuideNode::endCondition() const {
  return static_cast< ::GuideNode_EndCondition >(endCondition_);
}
inline void GuideNode::set_endCondition(::GuideNode_EndCondition value) {
  GOOGLE_DCHECK(::GuideNode_EndCondition_IsValid(value));
  set_has_endCondition();
  endCondition_ = value;
}

// optional .GuideNode.DoEvent doEvent = 10;
inline bool GuideNode::has_doEvent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GuideNode::set_has_doEvent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GuideNode::clear_has_doEvent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GuideNode::clear_doEvent() {
  doEvent_ = 0;
  clear_has_doEvent();
}
inline ::GuideNode_DoEvent GuideNode::doEvent() const {
  return static_cast< ::GuideNode_DoEvent >(doEvent_);
}
inline void GuideNode::set_doEvent(::GuideNode_DoEvent value) {
  GOOGLE_DCHECK(::GuideNode_DoEvent_IsValid(value));
  set_has_doEvent();
  doEvent_ = value;
}

// optional float scaleX = 11;
inline bool GuideNode::has_scaleX() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GuideNode::set_has_scaleX() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GuideNode::clear_has_scaleX() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GuideNode::clear_scaleX() {
  scaleX_ = 0;
  clear_has_scaleX();
}
inline float GuideNode::scaleX() const {
  return scaleX_;
}
inline void GuideNode::set_scaleX(float value) {
  set_has_scaleX();
  scaleX_ = value;
}

// optional float scaleY = 12;
inline bool GuideNode::has_scaleY() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GuideNode::set_has_scaleY() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GuideNode::clear_has_scaleY() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GuideNode::clear_scaleY() {
  scaleY_ = 0;
  clear_has_scaleY();
}
inline float GuideNode::scaleY() const {
  return scaleY_;
}
inline void GuideNode::set_scaleY(float value) {
  set_has_scaleY();
  scaleY_ = value;
}

// optional .GuideNode.MaskType maskType = 13;
inline bool GuideNode::has_maskType() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GuideNode::set_has_maskType() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GuideNode::clear_has_maskType() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GuideNode::clear_maskType() {
  maskType_ = 0;
  clear_has_maskType();
}
inline ::GuideNode_MaskType GuideNode::maskType() const {
  return static_cast< ::GuideNode_MaskType >(maskType_);
}
inline void GuideNode::set_maskType(::GuideNode_MaskType value) {
  GOOGLE_DCHECK(::GuideNode_MaskType_IsValid(value));
  set_has_maskType();
  maskType_ = value;
}

// optional float maskSX = 14;
inline bool GuideNode::has_maskSX() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GuideNode::set_has_maskSX() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GuideNode::clear_has_maskSX() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GuideNode::clear_maskSX() {
  maskSX_ = 0;
  clear_has_maskSX();
}
inline float GuideNode::maskSX() const {
  return maskSX_;
}
inline void GuideNode::set_maskSX(float value) {
  set_has_maskSX();
  maskSX_ = value;
}

// optional float maskSY = 15;
inline bool GuideNode::has_maskSY() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GuideNode::set_has_maskSY() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GuideNode::clear_has_maskSY() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GuideNode::clear_maskSY() {
  maskSY_ = 0;
  clear_has_maskSY();
}
inline float GuideNode::maskSY() const {
  return maskSY_;
}
inline void GuideNode::set_maskSY(float value) {
  set_has_maskSY();
  maskSY_ = value;
}

// optional float maskPX = 16;
inline bool GuideNode::has_maskPX() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GuideNode::set_has_maskPX() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GuideNode::clear_has_maskPX() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GuideNode::clear_maskPX() {
  maskPX_ = 0;
  clear_has_maskPX();
}
inline float GuideNode::maskPX() const {
  return maskPX_;
}
inline void GuideNode::set_maskPX(float value) {
  set_has_maskPX();
  maskPX_ = value;
}

// optional float maskPY = 17;
inline bool GuideNode::has_maskPY() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GuideNode::set_has_maskPY() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GuideNode::clear_has_maskPY() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GuideNode::clear_maskPY() {
  maskPY_ = 0;
  clear_has_maskPY();
}
inline float GuideNode::maskPY() const {
  return maskPY_;
}
inline void GuideNode::set_maskPY(float value) {
  set_has_maskPY();
  maskPY_ = value;
}

// optional float tipsX = 18;
inline bool GuideNode::has_tipsX() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GuideNode::set_has_tipsX() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GuideNode::clear_has_tipsX() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GuideNode::clear_tipsX() {
  tipsX_ = 0;
  clear_has_tipsX();
}
inline float GuideNode::tipsX() const {
  return tipsX_;
}
inline void GuideNode::set_tipsX(float value) {
  set_has_tipsX();
  tipsX_ = value;
}

// optional float tipsY = 19;
inline bool GuideNode::has_tipsY() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GuideNode::set_has_tipsY() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GuideNode::clear_has_tipsY() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GuideNode::clear_tipsY() {
  tipsY_ = 0;
  clear_has_tipsY();
}
inline float GuideNode::tipsY() const {
  return tipsY_;
}
inline void GuideNode::set_tipsY(float value) {
  set_has_tipsY();
  tipsY_ = value;
}

// optional float z = 20;
inline bool GuideNode::has_z() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GuideNode::set_has_z() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GuideNode::clear_has_z() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GuideNode::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float GuideNode::z() const {
  return z_;
}
inline void GuideNode::set_z(float value) {
  set_has_z();
  z_ = value;
}

// optional float pauseTime = 21;
inline bool GuideNode::has_pauseTime() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GuideNode::set_has_pauseTime() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GuideNode::clear_has_pauseTime() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GuideNode::clear_pauseTime() {
  pauseTime_ = 0;
  clear_has_pauseTime();
}
inline float GuideNode::pauseTime() const {
  return pauseTime_;
}
inline void GuideNode::set_pauseTime(float value) {
  set_has_pauseTime();
  pauseTime_ = value;
}

// -------------------------------------------------------------------

// AllGuideNode

// repeated .GuideNode guideNodes = 1;
inline int AllGuideNode::guideNodes_size() const {
  return guideNodes_.size();
}
inline void AllGuideNode::clear_guideNodes() {
  guideNodes_.Clear();
}
inline const ::GuideNode& AllGuideNode::guideNodes(int index) const {
  return guideNodes_.Get(index);
}
inline ::GuideNode* AllGuideNode::mutable_guideNodes(int index) {
  return guideNodes_.Mutable(index);
}
inline ::GuideNode* AllGuideNode::add_guideNodes() {
  return guideNodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GuideNode >&
AllGuideNode::guideNodes() const {
  return guideNodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::GuideNode >*
AllGuideNode::mutable_guideNodes() {
  return &guideNodes_;
}

// -------------------------------------------------------------------

// GuidePass

// optional int32 id = 1;
inline bool GuidePass::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuidePass::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuidePass::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuidePass::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GuidePass::id() const {
  return id_;
}
inline void GuidePass::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .GuidePass.TriggerType triggerType = 2;
inline int GuidePass::triggerType_size() const {
  return triggerType_.size();
}
inline void GuidePass::clear_triggerType() {
  triggerType_.Clear();
}
inline ::GuidePass_TriggerType GuidePass::triggerType(int index) const {
  return static_cast< ::GuidePass_TriggerType >(triggerType_.Get(index));
}
inline void GuidePass::set_triggerType(int index, ::GuidePass_TriggerType value) {
  GOOGLE_DCHECK(::GuidePass_TriggerType_IsValid(value));
  triggerType_.Set(index, value);
}
inline void GuidePass::add_triggerType(::GuidePass_TriggerType value) {
  GOOGLE_DCHECK(::GuidePass_TriggerType_IsValid(value));
  triggerType_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
GuidePass::triggerType() const {
  return triggerType_;
}
inline ::google::protobuf::RepeatedField<int>*
GuidePass::mutable_triggerType() {
  return &triggerType_;
}

// repeated int32 param = 3;
inline int GuidePass::param_size() const {
  return param_.size();
}
inline void GuidePass::clear_param() {
  param_.Clear();
}
inline ::google::protobuf::int32 GuidePass::param(int index) const {
  return param_.Get(index);
}
inline void GuidePass::set_param(int index, ::google::protobuf::int32 value) {
  param_.Set(index, value);
}
inline void GuidePass::add_param(::google::protobuf::int32 value) {
  param_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GuidePass::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GuidePass::mutable_param() {
  return &param_;
}

// optional int32 firstNode = 4;
inline bool GuidePass::has_firstNode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuidePass::set_has_firstNode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuidePass::clear_has_firstNode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuidePass::clear_firstNode() {
  firstNode_ = 0;
  clear_has_firstNode();
}
inline ::google::protobuf::int32 GuidePass::firstNode() const {
  return firstNode_;
}
inline void GuidePass::set_firstNode(::google::protobuf::int32 value) {
  set_has_firstNode();
  firstNode_ = value;
}

// -------------------------------------------------------------------

// AllGuidePass

// repeated .GuidePass guidePasses = 1;
inline int AllGuidePass::guidePasses_size() const {
  return guidePasses_.size();
}
inline void AllGuidePass::clear_guidePasses() {
  guidePasses_.Clear();
}
inline const ::GuidePass& AllGuidePass::guidePasses(int index) const {
  return guidePasses_.Get(index);
}
inline ::GuidePass* AllGuidePass::mutable_guidePasses(int index) {
  return guidePasses_.Mutable(index);
}
inline ::GuidePass* AllGuidePass::add_guidePasses() {
  return guidePasses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GuidePass >&
AllGuidePass::guidePasses() const {
  return guidePasses_;
}
inline ::google::protobuf::RepeatedPtrField< ::GuidePass >*
AllGuidePass::mutable_guidePasses() {
  return &guidePasses_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GuideNode_EndCondition>() {
  return ::GuideNode_EndCondition_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GuideNode_DoEvent>() {
  return ::GuideNode_DoEvent_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GuideNode_MaskType>() {
  return ::GuideNode_MaskType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GuidePass_TriggerType>() {
  return ::GuidePass_TriggerType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GuideInfo_2eproto__INCLUDED
