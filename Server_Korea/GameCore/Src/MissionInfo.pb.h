// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MissionInfo.proto

#ifndef PROTOBUF_MissionInfo_2eproto__INCLUDED
#define PROTOBUF_MissionInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MissionInfo_2eproto();
void protobuf_AssignDesc_MissionInfo_2eproto();
void protobuf_ShutdownFile_MissionInfo_2eproto();

class MissionContent;
class MissionArg;
class MissionOpen;
class MissionTarget;
class MissionAward;
class MissionPort;
class MissionTrack;
class MissionInfo;
class AllMissions;
class PB_MissionTargetRecord;
class PB_MissionRecord;
class PB_MissionAllRecord;

enum MissionOpen_Type {
  MissionOpen_Type_NONE = 0,
  MissionOpen_Type_LEVEL = 1,
  MissionOpen_Type_COMPLETE_MISSION = 2,
  MissionOpen_Type_HASGOODS = 3,
  MissionOpen_Type_APPLY_MISSION = 4,
  MissionOpen_Type_OPENSERVERDATE = 5
};
bool MissionOpen_Type_IsValid(int value);
const MissionOpen_Type MissionOpen_Type_Type_MIN = MissionOpen_Type_NONE;
const MissionOpen_Type MissionOpen_Type_Type_MAX = MissionOpen_Type_OPENSERVERDATE;
const int MissionOpen_Type_Type_ARRAYSIZE = MissionOpen_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MissionOpen_Type_descriptor();
inline const ::std::string& MissionOpen_Type_Name(MissionOpen_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MissionOpen_Type_descriptor(), value);
}
inline bool MissionOpen_Type_Parse(
    const ::std::string& name, MissionOpen_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MissionOpen_Type>(
    MissionOpen_Type_descriptor(), name, value);
}
enum MissionTarget_Type {
  MissionTarget_Type_NONE = 0,
  MissionTarget_Type_KILLNPC = 1,
  MissionTarget_Type_TALK = 2,
  MissionTarget_Type_GETGOODS = 3,
  MissionTarget_Type_CLEAR_ROOM = 4,
  MissionTarget_Type_CLEAR_ONLYROOM = 5,
  MissionTarget_Type_CLEAR_TOWER = 6,
  MissionTarget_Type_CLEAR_SURVIVE = 7,
  MissionTarget_Type_CLEAR_HERO = 8,
  MissionTarget_Type_STRONG = 10,
  MissionTarget_Type_UNLOCK_BLOODNODE = 12,
  MissionTarget_Type_PVP = 14,
  MissionTarget_Type_LEVEL_TO = 15,
  MissionTarget_Type_MOUNT = 16,
  MissionTarget_Type_ENHANCE = 17,
  MissionTarget_Type_STRONG_WING_TO = 18,
  MissionTarget_Type_SKILL_LEVEL_TO = 19,
  MissionTarget_Type_HELL_KILL = 20,
  MissionTarget_Type_ADD_FRIEND = 21,
  MissionTarget_Type_BE_ADDED_FRIEND = 22,
  MissionTarget_Type_STRONG_TO = 23,
  MissionTarget_Type_UNLOCK_BLOODNODE_TO = 24,
  MissionTarget_Type_ENTER_ANY_ROOM = 25,
  MissionTarget_Type_SURVIVE_TO = 26,
  MissionTarget_Type_PETHALO_COUNT = 27,
  MissionTarget_Type_PETHALO_LEVEL = 28,
  MissionTarget_Type_RECHARGE_OPEN = 29,
  MissionTarget_Type_STRONGALL_OPEN = 30,
  MissionTarget_Type_TOWER_OPEN = 31,
  MissionTarget_Type_OBTRIDE_OPEN = 32,
  MissionTarget_Type_LEVELUPRIDE_OPEN = 33,
  MissionTarget_Type_TRAINRIDE_OPEN = 34,
  MissionTarget_Type_PETEVOLUTION_OPEN = 35,
  MissionTarget_Type_OBTGODSHIP_OPEN = 36,
  MissionTarget_Type_LEVELUPGODSHIP_OPEN = 37,
  MissionTarget_Type_JINJIEAWAKEN_OPEN = 38
};
bool MissionTarget_Type_IsValid(int value);
const MissionTarget_Type MissionTarget_Type_Type_MIN = MissionTarget_Type_NONE;
const MissionTarget_Type MissionTarget_Type_Type_MAX = MissionTarget_Type_JINJIEAWAKEN_OPEN;
const int MissionTarget_Type_Type_ARRAYSIZE = MissionTarget_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MissionTarget_Type_descriptor();
inline const ::std::string& MissionTarget_Type_Name(MissionTarget_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MissionTarget_Type_descriptor(), value);
}
inline bool MissionTarget_Type_Parse(
    const ::std::string& name, MissionTarget_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MissionTarget_Type>(
    MissionTarget_Type_descriptor(), name, value);
}
enum MissionAward_Type {
  MissionAward_Type_NONE = 0,
  MissionAward_Type_EXP = 1,
  MissionAward_Type_MONEY = 2,
  MissionAward_Type_GOODS = 3,
  MissionAward_Type_EQUIPMENT = 4,
  MissionAward_Type_DESIGNATION = 5,
  MissionAward_Type_RMB = 6,
  MissionAward_Type_SOULJADE = 7,
  MissionAward_Type_SOUL = 8,
  MissionAward_Type_SOULSTONE = 9,
  MissionAward_Type_HONOR = 10,
  MissionAward_Type_DURABILITY = 11,
  MissionAward_Type_SUBRMB = 12,
  MissionAward_Type_ACTIVITY = 13,
  MissionAward_Type_OPENSERVERSCORE = 14
};
bool MissionAward_Type_IsValid(int value);
const MissionAward_Type MissionAward_Type_Type_MIN = MissionAward_Type_NONE;
const MissionAward_Type MissionAward_Type_Type_MAX = MissionAward_Type_OPENSERVERSCORE;
const int MissionAward_Type_Type_ARRAYSIZE = MissionAward_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MissionAward_Type_descriptor();
inline const ::std::string& MissionAward_Type_Name(MissionAward_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MissionAward_Type_descriptor(), value);
}
inline bool MissionAward_Type_Parse(
    const ::std::string& name, MissionAward_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MissionAward_Type>(
    MissionAward_Type_descriptor(), name, value);
}
enum MissionPort_Type {
  MissionPort_Type_NPC = 0,
  MissionPort_Type_AUTO = 1,
  MissionPort_Type_CHANGE_SCENE = 2,
  MissionPort_Type_LOGIN = 3
};
bool MissionPort_Type_IsValid(int value);
const MissionPort_Type MissionPort_Type_Type_MIN = MissionPort_Type_NPC;
const MissionPort_Type MissionPort_Type_Type_MAX = MissionPort_Type_LOGIN;
const int MissionPort_Type_Type_ARRAYSIZE = MissionPort_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MissionPort_Type_descriptor();
inline const ::std::string& MissionPort_Type_Name(MissionPort_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MissionPort_Type_descriptor(), value);
}
inline bool MissionPort_Type_Parse(
    const ::std::string& name, MissionPort_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MissionPort_Type>(
    MissionPort_Type_descriptor(), name, value);
}
enum MissionTrack_Type {
  MissionTrack_Type_NONE = 0,
  MissionTrack_Type_ROOM = 1,
  MissionTrack_Type_NPC = 2,
  MissionTrack_Type_OPENUI = 3
};
bool MissionTrack_Type_IsValid(int value);
const MissionTrack_Type MissionTrack_Type_Type_MIN = MissionTrack_Type_NONE;
const MissionTrack_Type MissionTrack_Type_Type_MAX = MissionTrack_Type_OPENUI;
const int MissionTrack_Type_Type_ARRAYSIZE = MissionTrack_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MissionTrack_Type_descriptor();
inline const ::std::string& MissionTrack_Type_Name(MissionTrack_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MissionTrack_Type_descriptor(), value);
}
inline bool MissionTrack_Type_Parse(
    const ::std::string& name, MissionTrack_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MissionTrack_Type>(
    MissionTrack_Type_descriptor(), name, value);
}
enum MissionInfo_Type {
  MissionInfo_Type_MAJOR = 0,
  MissionInfo_Type_MINOR = 1,
  MissionInfo_Type_DAILY = 2,
  MissionInfo_Type_LINE = 3,
  MissionInfo_Type_OPENSERVER = 4
};
bool MissionInfo_Type_IsValid(int value);
const MissionInfo_Type MissionInfo_Type_Type_MIN = MissionInfo_Type_MAJOR;
const MissionInfo_Type MissionInfo_Type_Type_MAX = MissionInfo_Type_OPENSERVER;
const int MissionInfo_Type_Type_ARRAYSIZE = MissionInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MissionInfo_Type_descriptor();
inline const ::std::string& MissionInfo_Type_Name(MissionInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MissionInfo_Type_descriptor(), value);
}
inline bool MissionInfo_Type_Parse(
    const ::std::string& name, MissionInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MissionInfo_Type>(
    MissionInfo_Type_descriptor(), name, value);
}
// ===================================================================

class MissionContent : public ::google::protobuf::Message {
 public:
  MissionContent();
  virtual ~MissionContent();
  
  MissionContent(const MissionContent& from);
  
  inline MissionContent& operator=(const MissionContent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionContent& default_instance();
  
  void Swap(MissionContent* other);
  
  // implements Message ----------------------------------------------
  
  MissionContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionContent& from);
  void MergeFrom(const MissionContent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string mission = 1;
  inline int mission_size() const;
  inline void clear_mission();
  static const int kMissionFieldNumber = 1;
  inline const ::std::string& mission(int index) const;
  inline ::std::string* mutable_mission(int index);
  inline void set_mission(int index, const ::std::string& value);
  inline void set_mission(int index, const char* value);
  inline void set_mission(int index, const char* value, size_t size);
  inline ::std::string* add_mission();
  inline void add_mission(const ::std::string& value);
  inline void add_mission(const char* value);
  inline void add_mission(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mission() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mission();
  
  // optional string accept = 2;
  inline bool has_accept() const;
  inline void clear_accept();
  static const int kAcceptFieldNumber = 2;
  inline const ::std::string& accept() const;
  inline void set_accept(const ::std::string& value);
  inline void set_accept(const char* value);
  inline void set_accept(const char* value, size_t size);
  inline ::std::string* mutable_accept();
  inline ::std::string* release_accept();
  
  // optional string reject = 3;
  inline bool has_reject() const;
  inline void clear_reject();
  static const int kRejectFieldNumber = 3;
  inline const ::std::string& reject() const;
  inline void set_reject(const ::std::string& value);
  inline void set_reject(const char* value);
  inline void set_reject(const char* value, size_t size);
  inline ::std::string* mutable_reject();
  inline ::std::string* release_reject();
  
  // @@protoc_insertion_point(class_scope:MissionContent)
 private:
  inline void set_has_accept();
  inline void clear_has_accept();
  inline void set_has_reject();
  inline void clear_has_reject();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> mission_;
  ::std::string* accept_;
  ::std::string* reject_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static MissionContent* default_instance_;
};
// -------------------------------------------------------------------

class MissionArg : public ::google::protobuf::Message {
 public:
  MissionArg();
  virtual ~MissionArg();
  
  MissionArg(const MissionArg& from);
  
  inline MissionArg& operator=(const MissionArg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionArg& default_instance();
  
  void Swap(MissionArg* other);
  
  // implements Message ----------------------------------------------
  
  MissionArg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionArg& from);
  void MergeFrom(const MissionArg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 arg = 1;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 1;
  inline ::google::protobuf::int32 arg(int index) const;
  inline void set_arg(int index, ::google::protobuf::int32 value);
  inline void add_arg(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      arg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_arg();
  
  // @@protoc_insertion_point(class_scope:MissionArg)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > arg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static MissionArg* default_instance_;
};
// -------------------------------------------------------------------

class MissionOpen : public ::google::protobuf::Message {
 public:
  MissionOpen();
  virtual ~MissionOpen();
  
  MissionOpen(const MissionOpen& from);
  
  inline MissionOpen& operator=(const MissionOpen& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionOpen& default_instance();
  
  void Swap(MissionOpen* other);
  
  // implements Message ----------------------------------------------
  
  MissionOpen* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionOpen& from);
  void MergeFrom(const MissionOpen& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MissionOpen_Type Type;
  static const Type NONE = MissionOpen_Type_NONE;
  static const Type LEVEL = MissionOpen_Type_LEVEL;
  static const Type COMPLETE_MISSION = MissionOpen_Type_COMPLETE_MISSION;
  static const Type HASGOODS = MissionOpen_Type_HASGOODS;
  static const Type APPLY_MISSION = MissionOpen_Type_APPLY_MISSION;
  static const Type OPENSERVERDATE = MissionOpen_Type_OPENSERVERDATE;
  static inline bool Type_IsValid(int value) {
    return MissionOpen_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MissionOpen_Type_Type_MIN;
  static const Type Type_MAX =
    MissionOpen_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MissionOpen_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MissionOpen_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MissionOpen_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MissionOpen_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // repeated .MissionOpen.Type type = 1;
  inline int type_size() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::MissionOpen_Type type(int index) const;
  inline void set_type(int index, ::MissionOpen_Type value);
  inline void add_type(::MissionOpen_Type value);
  inline const ::google::protobuf::RepeatedField<int>& type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_type();
  
  // repeated .MissionArg arg = 2;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 2;
  inline const ::MissionArg& arg(int index) const;
  inline ::MissionArg* mutable_arg(int index);
  inline ::MissionArg* add_arg();
  inline const ::google::protobuf::RepeatedPtrField< ::MissionArg >&
      arg() const;
  inline ::google::protobuf::RepeatedPtrField< ::MissionArg >*
      mutable_arg();
  
  // @@protoc_insertion_point(class_scope:MissionOpen)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField<int> type_;
  ::google::protobuf::RepeatedPtrField< ::MissionArg > arg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static MissionOpen* default_instance_;
};
// -------------------------------------------------------------------

class MissionTarget : public ::google::protobuf::Message {
 public:
  MissionTarget();
  virtual ~MissionTarget();
  
  MissionTarget(const MissionTarget& from);
  
  inline MissionTarget& operator=(const MissionTarget& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionTarget& default_instance();
  
  void Swap(MissionTarget* other);
  
  // implements Message ----------------------------------------------
  
  MissionTarget* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionTarget& from);
  void MergeFrom(const MissionTarget& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MissionTarget_Type Type;
  static const Type NONE = MissionTarget_Type_NONE;
  static const Type KILLNPC = MissionTarget_Type_KILLNPC;
  static const Type TALK = MissionTarget_Type_TALK;
  static const Type GETGOODS = MissionTarget_Type_GETGOODS;
  static const Type CLEAR_ROOM = MissionTarget_Type_CLEAR_ROOM;
  static const Type CLEAR_ONLYROOM = MissionTarget_Type_CLEAR_ONLYROOM;
  static const Type CLEAR_TOWER = MissionTarget_Type_CLEAR_TOWER;
  static const Type CLEAR_SURVIVE = MissionTarget_Type_CLEAR_SURVIVE;
  static const Type CLEAR_HERO = MissionTarget_Type_CLEAR_HERO;
  static const Type STRONG = MissionTarget_Type_STRONG;
  static const Type UNLOCK_BLOODNODE = MissionTarget_Type_UNLOCK_BLOODNODE;
  static const Type PVP = MissionTarget_Type_PVP;
  static const Type LEVEL_TO = MissionTarget_Type_LEVEL_TO;
  static const Type MOUNT = MissionTarget_Type_MOUNT;
  static const Type ENHANCE = MissionTarget_Type_ENHANCE;
  static const Type STRONG_WING_TO = MissionTarget_Type_STRONG_WING_TO;
  static const Type SKILL_LEVEL_TO = MissionTarget_Type_SKILL_LEVEL_TO;
  static const Type HELL_KILL = MissionTarget_Type_HELL_KILL;
  static const Type ADD_FRIEND = MissionTarget_Type_ADD_FRIEND;
  static const Type BE_ADDED_FRIEND = MissionTarget_Type_BE_ADDED_FRIEND;
  static const Type STRONG_TO = MissionTarget_Type_STRONG_TO;
  static const Type UNLOCK_BLOODNODE_TO = MissionTarget_Type_UNLOCK_BLOODNODE_TO;
  static const Type ENTER_ANY_ROOM = MissionTarget_Type_ENTER_ANY_ROOM;
  static const Type SURVIVE_TO = MissionTarget_Type_SURVIVE_TO;
  static const Type PETHALO_COUNT = MissionTarget_Type_PETHALO_COUNT;
  static const Type PETHALO_LEVEL = MissionTarget_Type_PETHALO_LEVEL;
  static const Type RECHARGE_OPEN = MissionTarget_Type_RECHARGE_OPEN;
  static const Type STRONGALL_OPEN = MissionTarget_Type_STRONGALL_OPEN;
  static const Type TOWER_OPEN = MissionTarget_Type_TOWER_OPEN;
  static const Type OBTRIDE_OPEN = MissionTarget_Type_OBTRIDE_OPEN;
  static const Type LEVELUPRIDE_OPEN = MissionTarget_Type_LEVELUPRIDE_OPEN;
  static const Type TRAINRIDE_OPEN = MissionTarget_Type_TRAINRIDE_OPEN;
  static const Type PETEVOLUTION_OPEN = MissionTarget_Type_PETEVOLUTION_OPEN;
  static const Type OBTGODSHIP_OPEN = MissionTarget_Type_OBTGODSHIP_OPEN;
  static const Type LEVELUPGODSHIP_OPEN = MissionTarget_Type_LEVELUPGODSHIP_OPEN;
  static const Type JINJIEAWAKEN_OPEN = MissionTarget_Type_JINJIEAWAKEN_OPEN;
  static inline bool Type_IsValid(int value) {
    return MissionTarget_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MissionTarget_Type_Type_MIN;
  static const Type Type_MAX =
    MissionTarget_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MissionTarget_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MissionTarget_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MissionTarget_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MissionTarget_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // repeated .MissionTarget.Type type = 1;
  inline int type_size() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::MissionTarget_Type type(int index) const;
  inline void set_type(int index, ::MissionTarget_Type value);
  inline void add_type(::MissionTarget_Type value);
  inline const ::google::protobuf::RepeatedField<int>& type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_type();
  
  // repeated .MissionArg arg = 2;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 2;
  inline const ::MissionArg& arg(int index) const;
  inline ::MissionArg* mutable_arg(int index);
  inline ::MissionArg* add_arg();
  inline const ::google::protobuf::RepeatedPtrField< ::MissionArg >&
      arg() const;
  inline ::google::protobuf::RepeatedPtrField< ::MissionArg >*
      mutable_arg();
  
  // @@protoc_insertion_point(class_scope:MissionTarget)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField<int> type_;
  ::google::protobuf::RepeatedPtrField< ::MissionArg > arg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static MissionTarget* default_instance_;
};
// -------------------------------------------------------------------

class MissionAward : public ::google::protobuf::Message {
 public:
  MissionAward();
  virtual ~MissionAward();
  
  MissionAward(const MissionAward& from);
  
  inline MissionAward& operator=(const MissionAward& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionAward& default_instance();
  
  void Swap(MissionAward* other);
  
  // implements Message ----------------------------------------------
  
  MissionAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionAward& from);
  void MergeFrom(const MissionAward& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MissionAward_Type Type;
  static const Type NONE = MissionAward_Type_NONE;
  static const Type EXP = MissionAward_Type_EXP;
  static const Type MONEY = MissionAward_Type_MONEY;
  static const Type GOODS = MissionAward_Type_GOODS;
  static const Type EQUIPMENT = MissionAward_Type_EQUIPMENT;
  static const Type DESIGNATION = MissionAward_Type_DESIGNATION;
  static const Type RMB = MissionAward_Type_RMB;
  static const Type SOULJADE = MissionAward_Type_SOULJADE;
  static const Type SOUL = MissionAward_Type_SOUL;
  static const Type SOULSTONE = MissionAward_Type_SOULSTONE;
  static const Type HONOR = MissionAward_Type_HONOR;
  static const Type DURABILITY = MissionAward_Type_DURABILITY;
  static const Type SUBRMB = MissionAward_Type_SUBRMB;
  static const Type ACTIVITY = MissionAward_Type_ACTIVITY;
  static const Type OPENSERVERSCORE = MissionAward_Type_OPENSERVERSCORE;
  static inline bool Type_IsValid(int value) {
    return MissionAward_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MissionAward_Type_Type_MIN;
  static const Type Type_MAX =
    MissionAward_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MissionAward_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MissionAward_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MissionAward_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MissionAward_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // repeated .MissionAward.Type type = 1;
  inline int type_size() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::MissionAward_Type type(int index) const;
  inline void set_type(int index, ::MissionAward_Type value);
  inline void add_type(::MissionAward_Type value);
  inline const ::google::protobuf::RepeatedField<int>& type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_type();
  
  // repeated .MissionArg arg = 2;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 2;
  inline const ::MissionArg& arg(int index) const;
  inline ::MissionArg* mutable_arg(int index);
  inline ::MissionArg* add_arg();
  inline const ::google::protobuf::RepeatedPtrField< ::MissionArg >&
      arg() const;
  inline ::google::protobuf::RepeatedPtrField< ::MissionArg >*
      mutable_arg();
  
  // @@protoc_insertion_point(class_scope:MissionAward)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField<int> type_;
  ::google::protobuf::RepeatedPtrField< ::MissionArg > arg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static MissionAward* default_instance_;
};
// -------------------------------------------------------------------

class MissionPort : public ::google::protobuf::Message {
 public:
  MissionPort();
  virtual ~MissionPort();
  
  MissionPort(const MissionPort& from);
  
  inline MissionPort& operator=(const MissionPort& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionPort& default_instance();
  
  void Swap(MissionPort* other);
  
  // implements Message ----------------------------------------------
  
  MissionPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionPort& from);
  void MergeFrom(const MissionPort& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MissionPort_Type Type;
  static const Type NPC = MissionPort_Type_NPC;
  static const Type AUTO = MissionPort_Type_AUTO;
  static const Type CHANGE_SCENE = MissionPort_Type_CHANGE_SCENE;
  static const Type LOGIN = MissionPort_Type_LOGIN;
  static inline bool Type_IsValid(int value) {
    return MissionPort_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MissionPort_Type_Type_MIN;
  static const Type Type_MAX =
    MissionPort_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MissionPort_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MissionPort_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MissionPort_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MissionPort_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .MissionPort.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::MissionPort_Type type() const;
  inline void set_type(::MissionPort_Type value);
  
  // repeated int32 arg = 2;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 2;
  inline ::google::protobuf::int32 arg(int index) const;
  inline void set_arg(int index, ::google::protobuf::int32 value);
  inline void add_arg(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      arg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_arg();
  
  // @@protoc_insertion_point(class_scope:MissionPort)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > arg_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static MissionPort* default_instance_;
};
// -------------------------------------------------------------------

class MissionTrack : public ::google::protobuf::Message {
 public:
  MissionTrack();
  virtual ~MissionTrack();
  
  MissionTrack(const MissionTrack& from);
  
  inline MissionTrack& operator=(const MissionTrack& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionTrack& default_instance();
  
  void Swap(MissionTrack* other);
  
  // implements Message ----------------------------------------------
  
  MissionTrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionTrack& from);
  void MergeFrom(const MissionTrack& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MissionTrack_Type Type;
  static const Type NONE = MissionTrack_Type_NONE;
  static const Type ROOM = MissionTrack_Type_ROOM;
  static const Type NPC = MissionTrack_Type_NPC;
  static const Type OPENUI = MissionTrack_Type_OPENUI;
  static inline bool Type_IsValid(int value) {
    return MissionTrack_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MissionTrack_Type_Type_MIN;
  static const Type Type_MAX =
    MissionTrack_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MissionTrack_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MissionTrack_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MissionTrack_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MissionTrack_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .MissionTrack.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::MissionTrack_Type type() const;
  inline void set_type(::MissionTrack_Type value);
  
  // repeated int32 arg = 2;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 2;
  inline ::google::protobuf::int32 arg(int index) const;
  inline void set_arg(int index, ::google::protobuf::int32 value);
  inline void add_arg(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      arg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_arg();
  
  // @@protoc_insertion_point(class_scope:MissionTrack)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > arg_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static MissionTrack* default_instance_;
};
// -------------------------------------------------------------------

class MissionInfo : public ::google::protobuf::Message {
 public:
  MissionInfo();
  virtual ~MissionInfo();
  
  MissionInfo(const MissionInfo& from);
  
  inline MissionInfo& operator=(const MissionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionInfo& default_instance();
  
  void Swap(MissionInfo* other);
  
  // implements Message ----------------------------------------------
  
  MissionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionInfo& from);
  void MergeFrom(const MissionInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MissionInfo_Type Type;
  static const Type MAJOR = MissionInfo_Type_MAJOR;
  static const Type MINOR = MissionInfo_Type_MINOR;
  static const Type DAILY = MissionInfo_Type_DAILY;
  static const Type LINE = MissionInfo_Type_LINE;
  static const Type OPENSERVER = MissionInfo_Type_OPENSERVER;
  static inline bool Type_IsValid(int value) {
    return MissionInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MissionInfo_Type_Type_MIN;
  static const Type Type_MAX =
    MissionInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MissionInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MissionInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MissionInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MissionInfo_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .MissionInfo.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::MissionInfo_Type type() const;
  inline void set_type(::MissionInfo_Type value);
  
  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // optional string inContent = 5;
  inline bool has_inContent() const;
  inline void clear_inContent();
  static const int kInContentFieldNumber = 5;
  inline const ::std::string& inContent() const;
  inline void set_inContent(const ::std::string& value);
  inline void set_inContent(const char* value);
  inline void set_inContent(const char* value, size_t size);
  inline ::std::string* mutable_inContent();
  inline ::std::string* release_inContent();
  
  // optional .MissionOpen open = 6;
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 6;
  inline const ::MissionOpen& open() const;
  inline ::MissionOpen* mutable_open();
  inline ::MissionOpen* release_open();
  
  // optional .MissionTarget target = 7;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 7;
  inline const ::MissionTarget& target() const;
  inline ::MissionTarget* mutable_target();
  inline ::MissionTarget* release_target();
  
  // optional .MissionAward award = 8;
  inline bool has_award() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 8;
  inline const ::MissionAward& award() const;
  inline ::MissionAward* mutable_award();
  inline ::MissionAward* release_award();
  
  // optional int32 next = 9;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 9;
  inline ::google::protobuf::int32 next() const;
  inline void set_next(::google::protobuf::int32 value);
  
  // optional int32 maxCount = 10;
  inline bool has_maxCount() const;
  inline void clear_maxCount();
  static const int kMaxCountFieldNumber = 10;
  inline ::google::protobuf::int32 maxCount() const;
  inline void set_maxCount(::google::protobuf::int32 value);
  
  // optional int32 groupID = 11;
  inline bool has_groupID() const;
  inline void clear_groupID();
  static const int kGroupIDFieldNumber = 11;
  inline ::google::protobuf::int32 groupID() const;
  inline void set_groupID(::google::protobuf::int32 value);
  
  // optional .MissionPort in = 12;
  inline bool has_in() const;
  inline void clear_in();
  static const int kInFieldNumber = 12;
  inline const ::MissionPort& in() const;
  inline ::MissionPort* mutable_in();
  inline ::MissionPort* release_in();
  
  // optional .MissionPort out = 13;
  inline bool has_out() const;
  inline void clear_out();
  static const int kOutFieldNumber = 13;
  inline const ::MissionPort& out() const;
  inline ::MissionPort* mutable_out();
  inline ::MissionPort* release_out();
  
  // optional string completeDesc = 14;
  inline bool has_completeDesc() const;
  inline void clear_completeDesc();
  static const int kCompleteDescFieldNumber = 14;
  inline const ::std::string& completeDesc() const;
  inline void set_completeDesc(const ::std::string& value);
  inline void set_completeDesc(const char* value);
  inline void set_completeDesc(const char* value, size_t size);
  inline ::std::string* mutable_completeDesc();
  inline ::std::string* release_completeDesc();
  
  // optional string outContent = 15;
  inline bool has_outContent() const;
  inline void clear_outContent();
  static const int kOutContentFieldNumber = 15;
  inline const ::std::string& outContent() const;
  inline void set_outContent(const ::std::string& value);
  inline void set_outContent(const char* value);
  inline void set_outContent(const char* value, size_t size);
  inline ::std::string* mutable_outContent();
  inline ::std::string* release_outContent();
  
  // optional .MissionTrack targetTrack = 16;
  inline bool has_targetTrack() const;
  inline void clear_targetTrack();
  static const int kTargetTrackFieldNumber = 16;
  inline const ::MissionTrack& targetTrack() const;
  inline ::MissionTrack* mutable_targetTrack();
  inline ::MissionTrack* release_targetTrack();
  
  // optional .MissionTrack outTrack = 17;
  inline bool has_outTrack() const;
  inline void clear_outTrack();
  static const int kOutTrackFieldNumber = 17;
  inline const ::MissionTrack& outTrack() const;
  inline ::MissionTrack* mutable_outTrack();
  inline ::MissionTrack* release_outTrack();
  
  // @@protoc_insertion_point(class_scope:MissionInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_inContent();
  inline void clear_has_inContent();
  inline void set_has_open();
  inline void clear_has_open();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_award();
  inline void clear_has_award();
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_maxCount();
  inline void clear_has_maxCount();
  inline void set_has_groupID();
  inline void clear_has_groupID();
  inline void set_has_in();
  inline void clear_has_in();
  inline void set_has_out();
  inline void clear_has_out();
  inline void set_has_completeDesc();
  inline void clear_has_completeDesc();
  inline void set_has_outContent();
  inline void clear_has_outContent();
  inline void set_has_targetTrack();
  inline void clear_has_targetTrack();
  inline void set_has_outTrack();
  inline void clear_has_outTrack();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  ::google::protobuf::int32 id_;
  ::std::string* name_;
  ::std::string* desc_;
  ::std::string* inContent_;
  ::MissionOpen* open_;
  ::MissionTarget* target_;
  ::MissionAward* award_;
  ::google::protobuf::int32 next_;
  ::google::protobuf::int32 maxCount_;
  ::MissionPort* in_;
  ::MissionPort* out_;
  ::std::string* completeDesc_;
  ::std::string* outContent_;
  ::MissionTrack* targetTrack_;
  ::MissionTrack* outTrack_;
  ::google::protobuf::int32 groupID_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static MissionInfo* default_instance_;
};
// -------------------------------------------------------------------

class AllMissions : public ::google::protobuf::Message {
 public:
  AllMissions();
  virtual ~AllMissions();
  
  AllMissions(const AllMissions& from);
  
  inline AllMissions& operator=(const AllMissions& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllMissions& default_instance();
  
  void Swap(AllMissions* other);
  
  // implements Message ----------------------------------------------
  
  AllMissions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllMissions& from);
  void MergeFrom(const AllMissions& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MissionInfo missions = 1;
  inline int missions_size() const;
  inline void clear_missions();
  static const int kMissionsFieldNumber = 1;
  inline const ::MissionInfo& missions(int index) const;
  inline ::MissionInfo* mutable_missions(int index);
  inline ::MissionInfo* add_missions();
  inline const ::google::protobuf::RepeatedPtrField< ::MissionInfo >&
      missions() const;
  inline ::google::protobuf::RepeatedPtrField< ::MissionInfo >*
      mutable_missions();
  
  // @@protoc_insertion_point(class_scope:AllMissions)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::MissionInfo > missions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AllMissions* default_instance_;
};
// -------------------------------------------------------------------

class PB_MissionTargetRecord : public ::google::protobuf::Message {
 public:
  PB_MissionTargetRecord();
  virtual ~PB_MissionTargetRecord();
  
  PB_MissionTargetRecord(const PB_MissionTargetRecord& from);
  
  inline PB_MissionTargetRecord& operator=(const PB_MissionTargetRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PB_MissionTargetRecord& default_instance();
  
  void Swap(PB_MissionTargetRecord* other);
  
  // implements Message ----------------------------------------------
  
  PB_MissionTargetRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PB_MissionTargetRecord& from);
  void MergeFrom(const PB_MissionTargetRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 arg = 1;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 1;
  inline ::google::protobuf::int32 arg(int index) const;
  inline void set_arg(int index, ::google::protobuf::int32 value);
  inline void add_arg(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      arg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_arg();
  
  // @@protoc_insertion_point(class_scope:PB_MissionTargetRecord)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > arg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static PB_MissionTargetRecord* default_instance_;
};
// -------------------------------------------------------------------

class PB_MissionRecord : public ::google::protobuf::Message {
 public:
  PB_MissionRecord();
  virtual ~PB_MissionRecord();
  
  PB_MissionRecord(const PB_MissionRecord& from);
  
  inline PB_MissionRecord& operator=(const PB_MissionRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PB_MissionRecord& default_instance();
  
  void Swap(PB_MissionRecord* other);
  
  // implements Message ----------------------------------------------
  
  PB_MissionRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PB_MissionRecord& from);
  void MergeFrom(const PB_MissionRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // repeated .PB_MissionTargetRecord target = 2;
  inline int target_size() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::PB_MissionTargetRecord& target(int index) const;
  inline ::PB_MissionTargetRecord* mutable_target(int index);
  inline ::PB_MissionTargetRecord* add_target();
  inline const ::google::protobuf::RepeatedPtrField< ::PB_MissionTargetRecord >&
      target() const;
  inline ::google::protobuf::RepeatedPtrField< ::PB_MissionTargetRecord >*
      mutable_target();
  
  // @@protoc_insertion_point(class_scope:PB_MissionRecord)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::PB_MissionTargetRecord > target_;
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static PB_MissionRecord* default_instance_;
};
// -------------------------------------------------------------------

class PB_MissionAllRecord : public ::google::protobuf::Message {
 public:
  PB_MissionAllRecord();
  virtual ~PB_MissionAllRecord();
  
  PB_MissionAllRecord(const PB_MissionAllRecord& from);
  
  inline PB_MissionAllRecord& operator=(const PB_MissionAllRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PB_MissionAllRecord& default_instance();
  
  void Swap(PB_MissionAllRecord* other);
  
  // implements Message ----------------------------------------------
  
  PB_MissionAllRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PB_MissionAllRecord& from);
  void MergeFrom(const PB_MissionAllRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PB_MissionRecord records = 1;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 1;
  inline const ::PB_MissionRecord& records(int index) const;
  inline ::PB_MissionRecord* mutable_records(int index);
  inline ::PB_MissionRecord* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::PB_MissionRecord >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::PB_MissionRecord >*
      mutable_records();
  
  // repeated int32 cur = 2;
  inline int cur_size() const;
  inline void clear_cur();
  static const int kCurFieldNumber = 2;
  inline ::google::protobuf::int32 cur(int index) const;
  inline void set_cur(int index, ::google::protobuf::int32 value);
  inline void add_cur(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      cur() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_cur();
  
  // @@protoc_insertion_point(class_scope:PB_MissionAllRecord)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::PB_MissionRecord > records_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > cur_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_MissionInfo_2eproto();
  friend void protobuf_AssignDesc_MissionInfo_2eproto();
  friend void protobuf_ShutdownFile_MissionInfo_2eproto();
  
  void InitAsDefaultInstance();
  static PB_MissionAllRecord* default_instance_;
};
// ===================================================================


// ===================================================================

// MissionContent

// repeated string mission = 1;
inline int MissionContent::mission_size() const {
  return mission_.size();
}
inline void MissionContent::clear_mission() {
  mission_.Clear();
}
inline const ::std::string& MissionContent::mission(int index) const {
  return mission_.Get(index);
}
inline ::std::string* MissionContent::mutable_mission(int index) {
  return mission_.Mutable(index);
}
inline void MissionContent::set_mission(int index, const ::std::string& value) {
  mission_.Mutable(index)->assign(value);
}
inline void MissionContent::set_mission(int index, const char* value) {
  mission_.Mutable(index)->assign(value);
}
inline void MissionContent::set_mission(int index, const char* value, size_t size) {
  mission_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionContent::add_mission() {
  return mission_.Add();
}
inline void MissionContent::add_mission(const ::std::string& value) {
  mission_.Add()->assign(value);
}
inline void MissionContent::add_mission(const char* value) {
  mission_.Add()->assign(value);
}
inline void MissionContent::add_mission(const char* value, size_t size) {
  mission_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MissionContent::mission() const {
  return mission_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MissionContent::mutable_mission() {
  return &mission_;
}

// optional string accept = 2;
inline bool MissionContent::has_accept() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MissionContent::set_has_accept() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MissionContent::clear_has_accept() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MissionContent::clear_accept() {
  if (accept_ != &::google::protobuf::internal::kEmptyString) {
    accept_->clear();
  }
  clear_has_accept();
}
inline const ::std::string& MissionContent::accept() const {
  return *accept_;
}
inline void MissionContent::set_accept(const ::std::string& value) {
  set_has_accept();
  if (accept_ == &::google::protobuf::internal::kEmptyString) {
    accept_ = new ::std::string;
  }
  accept_->assign(value);
}
inline void MissionContent::set_accept(const char* value) {
  set_has_accept();
  if (accept_ == &::google::protobuf::internal::kEmptyString) {
    accept_ = new ::std::string;
  }
  accept_->assign(value);
}
inline void MissionContent::set_accept(const char* value, size_t size) {
  set_has_accept();
  if (accept_ == &::google::protobuf::internal::kEmptyString) {
    accept_ = new ::std::string;
  }
  accept_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionContent::mutable_accept() {
  set_has_accept();
  if (accept_ == &::google::protobuf::internal::kEmptyString) {
    accept_ = new ::std::string;
  }
  return accept_;
}
inline ::std::string* MissionContent::release_accept() {
  clear_has_accept();
  if (accept_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accept_;
    accept_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string reject = 3;
inline bool MissionContent::has_reject() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MissionContent::set_has_reject() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MissionContent::clear_has_reject() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MissionContent::clear_reject() {
  if (reject_ != &::google::protobuf::internal::kEmptyString) {
    reject_->clear();
  }
  clear_has_reject();
}
inline const ::std::string& MissionContent::reject() const {
  return *reject_;
}
inline void MissionContent::set_reject(const ::std::string& value) {
  set_has_reject();
  if (reject_ == &::google::protobuf::internal::kEmptyString) {
    reject_ = new ::std::string;
  }
  reject_->assign(value);
}
inline void MissionContent::set_reject(const char* value) {
  set_has_reject();
  if (reject_ == &::google::protobuf::internal::kEmptyString) {
    reject_ = new ::std::string;
  }
  reject_->assign(value);
}
inline void MissionContent::set_reject(const char* value, size_t size) {
  set_has_reject();
  if (reject_ == &::google::protobuf::internal::kEmptyString) {
    reject_ = new ::std::string;
  }
  reject_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionContent::mutable_reject() {
  set_has_reject();
  if (reject_ == &::google::protobuf::internal::kEmptyString) {
    reject_ = new ::std::string;
  }
  return reject_;
}
inline ::std::string* MissionContent::release_reject() {
  clear_has_reject();
  if (reject_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reject_;
    reject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MissionArg

// repeated int32 arg = 1;
inline int MissionArg::arg_size() const {
  return arg_.size();
}
inline void MissionArg::clear_arg() {
  arg_.Clear();
}
inline ::google::protobuf::int32 MissionArg::arg(int index) const {
  return arg_.Get(index);
}
inline void MissionArg::set_arg(int index, ::google::protobuf::int32 value) {
  arg_.Set(index, value);
}
inline void MissionArg::add_arg(::google::protobuf::int32 value) {
  arg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MissionArg::arg() const {
  return arg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MissionArg::mutable_arg() {
  return &arg_;
}

// -------------------------------------------------------------------

// MissionOpen

// repeated .MissionOpen.Type type = 1;
inline int MissionOpen::type_size() const {
  return type_.size();
}
inline void MissionOpen::clear_type() {
  type_.Clear();
}
inline ::MissionOpen_Type MissionOpen::type(int index) const {
  return static_cast< ::MissionOpen_Type >(type_.Get(index));
}
inline void MissionOpen::set_type(int index, ::MissionOpen_Type value) {
  GOOGLE_DCHECK(::MissionOpen_Type_IsValid(value));
  type_.Set(index, value);
}
inline void MissionOpen::add_type(::MissionOpen_Type value) {
  GOOGLE_DCHECK(::MissionOpen_Type_IsValid(value));
  type_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
MissionOpen::type() const {
  return type_;
}
inline ::google::protobuf::RepeatedField<int>*
MissionOpen::mutable_type() {
  return &type_;
}

// repeated .MissionArg arg = 2;
inline int MissionOpen::arg_size() const {
  return arg_.size();
}
inline void MissionOpen::clear_arg() {
  arg_.Clear();
}
inline const ::MissionArg& MissionOpen::arg(int index) const {
  return arg_.Get(index);
}
inline ::MissionArg* MissionOpen::mutable_arg(int index) {
  return arg_.Mutable(index);
}
inline ::MissionArg* MissionOpen::add_arg() {
  return arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MissionArg >&
MissionOpen::arg() const {
  return arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::MissionArg >*
MissionOpen::mutable_arg() {
  return &arg_;
}

// -------------------------------------------------------------------

// MissionTarget

// repeated .MissionTarget.Type type = 1;
inline int MissionTarget::type_size() const {
  return type_.size();
}
inline void MissionTarget::clear_type() {
  type_.Clear();
}
inline ::MissionTarget_Type MissionTarget::type(int index) const {
  return static_cast< ::MissionTarget_Type >(type_.Get(index));
}
inline void MissionTarget::set_type(int index, ::MissionTarget_Type value) {
  GOOGLE_DCHECK(::MissionTarget_Type_IsValid(value));
  type_.Set(index, value);
}
inline void MissionTarget::add_type(::MissionTarget_Type value) {
  GOOGLE_DCHECK(::MissionTarget_Type_IsValid(value));
  type_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
MissionTarget::type() const {
  return type_;
}
inline ::google::protobuf::RepeatedField<int>*
MissionTarget::mutable_type() {
  return &type_;
}

// repeated .MissionArg arg = 2;
inline int MissionTarget::arg_size() const {
  return arg_.size();
}
inline void MissionTarget::clear_arg() {
  arg_.Clear();
}
inline const ::MissionArg& MissionTarget::arg(int index) const {
  return arg_.Get(index);
}
inline ::MissionArg* MissionTarget::mutable_arg(int index) {
  return arg_.Mutable(index);
}
inline ::MissionArg* MissionTarget::add_arg() {
  return arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MissionArg >&
MissionTarget::arg() const {
  return arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::MissionArg >*
MissionTarget::mutable_arg() {
  return &arg_;
}

// -------------------------------------------------------------------

// MissionAward

// repeated .MissionAward.Type type = 1;
inline int MissionAward::type_size() const {
  return type_.size();
}
inline void MissionAward::clear_type() {
  type_.Clear();
}
inline ::MissionAward_Type MissionAward::type(int index) const {
  return static_cast< ::MissionAward_Type >(type_.Get(index));
}
inline void MissionAward::set_type(int index, ::MissionAward_Type value) {
  GOOGLE_DCHECK(::MissionAward_Type_IsValid(value));
  type_.Set(index, value);
}
inline void MissionAward::add_type(::MissionAward_Type value) {
  GOOGLE_DCHECK(::MissionAward_Type_IsValid(value));
  type_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
MissionAward::type() const {
  return type_;
}
inline ::google::protobuf::RepeatedField<int>*
MissionAward::mutable_type() {
  return &type_;
}

// repeated .MissionArg arg = 2;
inline int MissionAward::arg_size() const {
  return arg_.size();
}
inline void MissionAward::clear_arg() {
  arg_.Clear();
}
inline const ::MissionArg& MissionAward::arg(int index) const {
  return arg_.Get(index);
}
inline ::MissionArg* MissionAward::mutable_arg(int index) {
  return arg_.Mutable(index);
}
inline ::MissionArg* MissionAward::add_arg() {
  return arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MissionArg >&
MissionAward::arg() const {
  return arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::MissionArg >*
MissionAward::mutable_arg() {
  return &arg_;
}

// -------------------------------------------------------------------

// MissionPort

// optional .MissionPort.Type type = 1;
inline bool MissionPort::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MissionPort::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MissionPort::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MissionPort::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::MissionPort_Type MissionPort::type() const {
  return static_cast< ::MissionPort_Type >(type_);
}
inline void MissionPort::set_type(::MissionPort_Type value) {
  GOOGLE_DCHECK(::MissionPort_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated int32 arg = 2;
inline int MissionPort::arg_size() const {
  return arg_.size();
}
inline void MissionPort::clear_arg() {
  arg_.Clear();
}
inline ::google::protobuf::int32 MissionPort::arg(int index) const {
  return arg_.Get(index);
}
inline void MissionPort::set_arg(int index, ::google::protobuf::int32 value) {
  arg_.Set(index, value);
}
inline void MissionPort::add_arg(::google::protobuf::int32 value) {
  arg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MissionPort::arg() const {
  return arg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MissionPort::mutable_arg() {
  return &arg_;
}

// -------------------------------------------------------------------

// MissionTrack

// optional .MissionTrack.Type type = 1;
inline bool MissionTrack::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MissionTrack::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MissionTrack::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MissionTrack::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::MissionTrack_Type MissionTrack::type() const {
  return static_cast< ::MissionTrack_Type >(type_);
}
inline void MissionTrack::set_type(::MissionTrack_Type value) {
  GOOGLE_DCHECK(::MissionTrack_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated int32 arg = 2;
inline int MissionTrack::arg_size() const {
  return arg_.size();
}
inline void MissionTrack::clear_arg() {
  arg_.Clear();
}
inline ::google::protobuf::int32 MissionTrack::arg(int index) const {
  return arg_.Get(index);
}
inline void MissionTrack::set_arg(int index, ::google::protobuf::int32 value) {
  arg_.Set(index, value);
}
inline void MissionTrack::add_arg(::google::protobuf::int32 value) {
  arg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MissionTrack::arg() const {
  return arg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MissionTrack::mutable_arg() {
  return &arg_;
}

// -------------------------------------------------------------------

// MissionInfo

// optional .MissionInfo.Type type = 1;
inline bool MissionInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MissionInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MissionInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MissionInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::MissionInfo_Type MissionInfo::type() const {
  return static_cast< ::MissionInfo_Type >(type_);
}
inline void MissionInfo::set_type(::MissionInfo_Type value) {
  GOOGLE_DCHECK(::MissionInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 id = 2;
inline bool MissionInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MissionInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MissionInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MissionInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MissionInfo::id() const {
  return id_;
}
inline void MissionInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 3;
inline bool MissionInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MissionInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MissionInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MissionInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MissionInfo::name() const {
  return *name_;
}
inline void MissionInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MissionInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MissionInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MissionInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string desc = 4;
inline bool MissionInfo::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MissionInfo::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MissionInfo::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MissionInfo::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& MissionInfo::desc() const {
  return *desc_;
}
inline void MissionInfo::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void MissionInfo::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void MissionInfo::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionInfo::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* MissionInfo::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string inContent = 5;
inline bool MissionInfo::has_inContent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MissionInfo::set_has_inContent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MissionInfo::clear_has_inContent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MissionInfo::clear_inContent() {
  if (inContent_ != &::google::protobuf::internal::kEmptyString) {
    inContent_->clear();
  }
  clear_has_inContent();
}
inline const ::std::string& MissionInfo::inContent() const {
  return *inContent_;
}
inline void MissionInfo::set_inContent(const ::std::string& value) {
  set_has_inContent();
  if (inContent_ == &::google::protobuf::internal::kEmptyString) {
    inContent_ = new ::std::string;
  }
  inContent_->assign(value);
}
inline void MissionInfo::set_inContent(const char* value) {
  set_has_inContent();
  if (inContent_ == &::google::protobuf::internal::kEmptyString) {
    inContent_ = new ::std::string;
  }
  inContent_->assign(value);
}
inline void MissionInfo::set_inContent(const char* value, size_t size) {
  set_has_inContent();
  if (inContent_ == &::google::protobuf::internal::kEmptyString) {
    inContent_ = new ::std::string;
  }
  inContent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionInfo::mutable_inContent() {
  set_has_inContent();
  if (inContent_ == &::google::protobuf::internal::kEmptyString) {
    inContent_ = new ::std::string;
  }
  return inContent_;
}
inline ::std::string* MissionInfo::release_inContent() {
  clear_has_inContent();
  if (inContent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inContent_;
    inContent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .MissionOpen open = 6;
inline bool MissionInfo::has_open() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MissionInfo::set_has_open() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MissionInfo::clear_has_open() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MissionInfo::clear_open() {
  if (open_ != NULL) open_->::MissionOpen::Clear();
  clear_has_open();
}
inline const ::MissionOpen& MissionInfo::open() const {
  return open_ != NULL ? *open_ : *default_instance_->open_;
}
inline ::MissionOpen* MissionInfo::mutable_open() {
  set_has_open();
  if (open_ == NULL) open_ = new ::MissionOpen;
  return open_;
}
inline ::MissionOpen* MissionInfo::release_open() {
  clear_has_open();
  ::MissionOpen* temp = open_;
  open_ = NULL;
  return temp;
}

// optional .MissionTarget target = 7;
inline bool MissionInfo::has_target() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MissionInfo::set_has_target() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MissionInfo::clear_has_target() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MissionInfo::clear_target() {
  if (target_ != NULL) target_->::MissionTarget::Clear();
  clear_has_target();
}
inline const ::MissionTarget& MissionInfo::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::MissionTarget* MissionInfo::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::MissionTarget;
  return target_;
}
inline ::MissionTarget* MissionInfo::release_target() {
  clear_has_target();
  ::MissionTarget* temp = target_;
  target_ = NULL;
  return temp;
}

// optional .MissionAward award = 8;
inline bool MissionInfo::has_award() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MissionInfo::set_has_award() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MissionInfo::clear_has_award() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MissionInfo::clear_award() {
  if (award_ != NULL) award_->::MissionAward::Clear();
  clear_has_award();
}
inline const ::MissionAward& MissionInfo::award() const {
  return award_ != NULL ? *award_ : *default_instance_->award_;
}
inline ::MissionAward* MissionInfo::mutable_award() {
  set_has_award();
  if (award_ == NULL) award_ = new ::MissionAward;
  return award_;
}
inline ::MissionAward* MissionInfo::release_award() {
  clear_has_award();
  ::MissionAward* temp = award_;
  award_ = NULL;
  return temp;
}

// optional int32 next = 9;
inline bool MissionInfo::has_next() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MissionInfo::set_has_next() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MissionInfo::clear_has_next() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MissionInfo::clear_next() {
  next_ = 0;
  clear_has_next();
}
inline ::google::protobuf::int32 MissionInfo::next() const {
  return next_;
}
inline void MissionInfo::set_next(::google::protobuf::int32 value) {
  set_has_next();
  next_ = value;
}

// optional int32 maxCount = 10;
inline bool MissionInfo::has_maxCount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MissionInfo::set_has_maxCount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MissionInfo::clear_has_maxCount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MissionInfo::clear_maxCount() {
  maxCount_ = 0;
  clear_has_maxCount();
}
inline ::google::protobuf::int32 MissionInfo::maxCount() const {
  return maxCount_;
}
inline void MissionInfo::set_maxCount(::google::protobuf::int32 value) {
  set_has_maxCount();
  maxCount_ = value;
}

// optional int32 groupID = 11;
inline bool MissionInfo::has_groupID() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MissionInfo::set_has_groupID() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MissionInfo::clear_has_groupID() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MissionInfo::clear_groupID() {
  groupID_ = 0;
  clear_has_groupID();
}
inline ::google::protobuf::int32 MissionInfo::groupID() const {
  return groupID_;
}
inline void MissionInfo::set_groupID(::google::protobuf::int32 value) {
  set_has_groupID();
  groupID_ = value;
}

// optional .MissionPort in = 12;
inline bool MissionInfo::has_in() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MissionInfo::set_has_in() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MissionInfo::clear_has_in() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MissionInfo::clear_in() {
  if (in_ != NULL) in_->::MissionPort::Clear();
  clear_has_in();
}
inline const ::MissionPort& MissionInfo::in() const {
  return in_ != NULL ? *in_ : *default_instance_->in_;
}
inline ::MissionPort* MissionInfo::mutable_in() {
  set_has_in();
  if (in_ == NULL) in_ = new ::MissionPort;
  return in_;
}
inline ::MissionPort* MissionInfo::release_in() {
  clear_has_in();
  ::MissionPort* temp = in_;
  in_ = NULL;
  return temp;
}

// optional .MissionPort out = 13;
inline bool MissionInfo::has_out() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MissionInfo::set_has_out() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MissionInfo::clear_has_out() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MissionInfo::clear_out() {
  if (out_ != NULL) out_->::MissionPort::Clear();
  clear_has_out();
}
inline const ::MissionPort& MissionInfo::out() const {
  return out_ != NULL ? *out_ : *default_instance_->out_;
}
inline ::MissionPort* MissionInfo::mutable_out() {
  set_has_out();
  if (out_ == NULL) out_ = new ::MissionPort;
  return out_;
}
inline ::MissionPort* MissionInfo::release_out() {
  clear_has_out();
  ::MissionPort* temp = out_;
  out_ = NULL;
  return temp;
}

// optional string completeDesc = 14;
inline bool MissionInfo::has_completeDesc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MissionInfo::set_has_completeDesc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MissionInfo::clear_has_completeDesc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MissionInfo::clear_completeDesc() {
  if (completeDesc_ != &::google::protobuf::internal::kEmptyString) {
    completeDesc_->clear();
  }
  clear_has_completeDesc();
}
inline const ::std::string& MissionInfo::completeDesc() const {
  return *completeDesc_;
}
inline void MissionInfo::set_completeDesc(const ::std::string& value) {
  set_has_completeDesc();
  if (completeDesc_ == &::google::protobuf::internal::kEmptyString) {
    completeDesc_ = new ::std::string;
  }
  completeDesc_->assign(value);
}
inline void MissionInfo::set_completeDesc(const char* value) {
  set_has_completeDesc();
  if (completeDesc_ == &::google::protobuf::internal::kEmptyString) {
    completeDesc_ = new ::std::string;
  }
  completeDesc_->assign(value);
}
inline void MissionInfo::set_completeDesc(const char* value, size_t size) {
  set_has_completeDesc();
  if (completeDesc_ == &::google::protobuf::internal::kEmptyString) {
    completeDesc_ = new ::std::string;
  }
  completeDesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionInfo::mutable_completeDesc() {
  set_has_completeDesc();
  if (completeDesc_ == &::google::protobuf::internal::kEmptyString) {
    completeDesc_ = new ::std::string;
  }
  return completeDesc_;
}
inline ::std::string* MissionInfo::release_completeDesc() {
  clear_has_completeDesc();
  if (completeDesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = completeDesc_;
    completeDesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string outContent = 15;
inline bool MissionInfo::has_outContent() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MissionInfo::set_has_outContent() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MissionInfo::clear_has_outContent() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MissionInfo::clear_outContent() {
  if (outContent_ != &::google::protobuf::internal::kEmptyString) {
    outContent_->clear();
  }
  clear_has_outContent();
}
inline const ::std::string& MissionInfo::outContent() const {
  return *outContent_;
}
inline void MissionInfo::set_outContent(const ::std::string& value) {
  set_has_outContent();
  if (outContent_ == &::google::protobuf::internal::kEmptyString) {
    outContent_ = new ::std::string;
  }
  outContent_->assign(value);
}
inline void MissionInfo::set_outContent(const char* value) {
  set_has_outContent();
  if (outContent_ == &::google::protobuf::internal::kEmptyString) {
    outContent_ = new ::std::string;
  }
  outContent_->assign(value);
}
inline void MissionInfo::set_outContent(const char* value, size_t size) {
  set_has_outContent();
  if (outContent_ == &::google::protobuf::internal::kEmptyString) {
    outContent_ = new ::std::string;
  }
  outContent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionInfo::mutable_outContent() {
  set_has_outContent();
  if (outContent_ == &::google::protobuf::internal::kEmptyString) {
    outContent_ = new ::std::string;
  }
  return outContent_;
}
inline ::std::string* MissionInfo::release_outContent() {
  clear_has_outContent();
  if (outContent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outContent_;
    outContent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .MissionTrack targetTrack = 16;
inline bool MissionInfo::has_targetTrack() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MissionInfo::set_has_targetTrack() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MissionInfo::clear_has_targetTrack() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MissionInfo::clear_targetTrack() {
  if (targetTrack_ != NULL) targetTrack_->::MissionTrack::Clear();
  clear_has_targetTrack();
}
inline const ::MissionTrack& MissionInfo::targetTrack() const {
  return targetTrack_ != NULL ? *targetTrack_ : *default_instance_->targetTrack_;
}
inline ::MissionTrack* MissionInfo::mutable_targetTrack() {
  set_has_targetTrack();
  if (targetTrack_ == NULL) targetTrack_ = new ::MissionTrack;
  return targetTrack_;
}
inline ::MissionTrack* MissionInfo::release_targetTrack() {
  clear_has_targetTrack();
  ::MissionTrack* temp = targetTrack_;
  targetTrack_ = NULL;
  return temp;
}

// optional .MissionTrack outTrack = 17;
inline bool MissionInfo::has_outTrack() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MissionInfo::set_has_outTrack() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MissionInfo::clear_has_outTrack() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MissionInfo::clear_outTrack() {
  if (outTrack_ != NULL) outTrack_->::MissionTrack::Clear();
  clear_has_outTrack();
}
inline const ::MissionTrack& MissionInfo::outTrack() const {
  return outTrack_ != NULL ? *outTrack_ : *default_instance_->outTrack_;
}
inline ::MissionTrack* MissionInfo::mutable_outTrack() {
  set_has_outTrack();
  if (outTrack_ == NULL) outTrack_ = new ::MissionTrack;
  return outTrack_;
}
inline ::MissionTrack* MissionInfo::release_outTrack() {
  clear_has_outTrack();
  ::MissionTrack* temp = outTrack_;
  outTrack_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AllMissions

// repeated .MissionInfo missions = 1;
inline int AllMissions::missions_size() const {
  return missions_.size();
}
inline void AllMissions::clear_missions() {
  missions_.Clear();
}
inline const ::MissionInfo& AllMissions::missions(int index) const {
  return missions_.Get(index);
}
inline ::MissionInfo* AllMissions::mutable_missions(int index) {
  return missions_.Mutable(index);
}
inline ::MissionInfo* AllMissions::add_missions() {
  return missions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MissionInfo >&
AllMissions::missions() const {
  return missions_;
}
inline ::google::protobuf::RepeatedPtrField< ::MissionInfo >*
AllMissions::mutable_missions() {
  return &missions_;
}

// -------------------------------------------------------------------

// PB_MissionTargetRecord

// repeated int32 arg = 1;
inline int PB_MissionTargetRecord::arg_size() const {
  return arg_.size();
}
inline void PB_MissionTargetRecord::clear_arg() {
  arg_.Clear();
}
inline ::google::protobuf::int32 PB_MissionTargetRecord::arg(int index) const {
  return arg_.Get(index);
}
inline void PB_MissionTargetRecord::set_arg(int index, ::google::protobuf::int32 value) {
  arg_.Set(index, value);
}
inline void PB_MissionTargetRecord::add_arg(::google::protobuf::int32 value) {
  arg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PB_MissionTargetRecord::arg() const {
  return arg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PB_MissionTargetRecord::mutable_arg() {
  return &arg_;
}

// -------------------------------------------------------------------

// PB_MissionRecord

// optional int32 count = 1;
inline bool PB_MissionRecord::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PB_MissionRecord::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PB_MissionRecord::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PB_MissionRecord::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 PB_MissionRecord::count() const {
  return count_;
}
inline void PB_MissionRecord::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// repeated .PB_MissionTargetRecord target = 2;
inline int PB_MissionRecord::target_size() const {
  return target_.size();
}
inline void PB_MissionRecord::clear_target() {
  target_.Clear();
}
inline const ::PB_MissionTargetRecord& PB_MissionRecord::target(int index) const {
  return target_.Get(index);
}
inline ::PB_MissionTargetRecord* PB_MissionRecord::mutable_target(int index) {
  return target_.Mutable(index);
}
inline ::PB_MissionTargetRecord* PB_MissionRecord::add_target() {
  return target_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PB_MissionTargetRecord >&
PB_MissionRecord::target() const {
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::PB_MissionTargetRecord >*
PB_MissionRecord::mutable_target() {
  return &target_;
}

// -------------------------------------------------------------------

// PB_MissionAllRecord

// repeated .PB_MissionRecord records = 1;
inline int PB_MissionAllRecord::records_size() const {
  return records_.size();
}
inline void PB_MissionAllRecord::clear_records() {
  records_.Clear();
}
inline const ::PB_MissionRecord& PB_MissionAllRecord::records(int index) const {
  return records_.Get(index);
}
inline ::PB_MissionRecord* PB_MissionAllRecord::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::PB_MissionRecord* PB_MissionAllRecord::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PB_MissionRecord >&
PB_MissionAllRecord::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::PB_MissionRecord >*
PB_MissionAllRecord::mutable_records() {
  return &records_;
}

// repeated int32 cur = 2;
inline int PB_MissionAllRecord::cur_size() const {
  return cur_.size();
}
inline void PB_MissionAllRecord::clear_cur() {
  cur_.Clear();
}
inline ::google::protobuf::int32 PB_MissionAllRecord::cur(int index) const {
  return cur_.Get(index);
}
inline void PB_MissionAllRecord::set_cur(int index, ::google::protobuf::int32 value) {
  cur_.Set(index, value);
}
inline void PB_MissionAllRecord::add_cur(::google::protobuf::int32 value) {
  cur_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PB_MissionAllRecord::cur() const {
  return cur_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PB_MissionAllRecord::mutable_cur() {
  return &cur_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MissionOpen_Type>() {
  return ::MissionOpen_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MissionTarget_Type>() {
  return ::MissionTarget_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MissionAward_Type>() {
  return ::MissionAward_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MissionPort_Type>() {
  return ::MissionPort_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MissionTrack_Type>() {
  return ::MissionTrack_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MissionInfo_Type>() {
  return ::MissionInfo_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MissionInfo_2eproto__INCLUDED
