// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BloodInfo.proto

#ifndef PROTOBUF_BloodInfo_2eproto__INCLUDED
#define PROTOBUF_BloodInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BloodInfo_2eproto();
void protobuf_AssignDesc_BloodInfo_2eproto();
void protobuf_ShutdownFile_BloodInfo_2eproto();

class BloodInfo;
class AllBloodInfo;
class BloodNodeInfo;
class AllBloodNodeInfo;
class ExploreInfo;
class AllExploreInfo;

enum BloodNodeInfo_Type {
  BloodNodeInfo_Type_ATT = 0,
  BloodNodeInfo_Type_SKILL_CD = 1,
  BloodNodeInfo_Type_AREA = 2,
  BloodNodeInfo_Type_INC_MANA = 3,
  BloodNodeInfo_Type_INC_ENERGY = 4,
  BloodNodeInfo_Type_DEC_MANA = 5,
  BloodNodeInfo_Type_TRANSFORM_TIME = 6
};
bool BloodNodeInfo_Type_IsValid(int value);
const BloodNodeInfo_Type BloodNodeInfo_Type_Type_MIN = BloodNodeInfo_Type_ATT;
const BloodNodeInfo_Type BloodNodeInfo_Type_Type_MAX = BloodNodeInfo_Type_TRANSFORM_TIME;
const int BloodNodeInfo_Type_Type_ARRAYSIZE = BloodNodeInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* BloodNodeInfo_Type_descriptor();
inline const ::std::string& BloodNodeInfo_Type_Name(BloodNodeInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    BloodNodeInfo_Type_descriptor(), value);
}
inline bool BloodNodeInfo_Type_Parse(
    const ::std::string& name, BloodNodeInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BloodNodeInfo_Type>(
    BloodNodeInfo_Type_descriptor(), name, value);
}
enum ExploreInfo_Type {
  ExploreInfo_Type_NORMAL = 0,
  ExploreInfo_Type_HIGH = 1
};
bool ExploreInfo_Type_IsValid(int value);
const ExploreInfo_Type ExploreInfo_Type_Type_MIN = ExploreInfo_Type_NORMAL;
const ExploreInfo_Type ExploreInfo_Type_Type_MAX = ExploreInfo_Type_HIGH;
const int ExploreInfo_Type_Type_ARRAYSIZE = ExploreInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExploreInfo_Type_descriptor();
inline const ::std::string& ExploreInfo_Type_Name(ExploreInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExploreInfo_Type_descriptor(), value);
}
inline bool ExploreInfo_Type_Parse(
    const ::std::string& name, ExploreInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExploreInfo_Type>(
    ExploreInfo_Type_descriptor(), name, value);
}
enum ExploreInfo_SoulJadeType {
  ExploreInfo_SoulJadeType_NONE = 0,
  ExploreInfo_SoulJadeType_SMALL = 1,
  ExploreInfo_SoulJadeType_MEDIUM = 2,
  ExploreInfo_SoulJadeType_BIG = 3,
  ExploreInfo_SoulJadeType_PERFECT = 4
};
bool ExploreInfo_SoulJadeType_IsValid(int value);
const ExploreInfo_SoulJadeType ExploreInfo_SoulJadeType_SoulJadeType_MIN = ExploreInfo_SoulJadeType_NONE;
const ExploreInfo_SoulJadeType ExploreInfo_SoulJadeType_SoulJadeType_MAX = ExploreInfo_SoulJadeType_PERFECT;
const int ExploreInfo_SoulJadeType_SoulJadeType_ARRAYSIZE = ExploreInfo_SoulJadeType_SoulJadeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExploreInfo_SoulJadeType_descriptor();
inline const ::std::string& ExploreInfo_SoulJadeType_Name(ExploreInfo_SoulJadeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExploreInfo_SoulJadeType_descriptor(), value);
}
inline bool ExploreInfo_SoulJadeType_Parse(
    const ::std::string& name, ExploreInfo_SoulJadeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExploreInfo_SoulJadeType>(
    ExploreInfo_SoulJadeType_descriptor(), name, value);
}
// ===================================================================

class BloodInfo : public ::google::protobuf::Message {
 public:
  BloodInfo();
  virtual ~BloodInfo();
  
  BloodInfo(const BloodInfo& from);
  
  inline BloodInfo& operator=(const BloodInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BloodInfo& default_instance();
  
  void Swap(BloodInfo* other);
  
  // implements Message ----------------------------------------------
  
  BloodInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BloodInfo& from);
  void MergeFrom(const BloodInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int32 pic = 3;
  inline bool has_pic() const;
  inline void clear_pic();
  static const int kPicFieldNumber = 3;
  inline ::google::protobuf::int32 pic() const;
  inline void set_pic(::google::protobuf::int32 value);
  
  // optional int32 requiredLevel = 4;
  inline bool has_requiredLevel() const;
  inline void clear_requiredLevel();
  static const int kRequiredLevelFieldNumber = 4;
  inline ::google::protobuf::int32 requiredLevel() const;
  inline void set_requiredLevel(::google::protobuf::int32 value);
  
  // optional .ExploreInfo.SoulJadeType soulJadeType = 5;
  inline bool has_soulJadeType() const;
  inline void clear_soulJadeType();
  static const int kSoulJadeTypeFieldNumber = 5;
  inline ::ExploreInfo_SoulJadeType soulJadeType() const;
  inline void set_soulJadeType(::ExploreInfo_SoulJadeType value);
  
  // optional int32 soulJadeCount = 6;
  inline bool has_soulJadeCount() const;
  inline void clear_soulJadeCount();
  static const int kSoulJadeCountFieldNumber = 6;
  inline ::google::protobuf::int32 soulJadeCount() const;
  inline void set_soulJadeCount(::google::protobuf::int32 value);
  
  // optional int32 limit = 7;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 7;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);
  
  // optional int32 toAtk = 8;
  inline bool has_toAtk() const;
  inline void clear_toAtk();
  static const int kToAtkFieldNumber = 8;
  inline ::google::protobuf::int32 toAtk() const;
  inline void set_toAtk(::google::protobuf::int32 value);
  
  // optional int32 toDef = 9;
  inline bool has_toDef() const;
  inline void clear_toDef();
  static const int kToDefFieldNumber = 9;
  inline ::google::protobuf::int32 toDef() const;
  inline void set_toDef(::google::protobuf::int32 value);
  
  // optional int32 toDodge = 10;
  inline bool has_toDodge() const;
  inline void clear_toDodge();
  static const int kToDodgeFieldNumber = 10;
  inline ::google::protobuf::int32 toDodge() const;
  inline void set_toDodge(::google::protobuf::int32 value);
  
  // optional int32 toAccuracy = 11;
  inline bool has_toAccuracy() const;
  inline void clear_toAccuracy();
  static const int kToAccuracyFieldNumber = 11;
  inline ::google::protobuf::int32 toAccuracy() const;
  inline void set_toAccuracy(::google::protobuf::int32 value);
  
  // optional int32 requiredMoney = 12;
  inline bool has_requiredMoney() const;
  inline void clear_requiredMoney();
  static const int kRequiredMoneyFieldNumber = 12;
  inline ::google::protobuf::int32 requiredMoney() const;
  inline void set_requiredMoney(::google::protobuf::int32 value);
  
  // optional int32 requiredGem = 13;
  inline bool has_requiredGem() const;
  inline void clear_requiredGem();
  static const int kRequiredGemFieldNumber = 13;
  inline ::google::protobuf::int32 requiredGem() const;
  inline void set_requiredGem(::google::protobuf::int32 value);
  
  // optional int32 lastNode = 14;
  inline bool has_lastNode() const;
  inline void clear_lastNode();
  static const int kLastNodeFieldNumber = 14;
  inline ::google::protobuf::int32 lastNode() const;
  inline void set_lastNode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:BloodInfo)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pic();
  inline void clear_has_pic();
  inline void set_has_requiredLevel();
  inline void clear_has_requiredLevel();
  inline void set_has_soulJadeType();
  inline void clear_has_soulJadeType();
  inline void set_has_soulJadeCount();
  inline void clear_has_soulJadeCount();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_toAtk();
  inline void clear_has_toAtk();
  inline void set_has_toDef();
  inline void clear_has_toDef();
  inline void set_has_toDodge();
  inline void clear_has_toDodge();
  inline void set_has_toAccuracy();
  inline void clear_has_toAccuracy();
  inline void set_has_requiredMoney();
  inline void clear_has_requiredMoney();
  inline void set_has_requiredGem();
  inline void clear_has_requiredGem();
  inline void set_has_lastNode();
  inline void clear_has_lastNode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 pic_;
  ::google::protobuf::int32 requiredLevel_;
  int soulJadeType_;
  ::google::protobuf::int32 soulJadeCount_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 toAtk_;
  ::google::protobuf::int32 toDef_;
  ::google::protobuf::int32 toDodge_;
  ::google::protobuf::int32 toAccuracy_;
  ::google::protobuf::int32 requiredMoney_;
  ::google::protobuf::int32 requiredGem_;
  ::google::protobuf::int32 lastNode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloodInfo_2eproto();
  friend void protobuf_AssignDesc_BloodInfo_2eproto();
  friend void protobuf_ShutdownFile_BloodInfo_2eproto();
  
  void InitAsDefaultInstance();
  static BloodInfo* default_instance_;
};
// -------------------------------------------------------------------

class AllBloodInfo : public ::google::protobuf::Message {
 public:
  AllBloodInfo();
  virtual ~AllBloodInfo();
  
  AllBloodInfo(const AllBloodInfo& from);
  
  inline AllBloodInfo& operator=(const AllBloodInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllBloodInfo& default_instance();
  
  void Swap(AllBloodInfo* other);
  
  // implements Message ----------------------------------------------
  
  AllBloodInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllBloodInfo& from);
  void MergeFrom(const AllBloodInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .BloodInfo bloodInfo = 1;
  inline int bloodInfo_size() const;
  inline void clear_bloodInfo();
  static const int kBloodInfoFieldNumber = 1;
  inline const ::BloodInfo& bloodInfo(int index) const;
  inline ::BloodInfo* mutable_bloodInfo(int index);
  inline ::BloodInfo* add_bloodInfo();
  inline const ::google::protobuf::RepeatedPtrField< ::BloodInfo >&
      bloodInfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::BloodInfo >*
      mutable_bloodInfo();
  
  // @@protoc_insertion_point(class_scope:AllBloodInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BloodInfo > bloodInfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloodInfo_2eproto();
  friend void protobuf_AssignDesc_BloodInfo_2eproto();
  friend void protobuf_ShutdownFile_BloodInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AllBloodInfo* default_instance_;
};
// -------------------------------------------------------------------

class BloodNodeInfo : public ::google::protobuf::Message {
 public:
  BloodNodeInfo();
  virtual ~BloodNodeInfo();
  
  BloodNodeInfo(const BloodNodeInfo& from);
  
  inline BloodNodeInfo& operator=(const BloodNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BloodNodeInfo& default_instance();
  
  void Swap(BloodNodeInfo* other);
  
  // implements Message ----------------------------------------------
  
  BloodNodeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BloodNodeInfo& from);
  void MergeFrom(const BloodNodeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef BloodNodeInfo_Type Type;
  static const Type ATT = BloodNodeInfo_Type_ATT;
  static const Type SKILL_CD = BloodNodeInfo_Type_SKILL_CD;
  static const Type AREA = BloodNodeInfo_Type_AREA;
  static const Type INC_MANA = BloodNodeInfo_Type_INC_MANA;
  static const Type INC_ENERGY = BloodNodeInfo_Type_INC_ENERGY;
  static const Type DEC_MANA = BloodNodeInfo_Type_DEC_MANA;
  static const Type TRANSFORM_TIME = BloodNodeInfo_Type_TRANSFORM_TIME;
  static inline bool Type_IsValid(int value) {
    return BloodNodeInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    BloodNodeInfo_Type_Type_MIN;
  static const Type Type_MAX =
    BloodNodeInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    BloodNodeInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return BloodNodeInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return BloodNodeInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return BloodNodeInfo_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int64 requiredSoul = 3;
  inline bool has_requiredSoul() const;
  inline void clear_requiredSoul();
  static const int kRequiredSoulFieldNumber = 3;
  inline ::google::protobuf::int64 requiredSoul() const;
  inline void set_requiredSoul(::google::protobuf::int64 value);
  
  // optional int64 requiredGem = 4;
  inline bool has_requiredGem() const;
  inline void clear_requiredGem();
  static const int kRequiredGemFieldNumber = 4;
  inline ::google::protobuf::int64 requiredGem() const;
  inline void set_requiredGem(::google::protobuf::int64 value);
  
  // optional float successRate = 5;
  inline bool has_successRate() const;
  inline void clear_successRate();
  static const int kSuccessRateFieldNumber = 5;
  inline float successRate() const;
  inline void set_successRate(float value);
  
  // repeated .BloodNodeInfo.Type type = 6;
  inline int type_size() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::BloodNodeInfo_Type type(int index) const;
  inline void set_type(int index, ::BloodNodeInfo_Type value);
  inline void add_type(::BloodNodeInfo_Type value);
  inline const ::google::protobuf::RepeatedField<int>& type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_type();
  
  // repeated int32 arg1 = 7;
  inline int arg1_size() const;
  inline void clear_arg1();
  static const int kArg1FieldNumber = 7;
  inline ::google::protobuf::int32 arg1(int index) const;
  inline void set_arg1(int index, ::google::protobuf::int32 value);
  inline void add_arg1(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      arg1() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_arg1();
  
  // repeated int32 arg2 = 8;
  inline int arg2_size() const;
  inline void clear_arg2();
  static const int kArg2FieldNumber = 8;
  inline ::google::protobuf::int32 arg2(int index) const;
  inline void set_arg2(int index, ::google::protobuf::int32 value);
  inline void add_arg2(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      arg2() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_arg2();
  
  // optional int32 goods = 9;
  inline bool has_goods() const;
  inline void clear_goods();
  static const int kGoodsFieldNumber = 9;
  inline ::google::protobuf::int32 goods() const;
  inline void set_goods(::google::protobuf::int32 value);
  
  // optional int32 count = 10;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 10;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:BloodNodeInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_requiredSoul();
  inline void clear_has_requiredSoul();
  inline void set_has_requiredGem();
  inline void clear_has_requiredGem();
  inline void set_has_successRate();
  inline void clear_has_successRate();
  inline void set_has_goods();
  inline void clear_has_goods();
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int64 requiredSoul_;
  ::google::protobuf::int32 id_;
  float successRate_;
  ::google::protobuf::int64 requiredGem_;
  ::google::protobuf::RepeatedField<int> type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > arg1_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > arg2_;
  ::google::protobuf::int32 goods_;
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloodInfo_2eproto();
  friend void protobuf_AssignDesc_BloodInfo_2eproto();
  friend void protobuf_ShutdownFile_BloodInfo_2eproto();
  
  void InitAsDefaultInstance();
  static BloodNodeInfo* default_instance_;
};
// -------------------------------------------------------------------

class AllBloodNodeInfo : public ::google::protobuf::Message {
 public:
  AllBloodNodeInfo();
  virtual ~AllBloodNodeInfo();
  
  AllBloodNodeInfo(const AllBloodNodeInfo& from);
  
  inline AllBloodNodeInfo& operator=(const AllBloodNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllBloodNodeInfo& default_instance();
  
  void Swap(AllBloodNodeInfo* other);
  
  // implements Message ----------------------------------------------
  
  AllBloodNodeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllBloodNodeInfo& from);
  void MergeFrom(const AllBloodNodeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .BloodNodeInfo bloodNodeInfo = 1;
  inline int bloodNodeInfo_size() const;
  inline void clear_bloodNodeInfo();
  static const int kBloodNodeInfoFieldNumber = 1;
  inline const ::BloodNodeInfo& bloodNodeInfo(int index) const;
  inline ::BloodNodeInfo* mutable_bloodNodeInfo(int index);
  inline ::BloodNodeInfo* add_bloodNodeInfo();
  inline const ::google::protobuf::RepeatedPtrField< ::BloodNodeInfo >&
      bloodNodeInfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::BloodNodeInfo >*
      mutable_bloodNodeInfo();
  
  // @@protoc_insertion_point(class_scope:AllBloodNodeInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BloodNodeInfo > bloodNodeInfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloodInfo_2eproto();
  friend void protobuf_AssignDesc_BloodInfo_2eproto();
  friend void protobuf_ShutdownFile_BloodInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AllBloodNodeInfo* default_instance_;
};
// -------------------------------------------------------------------

class ExploreInfo : public ::google::protobuf::Message {
 public:
  ExploreInfo();
  virtual ~ExploreInfo();
  
  ExploreInfo(const ExploreInfo& from);
  
  inline ExploreInfo& operator=(const ExploreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExploreInfo& default_instance();
  
  void Swap(ExploreInfo* other);
  
  // implements Message ----------------------------------------------
  
  ExploreInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExploreInfo& from);
  void MergeFrom(const ExploreInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ExploreInfo_Type Type;
  static const Type NORMAL = ExploreInfo_Type_NORMAL;
  static const Type HIGH = ExploreInfo_Type_HIGH;
  static inline bool Type_IsValid(int value) {
    return ExploreInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ExploreInfo_Type_Type_MIN;
  static const Type Type_MAX =
    ExploreInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ExploreInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ExploreInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ExploreInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ExploreInfo_Type_Parse(name, value);
  }
  
  typedef ExploreInfo_SoulJadeType SoulJadeType;
  static const SoulJadeType NONE = ExploreInfo_SoulJadeType_NONE;
  static const SoulJadeType SMALL = ExploreInfo_SoulJadeType_SMALL;
  static const SoulJadeType MEDIUM = ExploreInfo_SoulJadeType_MEDIUM;
  static const SoulJadeType BIG = ExploreInfo_SoulJadeType_BIG;
  static const SoulJadeType PERFECT = ExploreInfo_SoulJadeType_PERFECT;
  static inline bool SoulJadeType_IsValid(int value) {
    return ExploreInfo_SoulJadeType_IsValid(value);
  }
  static const SoulJadeType SoulJadeType_MIN =
    ExploreInfo_SoulJadeType_SoulJadeType_MIN;
  static const SoulJadeType SoulJadeType_MAX =
    ExploreInfo_SoulJadeType_SoulJadeType_MAX;
  static const int SoulJadeType_ARRAYSIZE =
    ExploreInfo_SoulJadeType_SoulJadeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SoulJadeType_descriptor() {
    return ExploreInfo_SoulJadeType_descriptor();
  }
  static inline const ::std::string& SoulJadeType_Name(SoulJadeType value) {
    return ExploreInfo_SoulJadeType_Name(value);
  }
  static inline bool SoulJadeType_Parse(const ::std::string& name,
      SoulJadeType* value) {
    return ExploreInfo_SoulJadeType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .ExploreInfo.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::ExploreInfo_Type type() const;
  inline void set_type(::ExploreInfo_Type value);
  
  // optional string desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // optional .ExploreInfo.SoulJadeType soulJadeType = 4;
  inline bool has_soulJadeType() const;
  inline void clear_soulJadeType();
  static const int kSoulJadeTypeFieldNumber = 4;
  inline ::ExploreInfo_SoulJadeType soulJadeType() const;
  inline void set_soulJadeType(::ExploreInfo_SoulJadeType value);
  
  // optional int32 soulJadeCount = 5;
  inline bool has_soulJadeCount() const;
  inline void clear_soulJadeCount();
  static const int kSoulJadeCountFieldNumber = 5;
  inline ::google::protobuf::int32 soulJadeCount() const;
  inline void set_soulJadeCount(::google::protobuf::int32 value);
  
  // optional int32 soul = 6;
  inline bool has_soul() const;
  inline void clear_soul();
  static const int kSoulFieldNumber = 6;
  inline ::google::protobuf::int32 soul() const;
  inline void set_soul(::google::protobuf::int32 value);
  
  // optional int32 rate = 7;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 7;
  inline ::google::protobuf::int32 rate() const;
  inline void set_rate(::google::protobuf::int32 value);
  
  // optional int32 soulStone = 8;
  inline bool has_soulStone() const;
  inline void clear_soulStone();
  static const int kSoulStoneFieldNumber = 8;
  inline ::google::protobuf::int32 soulStone() const;
  inline void set_soulStone(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ExploreInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_soulJadeType();
  inline void clear_has_soulJadeType();
  inline void set_has_soulJadeCount();
  inline void clear_has_soulJadeCount();
  inline void set_has_soul();
  inline void clear_has_soul();
  inline void set_has_rate();
  inline void clear_has_rate();
  inline void set_has_soulStone();
  inline void clear_has_soulStone();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  int type_;
  ::std::string* desc_;
  int soulJadeType_;
  ::google::protobuf::int32 soulJadeCount_;
  ::google::protobuf::int32 soul_;
  ::google::protobuf::int32 rate_;
  ::google::protobuf::int32 soulStone_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloodInfo_2eproto();
  friend void protobuf_AssignDesc_BloodInfo_2eproto();
  friend void protobuf_ShutdownFile_BloodInfo_2eproto();
  
  void InitAsDefaultInstance();
  static ExploreInfo* default_instance_;
};
// -------------------------------------------------------------------

class AllExploreInfo : public ::google::protobuf::Message {
 public:
  AllExploreInfo();
  virtual ~AllExploreInfo();
  
  AllExploreInfo(const AllExploreInfo& from);
  
  inline AllExploreInfo& operator=(const AllExploreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllExploreInfo& default_instance();
  
  void Swap(AllExploreInfo* other);
  
  // implements Message ----------------------------------------------
  
  AllExploreInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllExploreInfo& from);
  void MergeFrom(const AllExploreInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ExploreInfo exploreInfo = 1;
  inline int exploreInfo_size() const;
  inline void clear_exploreInfo();
  static const int kExploreInfoFieldNumber = 1;
  inline const ::ExploreInfo& exploreInfo(int index) const;
  inline ::ExploreInfo* mutable_exploreInfo(int index);
  inline ::ExploreInfo* add_exploreInfo();
  inline const ::google::protobuf::RepeatedPtrField< ::ExploreInfo >&
      exploreInfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::ExploreInfo >*
      mutable_exploreInfo();
  
  // @@protoc_insertion_point(class_scope:AllExploreInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ExploreInfo > exploreInfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_BloodInfo_2eproto();
  friend void protobuf_AssignDesc_BloodInfo_2eproto();
  friend void protobuf_ShutdownFile_BloodInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AllExploreInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// BloodInfo

// optional int32 level = 1;
inline bool BloodInfo::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BloodInfo::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BloodInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BloodInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 BloodInfo::level() const {
  return level_;
}
inline void BloodInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional string name = 2;
inline bool BloodInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BloodInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BloodInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BloodInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BloodInfo::name() const {
  return *name_;
}
inline void BloodInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BloodInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BloodInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BloodInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BloodInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 pic = 3;
inline bool BloodInfo::has_pic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BloodInfo::set_has_pic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BloodInfo::clear_has_pic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BloodInfo::clear_pic() {
  pic_ = 0;
  clear_has_pic();
}
inline ::google::protobuf::int32 BloodInfo::pic() const {
  return pic_;
}
inline void BloodInfo::set_pic(::google::protobuf::int32 value) {
  set_has_pic();
  pic_ = value;
}

// optional int32 requiredLevel = 4;
inline bool BloodInfo::has_requiredLevel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BloodInfo::set_has_requiredLevel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BloodInfo::clear_has_requiredLevel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BloodInfo::clear_requiredLevel() {
  requiredLevel_ = 0;
  clear_has_requiredLevel();
}
inline ::google::protobuf::int32 BloodInfo::requiredLevel() const {
  return requiredLevel_;
}
inline void BloodInfo::set_requiredLevel(::google::protobuf::int32 value) {
  set_has_requiredLevel();
  requiredLevel_ = value;
}

// optional .ExploreInfo.SoulJadeType soulJadeType = 5;
inline bool BloodInfo::has_soulJadeType() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BloodInfo::set_has_soulJadeType() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BloodInfo::clear_has_soulJadeType() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BloodInfo::clear_soulJadeType() {
  soulJadeType_ = 0;
  clear_has_soulJadeType();
}
inline ::ExploreInfo_SoulJadeType BloodInfo::soulJadeType() const {
  return static_cast< ::ExploreInfo_SoulJadeType >(soulJadeType_);
}
inline void BloodInfo::set_soulJadeType(::ExploreInfo_SoulJadeType value) {
  GOOGLE_DCHECK(::ExploreInfo_SoulJadeType_IsValid(value));
  set_has_soulJadeType();
  soulJadeType_ = value;
}

// optional int32 soulJadeCount = 6;
inline bool BloodInfo::has_soulJadeCount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BloodInfo::set_has_soulJadeCount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BloodInfo::clear_has_soulJadeCount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BloodInfo::clear_soulJadeCount() {
  soulJadeCount_ = 0;
  clear_has_soulJadeCount();
}
inline ::google::protobuf::int32 BloodInfo::soulJadeCount() const {
  return soulJadeCount_;
}
inline void BloodInfo::set_soulJadeCount(::google::protobuf::int32 value) {
  set_has_soulJadeCount();
  soulJadeCount_ = value;
}

// optional int32 limit = 7;
inline bool BloodInfo::has_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BloodInfo::set_has_limit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BloodInfo::clear_has_limit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BloodInfo::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 BloodInfo::limit() const {
  return limit_;
}
inline void BloodInfo::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 toAtk = 8;
inline bool BloodInfo::has_toAtk() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BloodInfo::set_has_toAtk() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BloodInfo::clear_has_toAtk() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BloodInfo::clear_toAtk() {
  toAtk_ = 0;
  clear_has_toAtk();
}
inline ::google::protobuf::int32 BloodInfo::toAtk() const {
  return toAtk_;
}
inline void BloodInfo::set_toAtk(::google::protobuf::int32 value) {
  set_has_toAtk();
  toAtk_ = value;
}

// optional int32 toDef = 9;
inline bool BloodInfo::has_toDef() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BloodInfo::set_has_toDef() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BloodInfo::clear_has_toDef() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BloodInfo::clear_toDef() {
  toDef_ = 0;
  clear_has_toDef();
}
inline ::google::protobuf::int32 BloodInfo::toDef() const {
  return toDef_;
}
inline void BloodInfo::set_toDef(::google::protobuf::int32 value) {
  set_has_toDef();
  toDef_ = value;
}

// optional int32 toDodge = 10;
inline bool BloodInfo::has_toDodge() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BloodInfo::set_has_toDodge() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BloodInfo::clear_has_toDodge() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BloodInfo::clear_toDodge() {
  toDodge_ = 0;
  clear_has_toDodge();
}
inline ::google::protobuf::int32 BloodInfo::toDodge() const {
  return toDodge_;
}
inline void BloodInfo::set_toDodge(::google::protobuf::int32 value) {
  set_has_toDodge();
  toDodge_ = value;
}

// optional int32 toAccuracy = 11;
inline bool BloodInfo::has_toAccuracy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BloodInfo::set_has_toAccuracy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BloodInfo::clear_has_toAccuracy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BloodInfo::clear_toAccuracy() {
  toAccuracy_ = 0;
  clear_has_toAccuracy();
}
inline ::google::protobuf::int32 BloodInfo::toAccuracy() const {
  return toAccuracy_;
}
inline void BloodInfo::set_toAccuracy(::google::protobuf::int32 value) {
  set_has_toAccuracy();
  toAccuracy_ = value;
}

// optional int32 requiredMoney = 12;
inline bool BloodInfo::has_requiredMoney() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BloodInfo::set_has_requiredMoney() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BloodInfo::clear_has_requiredMoney() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BloodInfo::clear_requiredMoney() {
  requiredMoney_ = 0;
  clear_has_requiredMoney();
}
inline ::google::protobuf::int32 BloodInfo::requiredMoney() const {
  return requiredMoney_;
}
inline void BloodInfo::set_requiredMoney(::google::protobuf::int32 value) {
  set_has_requiredMoney();
  requiredMoney_ = value;
}

// optional int32 requiredGem = 13;
inline bool BloodInfo::has_requiredGem() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BloodInfo::set_has_requiredGem() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BloodInfo::clear_has_requiredGem() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BloodInfo::clear_requiredGem() {
  requiredGem_ = 0;
  clear_has_requiredGem();
}
inline ::google::protobuf::int32 BloodInfo::requiredGem() const {
  return requiredGem_;
}
inline void BloodInfo::set_requiredGem(::google::protobuf::int32 value) {
  set_has_requiredGem();
  requiredGem_ = value;
}

// optional int32 lastNode = 14;
inline bool BloodInfo::has_lastNode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BloodInfo::set_has_lastNode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BloodInfo::clear_has_lastNode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BloodInfo::clear_lastNode() {
  lastNode_ = 0;
  clear_has_lastNode();
}
inline ::google::protobuf::int32 BloodInfo::lastNode() const {
  return lastNode_;
}
inline void BloodInfo::set_lastNode(::google::protobuf::int32 value) {
  set_has_lastNode();
  lastNode_ = value;
}

// -------------------------------------------------------------------

// AllBloodInfo

// repeated .BloodInfo bloodInfo = 1;
inline int AllBloodInfo::bloodInfo_size() const {
  return bloodInfo_.size();
}
inline void AllBloodInfo::clear_bloodInfo() {
  bloodInfo_.Clear();
}
inline const ::BloodInfo& AllBloodInfo::bloodInfo(int index) const {
  return bloodInfo_.Get(index);
}
inline ::BloodInfo* AllBloodInfo::mutable_bloodInfo(int index) {
  return bloodInfo_.Mutable(index);
}
inline ::BloodInfo* AllBloodInfo::add_bloodInfo() {
  return bloodInfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BloodInfo >&
AllBloodInfo::bloodInfo() const {
  return bloodInfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::BloodInfo >*
AllBloodInfo::mutable_bloodInfo() {
  return &bloodInfo_;
}

// -------------------------------------------------------------------

// BloodNodeInfo

// optional int32 id = 1;
inline bool BloodNodeInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BloodNodeInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BloodNodeInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BloodNodeInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BloodNodeInfo::id() const {
  return id_;
}
inline void BloodNodeInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool BloodNodeInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BloodNodeInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BloodNodeInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BloodNodeInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BloodNodeInfo::name() const {
  return *name_;
}
inline void BloodNodeInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BloodNodeInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BloodNodeInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BloodNodeInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BloodNodeInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 requiredSoul = 3;
inline bool BloodNodeInfo::has_requiredSoul() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BloodNodeInfo::set_has_requiredSoul() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BloodNodeInfo::clear_has_requiredSoul() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BloodNodeInfo::clear_requiredSoul() {
  requiredSoul_ = GOOGLE_LONGLONG(0);
  clear_has_requiredSoul();
}
inline ::google::protobuf::int64 BloodNodeInfo::requiredSoul() const {
  return requiredSoul_;
}
inline void BloodNodeInfo::set_requiredSoul(::google::protobuf::int64 value) {
  set_has_requiredSoul();
  requiredSoul_ = value;
}

// optional int64 requiredGem = 4;
inline bool BloodNodeInfo::has_requiredGem() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BloodNodeInfo::set_has_requiredGem() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BloodNodeInfo::clear_has_requiredGem() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BloodNodeInfo::clear_requiredGem() {
  requiredGem_ = GOOGLE_LONGLONG(0);
  clear_has_requiredGem();
}
inline ::google::protobuf::int64 BloodNodeInfo::requiredGem() const {
  return requiredGem_;
}
inline void BloodNodeInfo::set_requiredGem(::google::protobuf::int64 value) {
  set_has_requiredGem();
  requiredGem_ = value;
}

// optional float successRate = 5;
inline bool BloodNodeInfo::has_successRate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BloodNodeInfo::set_has_successRate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BloodNodeInfo::clear_has_successRate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BloodNodeInfo::clear_successRate() {
  successRate_ = 0;
  clear_has_successRate();
}
inline float BloodNodeInfo::successRate() const {
  return successRate_;
}
inline void BloodNodeInfo::set_successRate(float value) {
  set_has_successRate();
  successRate_ = value;
}

// repeated .BloodNodeInfo.Type type = 6;
inline int BloodNodeInfo::type_size() const {
  return type_.size();
}
inline void BloodNodeInfo::clear_type() {
  type_.Clear();
}
inline ::BloodNodeInfo_Type BloodNodeInfo::type(int index) const {
  return static_cast< ::BloodNodeInfo_Type >(type_.Get(index));
}
inline void BloodNodeInfo::set_type(int index, ::BloodNodeInfo_Type value) {
  GOOGLE_DCHECK(::BloodNodeInfo_Type_IsValid(value));
  type_.Set(index, value);
}
inline void BloodNodeInfo::add_type(::BloodNodeInfo_Type value) {
  GOOGLE_DCHECK(::BloodNodeInfo_Type_IsValid(value));
  type_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
BloodNodeInfo::type() const {
  return type_;
}
inline ::google::protobuf::RepeatedField<int>*
BloodNodeInfo::mutable_type() {
  return &type_;
}

// repeated int32 arg1 = 7;
inline int BloodNodeInfo::arg1_size() const {
  return arg1_.size();
}
inline void BloodNodeInfo::clear_arg1() {
  arg1_.Clear();
}
inline ::google::protobuf::int32 BloodNodeInfo::arg1(int index) const {
  return arg1_.Get(index);
}
inline void BloodNodeInfo::set_arg1(int index, ::google::protobuf::int32 value) {
  arg1_.Set(index, value);
}
inline void BloodNodeInfo::add_arg1(::google::protobuf::int32 value) {
  arg1_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BloodNodeInfo::arg1() const {
  return arg1_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BloodNodeInfo::mutable_arg1() {
  return &arg1_;
}

// repeated int32 arg2 = 8;
inline int BloodNodeInfo::arg2_size() const {
  return arg2_.size();
}
inline void BloodNodeInfo::clear_arg2() {
  arg2_.Clear();
}
inline ::google::protobuf::int32 BloodNodeInfo::arg2(int index) const {
  return arg2_.Get(index);
}
inline void BloodNodeInfo::set_arg2(int index, ::google::protobuf::int32 value) {
  arg2_.Set(index, value);
}
inline void BloodNodeInfo::add_arg2(::google::protobuf::int32 value) {
  arg2_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BloodNodeInfo::arg2() const {
  return arg2_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BloodNodeInfo::mutable_arg2() {
  return &arg2_;
}

// optional int32 goods = 9;
inline bool BloodNodeInfo::has_goods() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BloodNodeInfo::set_has_goods() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BloodNodeInfo::clear_has_goods() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BloodNodeInfo::clear_goods() {
  goods_ = 0;
  clear_has_goods();
}
inline ::google::protobuf::int32 BloodNodeInfo::goods() const {
  return goods_;
}
inline void BloodNodeInfo::set_goods(::google::protobuf::int32 value) {
  set_has_goods();
  goods_ = value;
}

// optional int32 count = 10;
inline bool BloodNodeInfo::has_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BloodNodeInfo::set_has_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BloodNodeInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BloodNodeInfo::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 BloodNodeInfo::count() const {
  return count_;
}
inline void BloodNodeInfo::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// AllBloodNodeInfo

// repeated .BloodNodeInfo bloodNodeInfo = 1;
inline int AllBloodNodeInfo::bloodNodeInfo_size() const {
  return bloodNodeInfo_.size();
}
inline void AllBloodNodeInfo::clear_bloodNodeInfo() {
  bloodNodeInfo_.Clear();
}
inline const ::BloodNodeInfo& AllBloodNodeInfo::bloodNodeInfo(int index) const {
  return bloodNodeInfo_.Get(index);
}
inline ::BloodNodeInfo* AllBloodNodeInfo::mutable_bloodNodeInfo(int index) {
  return bloodNodeInfo_.Mutable(index);
}
inline ::BloodNodeInfo* AllBloodNodeInfo::add_bloodNodeInfo() {
  return bloodNodeInfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BloodNodeInfo >&
AllBloodNodeInfo::bloodNodeInfo() const {
  return bloodNodeInfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::BloodNodeInfo >*
AllBloodNodeInfo::mutable_bloodNodeInfo() {
  return &bloodNodeInfo_;
}

// -------------------------------------------------------------------

// ExploreInfo

// optional int32 id = 1;
inline bool ExploreInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExploreInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExploreInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExploreInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ExploreInfo::id() const {
  return id_;
}
inline void ExploreInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .ExploreInfo.Type type = 2;
inline bool ExploreInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExploreInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExploreInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExploreInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ExploreInfo_Type ExploreInfo::type() const {
  return static_cast< ::ExploreInfo_Type >(type_);
}
inline void ExploreInfo::set_type(::ExploreInfo_Type value) {
  GOOGLE_DCHECK(::ExploreInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string desc = 3;
inline bool ExploreInfo::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExploreInfo::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExploreInfo::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExploreInfo::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& ExploreInfo::desc() const {
  return *desc_;
}
inline void ExploreInfo::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void ExploreInfo::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void ExploreInfo::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExploreInfo::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* ExploreInfo::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .ExploreInfo.SoulJadeType soulJadeType = 4;
inline bool ExploreInfo::has_soulJadeType() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExploreInfo::set_has_soulJadeType() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExploreInfo::clear_has_soulJadeType() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExploreInfo::clear_soulJadeType() {
  soulJadeType_ = 0;
  clear_has_soulJadeType();
}
inline ::ExploreInfo_SoulJadeType ExploreInfo::soulJadeType() const {
  return static_cast< ::ExploreInfo_SoulJadeType >(soulJadeType_);
}
inline void ExploreInfo::set_soulJadeType(::ExploreInfo_SoulJadeType value) {
  GOOGLE_DCHECK(::ExploreInfo_SoulJadeType_IsValid(value));
  set_has_soulJadeType();
  soulJadeType_ = value;
}

// optional int32 soulJadeCount = 5;
inline bool ExploreInfo::has_soulJadeCount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExploreInfo::set_has_soulJadeCount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExploreInfo::clear_has_soulJadeCount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExploreInfo::clear_soulJadeCount() {
  soulJadeCount_ = 0;
  clear_has_soulJadeCount();
}
inline ::google::protobuf::int32 ExploreInfo::soulJadeCount() const {
  return soulJadeCount_;
}
inline void ExploreInfo::set_soulJadeCount(::google::protobuf::int32 value) {
  set_has_soulJadeCount();
  soulJadeCount_ = value;
}

// optional int32 soul = 6;
inline bool ExploreInfo::has_soul() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExploreInfo::set_has_soul() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExploreInfo::clear_has_soul() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExploreInfo::clear_soul() {
  soul_ = 0;
  clear_has_soul();
}
inline ::google::protobuf::int32 ExploreInfo::soul() const {
  return soul_;
}
inline void ExploreInfo::set_soul(::google::protobuf::int32 value) {
  set_has_soul();
  soul_ = value;
}

// optional int32 rate = 7;
inline bool ExploreInfo::has_rate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExploreInfo::set_has_rate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExploreInfo::clear_has_rate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExploreInfo::clear_rate() {
  rate_ = 0;
  clear_has_rate();
}
inline ::google::protobuf::int32 ExploreInfo::rate() const {
  return rate_;
}
inline void ExploreInfo::set_rate(::google::protobuf::int32 value) {
  set_has_rate();
  rate_ = value;
}

// optional int32 soulStone = 8;
inline bool ExploreInfo::has_soulStone() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExploreInfo::set_has_soulStone() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExploreInfo::clear_has_soulStone() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExploreInfo::clear_soulStone() {
  soulStone_ = 0;
  clear_has_soulStone();
}
inline ::google::protobuf::int32 ExploreInfo::soulStone() const {
  return soulStone_;
}
inline void ExploreInfo::set_soulStone(::google::protobuf::int32 value) {
  set_has_soulStone();
  soulStone_ = value;
}

// -------------------------------------------------------------------

// AllExploreInfo

// repeated .ExploreInfo exploreInfo = 1;
inline int AllExploreInfo::exploreInfo_size() const {
  return exploreInfo_.size();
}
inline void AllExploreInfo::clear_exploreInfo() {
  exploreInfo_.Clear();
}
inline const ::ExploreInfo& AllExploreInfo::exploreInfo(int index) const {
  return exploreInfo_.Get(index);
}
inline ::ExploreInfo* AllExploreInfo::mutable_exploreInfo(int index) {
  return exploreInfo_.Mutable(index);
}
inline ::ExploreInfo* AllExploreInfo::add_exploreInfo() {
  return exploreInfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ExploreInfo >&
AllExploreInfo::exploreInfo() const {
  return exploreInfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::ExploreInfo >*
AllExploreInfo::mutable_exploreInfo() {
  return &exploreInfo_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BloodNodeInfo_Type>() {
  return ::BloodNodeInfo_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExploreInfo_Type>() {
  return ::ExploreInfo_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExploreInfo_SoulJadeType>() {
  return ::ExploreInfo_SoulJadeType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BloodInfo_2eproto__INCLUDED
