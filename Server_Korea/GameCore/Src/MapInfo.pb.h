// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MapInfo.proto

#ifndef PROTOBUF_MapInfo_2eproto__INCLUDED
#define PROTOBUF_MapInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Math.pb.h"
#include "BoxInfo.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MapInfo_2eproto();
void protobuf_AssignDesc_MapInfo_2eproto();
void protobuf_ShutdownFile_MapInfo_2eproto();

class NPCSceneUnit;
class JumpPointInfo;
class JumpTableInfo;
class AudioItemInfo;
class NPCPass;
class NPCGroup;
class PathNode;
class ObstacleTriggerInfo;
class MapUnit;
class MapInfo;
class AllMapInfo;
class BlockInfo;

enum PathNode_Type {
  PathNode_Type_PATH = 0,
  PathNode_Type_NPC = 1,
  PathNode_Type_DOOR = 2
};
bool PathNode_Type_IsValid(int value);
const PathNode_Type PathNode_Type_Type_MIN = PathNode_Type_PATH;
const PathNode_Type PathNode_Type_Type_MAX = PathNode_Type_DOOR;
const int PathNode_Type_Type_ARRAYSIZE = PathNode_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* PathNode_Type_descriptor();
inline const ::std::string& PathNode_Type_Name(PathNode_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    PathNode_Type_descriptor(), value);
}
inline bool PathNode_Type_Parse(
    const ::std::string& name, PathNode_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PathNode_Type>(
    PathNode_Type_descriptor(), name, value);
}
enum ObstacleTriggerInfo_OpenType {
  ObstacleTriggerInfo_OpenType_NONE = 0,
  ObstacleTriggerInfo_OpenType_KILL_GROUP_NPC = 1,
  ObstacleTriggerInfo_OpenType_SHOW_UI_PROGRESS = 2
};
bool ObstacleTriggerInfo_OpenType_IsValid(int value);
const ObstacleTriggerInfo_OpenType ObstacleTriggerInfo_OpenType_OpenType_MIN = ObstacleTriggerInfo_OpenType_NONE;
const ObstacleTriggerInfo_OpenType ObstacleTriggerInfo_OpenType_OpenType_MAX = ObstacleTriggerInfo_OpenType_SHOW_UI_PROGRESS;
const int ObstacleTriggerInfo_OpenType_OpenType_ARRAYSIZE = ObstacleTriggerInfo_OpenType_OpenType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObstacleTriggerInfo_OpenType_descriptor();
inline const ::std::string& ObstacleTriggerInfo_OpenType_Name(ObstacleTriggerInfo_OpenType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObstacleTriggerInfo_OpenType_descriptor(), value);
}
inline bool ObstacleTriggerInfo_OpenType_Parse(
    const ::std::string& name, ObstacleTriggerInfo_OpenType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstacleTriggerInfo_OpenType>(
    ObstacleTriggerInfo_OpenType_descriptor(), name, value);
}
enum MapUnit_SceneType {
  MapUnit_SceneType_LAND = 0,
  MapUnit_SceneType_OCEAN = 1
};
bool MapUnit_SceneType_IsValid(int value);
const MapUnit_SceneType MapUnit_SceneType_SceneType_MIN = MapUnit_SceneType_LAND;
const MapUnit_SceneType MapUnit_SceneType_SceneType_MAX = MapUnit_SceneType_OCEAN;
const int MapUnit_SceneType_SceneType_ARRAYSIZE = MapUnit_SceneType_SceneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapUnit_SceneType_descriptor();
inline const ::std::string& MapUnit_SceneType_Name(MapUnit_SceneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapUnit_SceneType_descriptor(), value);
}
inline bool MapUnit_SceneType_Parse(
    const ::std::string& name, MapUnit_SceneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapUnit_SceneType>(
    MapUnit_SceneType_descriptor(), name, value);
}
enum MapInfo_MapType {
  MapInfo_MapType_PEACE = 0,
  MapInfo_MapType_SINGLE = 1,
  MapInfo_MapType_ROOM = 2,
  MapInfo_MapType_PVP = 3,
  MapInfo_MapType_ONLY_ROOM = 4,
  MapInfo_MapType_PRACTICE = 5,
  MapInfo_MapType_HELL = 6,
  MapInfo_MapType_BATTLE_SINGLE = 7
};
bool MapInfo_MapType_IsValid(int value);
const MapInfo_MapType MapInfo_MapType_MapType_MIN = MapInfo_MapType_PEACE;
const MapInfo_MapType MapInfo_MapType_MapType_MAX = MapInfo_MapType_BATTLE_SINGLE;
const int MapInfo_MapType_MapType_ARRAYSIZE = MapInfo_MapType_MapType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapInfo_MapType_descriptor();
inline const ::std::string& MapInfo_MapType_Name(MapInfo_MapType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapInfo_MapType_descriptor(), value);
}
inline bool MapInfo_MapType_Parse(
    const ::std::string& name, MapInfo_MapType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapInfo_MapType>(
    MapInfo_MapType_descriptor(), name, value);
}
enum MapInfo_AwardType {
  MapInfo_AwardType_FINAL = 0,
  MapInfo_AwardType_PASS = 1
};
bool MapInfo_AwardType_IsValid(int value);
const MapInfo_AwardType MapInfo_AwardType_AwardType_MIN = MapInfo_AwardType_FINAL;
const MapInfo_AwardType MapInfo_AwardType_AwardType_MAX = MapInfo_AwardType_PASS;
const int MapInfo_AwardType_AwardType_ARRAYSIZE = MapInfo_AwardType_AwardType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapInfo_AwardType_descriptor();
inline const ::std::string& MapInfo_AwardType_Name(MapInfo_AwardType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapInfo_AwardType_descriptor(), value);
}
inline bool MapInfo_AwardType_Parse(
    const ::std::string& name, MapInfo_AwardType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapInfo_AwardType>(
    MapInfo_AwardType_descriptor(), name, value);
}
enum MapInfo_OpenNPCType {
  MapInfo_OpenNPCType_NORMAL = 0,
  MapInfo_OpenNPCType_TRIGGER = 1
};
bool MapInfo_OpenNPCType_IsValid(int value);
const MapInfo_OpenNPCType MapInfo_OpenNPCType_OpenNPCType_MIN = MapInfo_OpenNPCType_NORMAL;
const MapInfo_OpenNPCType MapInfo_OpenNPCType_OpenNPCType_MAX = MapInfo_OpenNPCType_TRIGGER;
const int MapInfo_OpenNPCType_OpenNPCType_ARRAYSIZE = MapInfo_OpenNPCType_OpenNPCType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapInfo_OpenNPCType_descriptor();
inline const ::std::string& MapInfo_OpenNPCType_Name(MapInfo_OpenNPCType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapInfo_OpenNPCType_descriptor(), value);
}
inline bool MapInfo_OpenNPCType_Parse(
    const ::std::string& name, MapInfo_OpenNPCType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapInfo_OpenNPCType>(
    MapInfo_OpenNPCType_descriptor(), name, value);
}
enum BlockInfo_BlockType {
  BlockInfo_BlockType_DEFAULT = 0,
  BlockInfo_BlockType_UNWALKABLE = 1,
  BlockInfo_BlockType_UNWALKABLE_UNSKILL = 2
};
bool BlockInfo_BlockType_IsValid(int value);
const BlockInfo_BlockType BlockInfo_BlockType_BlockType_MIN = BlockInfo_BlockType_DEFAULT;
const BlockInfo_BlockType BlockInfo_BlockType_BlockType_MAX = BlockInfo_BlockType_UNWALKABLE_UNSKILL;
const int BlockInfo_BlockType_BlockType_ARRAYSIZE = BlockInfo_BlockType_BlockType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BlockInfo_BlockType_descriptor();
inline const ::std::string& BlockInfo_BlockType_Name(BlockInfo_BlockType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BlockInfo_BlockType_descriptor(), value);
}
inline bool BlockInfo_BlockType_Parse(
    const ::std::string& name, BlockInfo_BlockType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlockInfo_BlockType>(
    BlockInfo_BlockType_descriptor(), name, value);
}
// ===================================================================

class NPCSceneUnit : public ::google::protobuf::Message {
 public:
  NPCSceneUnit();
  virtual ~NPCSceneUnit();
  
  NPCSceneUnit(const NPCSceneUnit& from);
  
  inline NPCSceneUnit& operator=(const NPCSceneUnit& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NPCSceneUnit& default_instance();
  
  void Swap(NPCSceneUnit* other);
  
  // implements Message ----------------------------------------------
  
  NPCSceneUnit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NPCSceneUnit& from);
  void MergeFrom(const NPCSceneUnit& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .PB_Vector2i coord = 2;
  inline bool has_coord() const;
  inline void clear_coord();
  static const int kCoordFieldNumber = 2;
  inline const ::PB_Vector2i& coord() const;
  inline ::PB_Vector2i* mutable_coord();
  inline ::PB_Vector2i* release_coord();
  
  // optional int32 resID = 3;
  inline bool has_resID() const;
  inline void clear_resID();
  static const int kResIDFieldNumber = 3;
  inline ::google::protobuf::int32 resID() const;
  inline void set_resID(::google::protobuf::int32 value);
  
  // optional .PB_Vector3f rotation = 4;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 4;
  inline const ::PB_Vector3f& rotation() const;
  inline ::PB_Vector3f* mutable_rotation();
  inline ::PB_Vector3f* release_rotation();
  
  // @@protoc_insertion_point(class_scope:NPCSceneUnit)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_coord();
  inline void clear_has_coord();
  inline void set_has_resID();
  inline void clear_has_resID();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::PB_Vector2i* coord_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 resID_;
  ::PB_Vector3f* rotation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static NPCSceneUnit* default_instance_;
};
// -------------------------------------------------------------------

class JumpPointInfo : public ::google::protobuf::Message {
 public:
  JumpPointInfo();
  virtual ~JumpPointInfo();
  
  JumpPointInfo(const JumpPointInfo& from);
  
  inline JumpPointInfo& operator=(const JumpPointInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JumpPointInfo& default_instance();
  
  void Swap(JumpPointInfo* other);
  
  // implements Message ----------------------------------------------
  
  JumpPointInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JumpPointInfo& from);
  void MergeFrom(const JumpPointInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .PB_Vector2i enterCoord = 2;
  inline bool has_enterCoord() const;
  inline void clear_enterCoord();
  static const int kEnterCoordFieldNumber = 2;
  inline const ::PB_Vector2i& enterCoord() const;
  inline ::PB_Vector2i* mutable_enterCoord();
  inline ::PB_Vector2i* release_enterCoord();
  
  // optional int32 nextMap = 3;
  inline bool has_nextMap() const;
  inline void clear_nextMap();
  static const int kNextMapFieldNumber = 3;
  inline ::google::protobuf::int32 nextMap() const;
  inline void set_nextMap(::google::protobuf::int32 value);
  
  // optional int32 nextPoint = 4;
  inline bool has_nextPoint() const;
  inline void clear_nextPoint();
  static const int kNextPointFieldNumber = 4;
  inline ::google::protobuf::int32 nextPoint() const;
  inline void set_nextPoint(::google::protobuf::int32 value);
  
  // optional .PB_Vector2i coord = 5;
  inline bool has_coord() const;
  inline void clear_coord();
  static const int kCoordFieldNumber = 5;
  inline const ::PB_Vector2i& coord() const;
  inline ::PB_Vector2i* mutable_coord();
  inline ::PB_Vector2i* release_coord();
  
  // @@protoc_insertion_point(class_scope:JumpPointInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_enterCoord();
  inline void clear_has_enterCoord();
  inline void set_has_nextMap();
  inline void clear_has_nextMap();
  inline void set_has_nextPoint();
  inline void clear_has_nextPoint();
  inline void set_has_coord();
  inline void clear_has_coord();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::PB_Vector2i* enterCoord_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 nextMap_;
  ::PB_Vector2i* coord_;
  ::google::protobuf::int32 nextPoint_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static JumpPointInfo* default_instance_;
};
// -------------------------------------------------------------------

class JumpTableInfo : public ::google::protobuf::Message {
 public:
  JumpTableInfo();
  virtual ~JumpTableInfo();
  
  JumpTableInfo(const JumpTableInfo& from);
  
  inline JumpTableInfo& operator=(const JumpTableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const JumpTableInfo& default_instance();
  
  void Swap(JumpTableInfo* other);
  
  // implements Message ----------------------------------------------
  
  JumpTableInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JumpTableInfo& from);
  void MergeFrom(const JumpTableInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .JumpPointInfo table = 1;
  inline int table_size() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::JumpPointInfo& table(int index) const;
  inline ::JumpPointInfo* mutable_table(int index);
  inline ::JumpPointInfo* add_table();
  inline const ::google::protobuf::RepeatedPtrField< ::JumpPointInfo >&
      table() const;
  inline ::google::protobuf::RepeatedPtrField< ::JumpPointInfo >*
      mutable_table();
  
  // @@protoc_insertion_point(class_scope:JumpTableInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::JumpPointInfo > table_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static JumpTableInfo* default_instance_;
};
// -------------------------------------------------------------------

class AudioItemInfo : public ::google::protobuf::Message {
 public:
  AudioItemInfo();
  virtual ~AudioItemInfo();
  
  AudioItemInfo(const AudioItemInfo& from);
  
  inline AudioItemInfo& operator=(const AudioItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioItemInfo& default_instance();
  
  void Swap(AudioItemInfo* other);
  
  // implements Message ----------------------------------------------
  
  AudioItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioItemInfo& from);
  void MergeFrom(const AudioItemInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string audioID = 1;
  inline bool has_audioID() const;
  inline void clear_audioID();
  static const int kAudioIDFieldNumber = 1;
  inline const ::std::string& audioID() const;
  inline void set_audioID(const ::std::string& value);
  inline void set_audioID(const char* value);
  inline void set_audioID(const char* value, size_t size);
  inline ::std::string* mutable_audioID();
  inline ::std::string* release_audioID();
  
  // optional float volume = 2;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 2;
  inline float volume() const;
  inline void set_volume(float value);
  
  // optional float maxDistance = 3;
  inline bool has_maxDistance() const;
  inline void clear_maxDistance();
  static const int kMaxDistanceFieldNumber = 3;
  inline float maxDistance() const;
  inline void set_maxDistance(float value);
  
  // optional int32 number = 4;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 4;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);
  
  // optional int32 minInterval = 5;
  inline bool has_minInterval() const;
  inline void clear_minInterval();
  static const int kMinIntervalFieldNumber = 5;
  inline ::google::protobuf::int32 minInterval() const;
  inline void set_minInterval(::google::protobuf::int32 value);
  
  // optional int32 delay = 6;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 6;
  inline ::google::protobuf::int32 delay() const;
  inline void set_delay(::google::protobuf::int32 value);
  
  // optional .PB_Vector3f position = 7;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 7;
  inline const ::PB_Vector3f& position() const;
  inline ::PB_Vector3f* mutable_position();
  inline ::PB_Vector3f* release_position();
  
  // optional int32 maxInterval = 8;
  inline bool has_maxInterval() const;
  inline void clear_maxInterval();
  static const int kMaxIntervalFieldNumber = 8;
  inline ::google::protobuf::int32 maxInterval() const;
  inline void set_maxInterval(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:AudioItemInfo)
 private:
  inline void set_has_audioID();
  inline void clear_has_audioID();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_maxDistance();
  inline void clear_has_maxDistance();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_minInterval();
  inline void clear_has_minInterval();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_maxInterval();
  inline void clear_has_maxInterval();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* audioID_;
  float volume_;
  float maxDistance_;
  ::google::protobuf::int32 number_;
  ::google::protobuf::int32 minInterval_;
  ::PB_Vector3f* position_;
  ::google::protobuf::int32 delay_;
  ::google::protobuf::int32 maxInterval_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AudioItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class NPCPass : public ::google::protobuf::Message {
 public:
  NPCPass();
  virtual ~NPCPass();
  
  NPCPass(const NPCPass& from);
  
  inline NPCPass& operator=(const NPCPass& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NPCPass& default_instance();
  
  void Swap(NPCPass* other);
  
  // implements Message ----------------------------------------------
  
  NPCPass* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NPCPass& from);
  void MergeFrom(const NPCPass& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 npcs = 1;
  inline int npcs_size() const;
  inline void clear_npcs();
  static const int kNpcsFieldNumber = 1;
  inline ::google::protobuf::int32 npcs(int index) const;
  inline void set_npcs(int index, ::google::protobuf::int32 value);
  inline void add_npcs(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      npcs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_npcs();
  
  // optional int32 delay = 2;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 2;
  inline ::google::protobuf::int32 delay() const;
  inline void set_delay(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:NPCPass)
 private:
  inline void set_has_delay();
  inline void clear_has_delay();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > npcs_;
  ::google::protobuf::int32 delay_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static NPCPass* default_instance_;
};
// -------------------------------------------------------------------

class NPCGroup : public ::google::protobuf::Message {
 public:
  NPCGroup();
  virtual ~NPCGroup();
  
  NPCGroup(const NPCGroup& from);
  
  inline NPCGroup& operator=(const NPCGroup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NPCGroup& default_instance();
  
  void Swap(NPCGroup* other);
  
  // implements Message ----------------------------------------------
  
  NPCGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NPCGroup& from);
  void MergeFrom(const NPCGroup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .NPCPass pass = 1;
  inline int pass_size() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 1;
  inline const ::NPCPass& pass(int index) const;
  inline ::NPCPass* mutable_pass(int index);
  inline ::NPCPass* add_pass();
  inline const ::google::protobuf::RepeatedPtrField< ::NPCPass >&
      pass() const;
  inline ::google::protobuf::RepeatedPtrField< ::NPCPass >*
      mutable_pass();
  
  // @@protoc_insertion_point(class_scope:NPCGroup)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::NPCPass > pass_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static NPCGroup* default_instance_;
};
// -------------------------------------------------------------------

class PathNode : public ::google::protobuf::Message {
 public:
  PathNode();
  virtual ~PathNode();
  
  PathNode(const PathNode& from);
  
  inline PathNode& operator=(const PathNode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PathNode& default_instance();
  
  void Swap(PathNode* other);
  
  // implements Message ----------------------------------------------
  
  PathNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PathNode& from);
  void MergeFrom(const PathNode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PathNode_Type Type;
  static const Type PATH = PathNode_Type_PATH;
  static const Type NPC = PathNode_Type_NPC;
  static const Type DOOR = PathNode_Type_DOOR;
  static inline bool Type_IsValid(int value) {
    return PathNode_Type_IsValid(value);
  }
  static const Type Type_MIN =
    PathNode_Type_Type_MIN;
  static const Type Type_MAX =
    PathNode_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    PathNode_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return PathNode_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return PathNode_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return PathNode_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional .PathNode.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::PathNode_Type type() const;
  inline void set_type(::PathNode_Type value);
  
  // repeated int32 next = 3;
  inline int next_size() const;
  inline void clear_next();
  static const int kNextFieldNumber = 3;
  inline ::google::protobuf::int32 next(int index) const;
  inline void set_next(int index, ::google::protobuf::int32 value);
  inline void add_next(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      next() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_next();
  
  // optional .PB_Vector3f pos = 4;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 4;
  inline const ::PB_Vector3f& pos() const;
  inline ::PB_Vector3f* mutable_pos();
  inline ::PB_Vector3f* release_pos();
  
  // @@protoc_insertion_point(class_scope:PathNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pos();
  inline void clear_has_pos();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  int type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > next_;
  ::PB_Vector3f* pos_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static PathNode* default_instance_;
};
// -------------------------------------------------------------------

class ObstacleTriggerInfo : public ::google::protobuf::Message {
 public:
  ObstacleTriggerInfo();
  virtual ~ObstacleTriggerInfo();
  
  ObstacleTriggerInfo(const ObstacleTriggerInfo& from);
  
  inline ObstacleTriggerInfo& operator=(const ObstacleTriggerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleTriggerInfo& default_instance();
  
  void Swap(ObstacleTriggerInfo* other);
  
  // implements Message ----------------------------------------------
  
  ObstacleTriggerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObstacleTriggerInfo& from);
  void MergeFrom(const ObstacleTriggerInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ObstacleTriggerInfo_OpenType OpenType;
  static const OpenType NONE = ObstacleTriggerInfo_OpenType_NONE;
  static const OpenType KILL_GROUP_NPC = ObstacleTriggerInfo_OpenType_KILL_GROUP_NPC;
  static const OpenType SHOW_UI_PROGRESS = ObstacleTriggerInfo_OpenType_SHOW_UI_PROGRESS;
  static inline bool OpenType_IsValid(int value) {
    return ObstacleTriggerInfo_OpenType_IsValid(value);
  }
  static const OpenType OpenType_MIN =
    ObstacleTriggerInfo_OpenType_OpenType_MIN;
  static const OpenType OpenType_MAX =
    ObstacleTriggerInfo_OpenType_OpenType_MAX;
  static const int OpenType_ARRAYSIZE =
    ObstacleTriggerInfo_OpenType_OpenType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpenType_descriptor() {
    return ObstacleTriggerInfo_OpenType_descriptor();
  }
  static inline const ::std::string& OpenType_Name(OpenType value) {
    return ObstacleTriggerInfo_OpenType_Name(value);
  }
  static inline bool OpenType_Parse(const ::std::string& name,
      OpenType* value) {
    return ObstacleTriggerInfo_OpenType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 openType = 1;
  inline bool has_openType() const;
  inline void clear_openType();
  static const int kOpenTypeFieldNumber = 1;
  inline ::google::protobuf::int32 openType() const;
  inline void set_openType(::google::protobuf::int32 value);
  
  // repeated int32 param = 2;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::google::protobuf::int32 param(int index) const;
  inline void set_param(int index, ::google::protobuf::int32 value);
  inline void add_param(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      param() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_param();
  
  // optional int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ObstacleTriggerInfo)
 private:
  inline void set_has_openType();
  inline void clear_has_openType();
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > param_;
  ::google::protobuf::int32 openType_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static ObstacleTriggerInfo* default_instance_;
};
// -------------------------------------------------------------------

class MapUnit : public ::google::protobuf::Message {
 public:
  MapUnit();
  virtual ~MapUnit();
  
  MapUnit(const MapUnit& from);
  
  inline MapUnit& operator=(const MapUnit& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapUnit& default_instance();
  
  void Swap(MapUnit* other);
  
  // implements Message ----------------------------------------------
  
  MapUnit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapUnit& from);
  void MergeFrom(const MapUnit& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MapUnit_SceneType SceneType;
  static const SceneType LAND = MapUnit_SceneType_LAND;
  static const SceneType OCEAN = MapUnit_SceneType_OCEAN;
  static inline bool SceneType_IsValid(int value) {
    return MapUnit_SceneType_IsValid(value);
  }
  static const SceneType SceneType_MIN =
    MapUnit_SceneType_SceneType_MIN;
  static const SceneType SceneType_MAX =
    MapUnit_SceneType_SceneType_MAX;
  static const int SceneType_ARRAYSIZE =
    MapUnit_SceneType_SceneType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SceneType_descriptor() {
    return MapUnit_SceneType_descriptor();
  }
  static inline const ::std::string& SceneType_Name(SceneType value) {
    return MapUnit_SceneType_Name(value);
  }
  static inline bool SceneType_Parse(const ::std::string& name,
      SceneType* value) {
    return MapUnit_SceneType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // repeated .NPCSceneUnit npcs = 2;
  inline int npcs_size() const;
  inline void clear_npcs();
  static const int kNpcsFieldNumber = 2;
  inline const ::NPCSceneUnit& npcs(int index) const;
  inline ::NPCSceneUnit* mutable_npcs(int index);
  inline ::NPCSceneUnit* add_npcs();
  inline const ::google::protobuf::RepeatedPtrField< ::NPCSceneUnit >&
      npcs() const;
  inline ::google::protobuf::RepeatedPtrField< ::NPCSceneUnit >*
      mutable_npcs();
  
  // optional .JumpTableInfo jumpTable = 3;
  inline bool has_jumpTable() const;
  inline void clear_jumpTable();
  static const int kJumpTableFieldNumber = 3;
  inline const ::JumpTableInfo& jumpTable() const;
  inline ::JumpTableInfo* mutable_jumpTable();
  inline ::JumpTableInfo* release_jumpTable();
  
  // repeated .AudioItemInfo audioItems = 4;
  inline int audioItems_size() const;
  inline void clear_audioItems();
  static const int kAudioItemsFieldNumber = 4;
  inline const ::AudioItemInfo& audioItems(int index) const;
  inline ::AudioItemInfo* mutable_audioItems(int index);
  inline ::AudioItemInfo* add_audioItems();
  inline const ::google::protobuf::RepeatedPtrField< ::AudioItemInfo >&
      audioItems() const;
  inline ::google::protobuf::RepeatedPtrField< ::AudioItemInfo >*
      mutable_audioItems();
  
  // optional int32 resID = 5;
  inline bool has_resID() const;
  inline void clear_resID();
  static const int kResIDFieldNumber = 5;
  inline ::google::protobuf::int32 resID() const;
  inline void set_resID(::google::protobuf::int32 value);
  
  // repeated .NPCGroup npcGroups = 6;
  inline int npcGroups_size() const;
  inline void clear_npcGroups();
  static const int kNpcGroupsFieldNumber = 6;
  inline const ::NPCGroup& npcGroups(int index) const;
  inline ::NPCGroup* mutable_npcGroups(int index);
  inline ::NPCGroup* add_npcGroups();
  inline const ::google::protobuf::RepeatedPtrField< ::NPCGroup >&
      npcGroups() const;
  inline ::google::protobuf::RepeatedPtrField< ::NPCGroup >*
      mutable_npcGroups();
  
  // optional int32 boss = 7 [default = -1];
  inline bool has_boss() const;
  inline void clear_boss();
  static const int kBossFieldNumber = 7;
  inline ::google::protobuf::int32 boss() const;
  inline void set_boss(::google::protobuf::int32 value);
  
  // optional .MapUnit.SceneType sceneType = 8;
  inline bool has_sceneType() const;
  inline void clear_sceneType();
  static const int kSceneTypeFieldNumber = 8;
  inline ::MapUnit_SceneType sceneType() const;
  inline void set_sceneType(::MapUnit_SceneType value);
  
  // repeated .PathNode path = 9;
  inline int path_size() const;
  inline void clear_path();
  static const int kPathFieldNumber = 9;
  inline const ::PathNode& path(int index) const;
  inline ::PathNode* mutable_path(int index);
  inline ::PathNode* add_path();
  inline const ::google::protobuf::RepeatedPtrField< ::PathNode >&
      path() const;
  inline ::google::protobuf::RepeatedPtrField< ::PathNode >*
      mutable_path();
  
  // optional int32 protectNPC = 10 [default = -1];
  inline bool has_protectNPC() const;
  inline void clear_protectNPC();
  static const int kProtectNPCFieldNumber = 10;
  inline ::google::protobuf::int32 protectNPC() const;
  inline void set_protectNPC(::google::protobuf::int32 value);
  
  // optional int32 targetNode = 11 [default = -1];
  inline bool has_targetNode() const;
  inline void clear_targetNode();
  static const int kTargetNodeFieldNumber = 11;
  inline ::google::protobuf::int32 targetNode() const;
  inline void set_targetNode(::google::protobuf::int32 value);
  
  // repeated .ObstacleTriggerInfo obstacleTriggerInfo = 12;
  inline int obstacleTriggerInfo_size() const;
  inline void clear_obstacleTriggerInfo();
  static const int kObstacleTriggerInfoFieldNumber = 12;
  inline const ::ObstacleTriggerInfo& obstacleTriggerInfo(int index) const;
  inline ::ObstacleTriggerInfo* mutable_obstacleTriggerInfo(int index);
  inline ::ObstacleTriggerInfo* add_obstacleTriggerInfo();
  inline const ::google::protobuf::RepeatedPtrField< ::ObstacleTriggerInfo >&
      obstacleTriggerInfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::ObstacleTriggerInfo >*
      mutable_obstacleTriggerInfo();
  
  // repeated int32 friendlyNpc = 13;
  inline int friendlyNpc_size() const;
  inline void clear_friendlyNpc();
  static const int kFriendlyNpcFieldNumber = 13;
  inline ::google::protobuf::int32 friendlyNpc(int index) const;
  inline void set_friendlyNpc(int index, ::google::protobuf::int32 value);
  inline void add_friendlyNpc(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      friendlyNpc() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_friendlyNpc();
  
  // repeated .PB_Vector3f freeCoords = 14;
  inline int freeCoords_size() const;
  inline void clear_freeCoords();
  static const int kFreeCoordsFieldNumber = 14;
  inline const ::PB_Vector3f& freeCoords(int index) const;
  inline ::PB_Vector3f* mutable_freeCoords(int index);
  inline ::PB_Vector3f* add_freeCoords();
  inline const ::google::protobuf::RepeatedPtrField< ::PB_Vector3f >&
      freeCoords() const;
  inline ::google::protobuf::RepeatedPtrField< ::PB_Vector3f >*
      mutable_freeCoords();
  
  // optional int32 enemyTargetNode = 15;
  inline bool has_enemyTargetNode() const;
  inline void clear_enemyTargetNode();
  static const int kEnemyTargetNodeFieldNumber = 15;
  inline ::google::protobuf::int32 enemyTargetNode() const;
  inline void set_enemyTargetNode(::google::protobuf::int32 value);
  
  // repeated int32 heroNPC = 16;
  inline int heroNPC_size() const;
  inline void clear_heroNPC();
  static const int kHeroNPCFieldNumber = 16;
  inline ::google::protobuf::int32 heroNPC(int index) const;
  inline void set_heroNPC(int index, ::google::protobuf::int32 value);
  inline void add_heroNPC(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      heroNPC() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_heroNPC();
  
  // repeated int32 ourRecoverHPNode = 17;
  inline int ourRecoverHPNode_size() const;
  inline void clear_ourRecoverHPNode();
  static const int kOurRecoverHPNodeFieldNumber = 17;
  inline ::google::protobuf::int32 ourRecoverHPNode(int index) const;
  inline void set_ourRecoverHPNode(int index, ::google::protobuf::int32 value);
  inline void add_ourRecoverHPNode(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ourRecoverHPNode() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ourRecoverHPNode();
  
  // repeated int32 enemyRecoverHPNode = 18;
  inline int enemyRecoverHPNode_size() const;
  inline void clear_enemyRecoverHPNode();
  static const int kEnemyRecoverHPNodeFieldNumber = 18;
  inline ::google::protobuf::int32 enemyRecoverHPNode(int index) const;
  inline void set_enemyRecoverHPNode(int index, ::google::protobuf::int32 value);
  inline void add_enemyRecoverHPNode(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      enemyRecoverHPNode() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_enemyRecoverHPNode();
  
  // @@protoc_insertion_point(class_scope:MapUnit)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_jumpTable();
  inline void clear_has_jumpTable();
  inline void set_has_resID();
  inline void clear_has_resID();
  inline void set_has_boss();
  inline void clear_has_boss();
  inline void set_has_sceneType();
  inline void clear_has_sceneType();
  inline void set_has_protectNPC();
  inline void clear_has_protectNPC();
  inline void set_has_targetNode();
  inline void clear_has_targetNode();
  inline void set_has_enemyTargetNode();
  inline void clear_has_enemyTargetNode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::NPCSceneUnit > npcs_;
  ::JumpTableInfo* jumpTable_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 resID_;
  ::google::protobuf::RepeatedPtrField< ::AudioItemInfo > audioItems_;
  ::google::protobuf::RepeatedPtrField< ::NPCGroup > npcGroups_;
  ::google::protobuf::int32 boss_;
  int sceneType_;
  ::google::protobuf::RepeatedPtrField< ::PathNode > path_;
  ::google::protobuf::int32 protectNPC_;
  ::google::protobuf::int32 targetNode_;
  ::google::protobuf::RepeatedPtrField< ::ObstacleTriggerInfo > obstacleTriggerInfo_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > friendlyNpc_;
  ::google::protobuf::RepeatedPtrField< ::PB_Vector3f > freeCoords_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > heroNPC_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ourRecoverHPNode_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > enemyRecoverHPNode_;
  ::google::protobuf::int32 enemyTargetNode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static MapUnit* default_instance_;
};
// -------------------------------------------------------------------

class MapInfo : public ::google::protobuf::Message {
 public:
  MapInfo();
  virtual ~MapInfo();
  
  MapInfo(const MapInfo& from);
  
  inline MapInfo& operator=(const MapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapInfo& default_instance();
  
  void Swap(MapInfo* other);
  
  // implements Message ----------------------------------------------
  
  MapInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapInfo& from);
  void MergeFrom(const MapInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MapInfo_MapType MapType;
  static const MapType PEACE = MapInfo_MapType_PEACE;
  static const MapType SINGLE = MapInfo_MapType_SINGLE;
  static const MapType ROOM = MapInfo_MapType_ROOM;
  static const MapType PVP = MapInfo_MapType_PVP;
  static const MapType ONLY_ROOM = MapInfo_MapType_ONLY_ROOM;
  static const MapType PRACTICE = MapInfo_MapType_PRACTICE;
  static const MapType HELL = MapInfo_MapType_HELL;
  static const MapType BATTLE_SINGLE = MapInfo_MapType_BATTLE_SINGLE;
  static inline bool MapType_IsValid(int value) {
    return MapInfo_MapType_IsValid(value);
  }
  static const MapType MapType_MIN =
    MapInfo_MapType_MapType_MIN;
  static const MapType MapType_MAX =
    MapInfo_MapType_MapType_MAX;
  static const int MapType_ARRAYSIZE =
    MapInfo_MapType_MapType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MapType_descriptor() {
    return MapInfo_MapType_descriptor();
  }
  static inline const ::std::string& MapType_Name(MapType value) {
    return MapInfo_MapType_Name(value);
  }
  static inline bool MapType_Parse(const ::std::string& name,
      MapType* value) {
    return MapInfo_MapType_Parse(name, value);
  }
  
  typedef MapInfo_AwardType AwardType;
  static const AwardType FINAL = MapInfo_AwardType_FINAL;
  static const AwardType PASS = MapInfo_AwardType_PASS;
  static inline bool AwardType_IsValid(int value) {
    return MapInfo_AwardType_IsValid(value);
  }
  static const AwardType AwardType_MIN =
    MapInfo_AwardType_AwardType_MIN;
  static const AwardType AwardType_MAX =
    MapInfo_AwardType_AwardType_MAX;
  static const int AwardType_ARRAYSIZE =
    MapInfo_AwardType_AwardType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AwardType_descriptor() {
    return MapInfo_AwardType_descriptor();
  }
  static inline const ::std::string& AwardType_Name(AwardType value) {
    return MapInfo_AwardType_Name(value);
  }
  static inline bool AwardType_Parse(const ::std::string& name,
      AwardType* value) {
    return MapInfo_AwardType_Parse(name, value);
  }
  
  typedef MapInfo_OpenNPCType OpenNPCType;
  static const OpenNPCType NORMAL = MapInfo_OpenNPCType_NORMAL;
  static const OpenNPCType TRIGGER = MapInfo_OpenNPCType_TRIGGER;
  static inline bool OpenNPCType_IsValid(int value) {
    return MapInfo_OpenNPCType_IsValid(value);
  }
  static const OpenNPCType OpenNPCType_MIN =
    MapInfo_OpenNPCType_OpenNPCType_MIN;
  static const OpenNPCType OpenNPCType_MAX =
    MapInfo_OpenNPCType_OpenNPCType_MAX;
  static const int OpenNPCType_ARRAYSIZE =
    MapInfo_OpenNPCType_OpenNPCType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpenNPCType_descriptor() {
    return MapInfo_OpenNPCType_descriptor();
  }
  static inline const ::std::string& OpenNPCType_Name(OpenNPCType value) {
    return MapInfo_OpenNPCType_Name(value);
  }
  static inline bool OpenNPCType_Parse(const ::std::string& name,
      OpenNPCType* value) {
    return MapInfo_OpenNPCType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .MapInfo.MapType mapType = 1;
  inline bool has_mapType() const;
  inline void clear_mapType();
  static const int kMapTypeFieldNumber = 1;
  inline ::MapInfo_MapType mapType() const;
  inline void set_mapType(::MapInfo_MapType value);
  
  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // optional int32 requireMission = 5;
  inline bool has_requireMission() const;
  inline void clear_requireMission();
  static const int kRequireMissionFieldNumber = 5;
  inline ::google::protobuf::int32 requireMission() const;
  inline void set_requireMission(::google::protobuf::int32 value);
  
  // repeated int32 sceneAudio = 6;
  inline int sceneAudio_size() const;
  inline void clear_sceneAudio();
  static const int kSceneAudioFieldNumber = 6;
  inline ::google::protobuf::int32 sceneAudio(int index) const;
  inline void set_sceneAudio(int index, ::google::protobuf::int32 value);
  inline void add_sceneAudio(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      sceneAudio() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_sceneAudio();
  
  // optional int32 freeBox = 7;
  inline bool has_freeBox() const;
  inline void clear_freeBox();
  static const int kFreeBoxFieldNumber = 7;
  inline ::google::protobuf::int32 freeBox() const;
  inline void set_freeBox(::google::protobuf::int32 value);
  
  // optional int32 gemBox = 8;
  inline bool has_gemBox() const;
  inline void clear_gemBox();
  static const int kGemBoxFieldNumber = 8;
  inline ::google::protobuf::int32 gemBox() const;
  inline void set_gemBox(::google::protobuf::int32 value);
  
  // optional int32 exp = 9;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 9;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);
  
  // optional int32 honor = 10;
  inline bool has_honor() const;
  inline void clear_honor();
  static const int kHonorFieldNumber = 10;
  inline ::google::protobuf::int32 honor() const;
  inline void set_honor(::google::protobuf::int32 value);
  
  // optional int32 requiredPower = 11;
  inline bool has_requiredPower() const;
  inline void clear_requiredPower();
  static const int kRequiredPowerFieldNumber = 11;
  inline ::google::protobuf::int32 requiredPower() const;
  inline void set_requiredPower(::google::protobuf::int32 value);
  
  // optional int32 durability = 12;
  inline bool has_durability() const;
  inline void clear_durability();
  static const int kDurabilityFieldNumber = 12;
  inline ::google::protobuf::int32 durability() const;
  inline void set_durability(::google::protobuf::int32 value);
  
  // optional .MapInfo.AwardType awardType = 13;
  inline bool has_awardType() const;
  inline void clear_awardType();
  static const int kAwardTypeFieldNumber = 13;
  inline ::MapInfo_AwardType awardType() const;
  inline void set_awardType(::MapInfo_AwardType value);
  
  // optional int32 money = 14;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 14;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);
  
  // optional int32 rmb = 15;
  inline bool has_rmb() const;
  inline void clear_rmb();
  static const int kRmbFieldNumber = 15;
  inline ::google::protobuf::int32 rmb() const;
  inline void set_rmb(::google::protobuf::int32 value);
  
  // optional int32 soul = 16;
  inline bool has_soul() const;
  inline void clear_soul();
  static const int kSoulFieldNumber = 16;
  inline ::google::protobuf::int32 soul() const;
  inline void set_soul(::google::protobuf::int32 value);
  
  // optional int32 showBox = 17;
  inline bool has_showBox() const;
  inline void clear_showBox();
  static const int kShowBoxFieldNumber = 17;
  inline ::google::protobuf::int32 showBox() const;
  inline void set_showBox(::google::protobuf::int32 value);
  
  // optional int32 smallSoulJade = 18;
  inline bool has_smallSoulJade() const;
  inline void clear_smallSoulJade();
  static const int kSmallSoulJadeFieldNumber = 18;
  inline ::google::protobuf::int32 smallSoulJade() const;
  inline void set_smallSoulJade(::google::protobuf::int32 value);
  
  // optional int32 soulStone = 19;
  inline bool has_soulStone() const;
  inline void clear_soulStone();
  static const int kSoulStoneFieldNumber = 19;
  inline ::google::protobuf::int32 soulStone() const;
  inline void set_soulStone(::google::protobuf::int32 value);
  
  // optional int32 parent = 20;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 20;
  inline ::google::protobuf::int32 parent() const;
  inline void set_parent(::google::protobuf::int32 value);
  
  // optional int32 child = 21;
  inline bool has_child() const;
  inline void clear_child();
  static const int kChildFieldNumber = 21;
  inline ::google::protobuf::int32 child() const;
  inline void set_child(::google::protobuf::int32 value);
  
  // optional int32 sweepMoney = 22;
  inline bool has_sweepMoney() const;
  inline void clear_sweepMoney();
  static const int kSweepMoneyFieldNumber = 22;
  inline ::google::protobuf::int32 sweepMoney() const;
  inline void set_sweepMoney(::google::protobuf::int32 value);
  
  // optional bool elite = 23;
  inline bool has_elite() const;
  inline void clear_elite();
  static const int kEliteFieldNumber = 23;
  inline bool elite() const;
  inline void set_elite(bool value);
  
  // optional int32 requiredLevel = 24;
  inline bool has_requiredLevel() const;
  inline void clear_requiredLevel();
  static const int kRequiredLevelFieldNumber = 24;
  inline ::google::protobuf::int32 requiredLevel() const;
  inline void set_requiredLevel(::google::protobuf::int32 value);
  
  // optional .MapInfo.OpenNPCType openNpcType = 25;
  inline bool has_openNpcType() const;
  inline void clear_openNpcType();
  static const int kOpenNpcTypeFieldNumber = 25;
  inline ::MapInfo_OpenNPCType openNpcType() const;
  inline void set_openNpcType(::MapInfo_OpenNPCType value);
  
  // optional int32 minTime = 26;
  inline bool has_minTime() const;
  inline void clear_minTime();
  static const int kMinTimeFieldNumber = 26;
  inline ::google::protobuf::int32 minTime() const;
  inline void set_minTime(::google::protobuf::int32 value);
  
  // optional int32 maxTime = 27;
  inline bool has_maxTime() const;
  inline void clear_maxTime();
  static const int kMaxTimeFieldNumber = 27;
  inline ::google::protobuf::int32 maxTime() const;
  inline void set_maxTime(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:MapInfo)
 private:
  inline void set_has_mapType();
  inline void clear_has_mapType();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_requireMission();
  inline void clear_has_requireMission();
  inline void set_has_freeBox();
  inline void clear_has_freeBox();
  inline void set_has_gemBox();
  inline void clear_has_gemBox();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_honor();
  inline void clear_has_honor();
  inline void set_has_requiredPower();
  inline void clear_has_requiredPower();
  inline void set_has_durability();
  inline void clear_has_durability();
  inline void set_has_awardType();
  inline void clear_has_awardType();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_rmb();
  inline void clear_has_rmb();
  inline void set_has_soul();
  inline void clear_has_soul();
  inline void set_has_showBox();
  inline void clear_has_showBox();
  inline void set_has_smallSoulJade();
  inline void clear_has_smallSoulJade();
  inline void set_has_soulStone();
  inline void clear_has_soulStone();
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_child();
  inline void clear_has_child();
  inline void set_has_sweepMoney();
  inline void clear_has_sweepMoney();
  inline void set_has_elite();
  inline void clear_has_elite();
  inline void set_has_requiredLevel();
  inline void clear_has_requiredLevel();
  inline void set_has_openNpcType();
  inline void clear_has_openNpcType();
  inline void set_has_minTime();
  inline void clear_has_minTime();
  inline void set_has_maxTime();
  inline void clear_has_maxTime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int mapType_;
  ::google::protobuf::int32 id_;
  ::std::string* name_;
  ::std::string* desc_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > sceneAudio_;
  ::google::protobuf::int32 requireMission_;
  ::google::protobuf::int32 freeBox_;
  ::google::protobuf::int32 gemBox_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 honor_;
  ::google::protobuf::int32 requiredPower_;
  ::google::protobuf::int32 durability_;
  int awardType_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 rmb_;
  ::google::protobuf::int32 soul_;
  ::google::protobuf::int32 showBox_;
  ::google::protobuf::int32 smallSoulJade_;
  ::google::protobuf::int32 soulStone_;
  ::google::protobuf::int32 parent_;
  ::google::protobuf::int32 child_;
  ::google::protobuf::int32 sweepMoney_;
  bool elite_;
  ::google::protobuf::int32 requiredLevel_;
  int openNpcType_;
  ::google::protobuf::int32 minTime_;
  ::google::protobuf::int32 maxTime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static MapInfo* default_instance_;
};
// -------------------------------------------------------------------

class AllMapInfo : public ::google::protobuf::Message {
 public:
  AllMapInfo();
  virtual ~AllMapInfo();
  
  AllMapInfo(const AllMapInfo& from);
  
  inline AllMapInfo& operator=(const AllMapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllMapInfo& default_instance();
  
  void Swap(AllMapInfo* other);
  
  // implements Message ----------------------------------------------
  
  AllMapInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllMapInfo& from);
  void MergeFrom(const AllMapInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MapInfo mapInfo = 1;
  inline int mapInfo_size() const;
  inline void clear_mapInfo();
  static const int kMapInfoFieldNumber = 1;
  inline const ::MapInfo& mapInfo(int index) const;
  inline ::MapInfo* mutable_mapInfo(int index);
  inline ::MapInfo* add_mapInfo();
  inline const ::google::protobuf::RepeatedPtrField< ::MapInfo >&
      mapInfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapInfo >*
      mutable_mapInfo();
  
  // @@protoc_insertion_point(class_scope:AllMapInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::MapInfo > mapInfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AllMapInfo* default_instance_;
};
// -------------------------------------------------------------------

class BlockInfo : public ::google::protobuf::Message {
 public:
  BlockInfo();
  virtual ~BlockInfo();
  
  BlockInfo(const BlockInfo& from);
  
  inline BlockInfo& operator=(const BlockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockInfo& default_instance();
  
  void Swap(BlockInfo* other);
  
  // implements Message ----------------------------------------------
  
  BlockInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockInfo& from);
  void MergeFrom(const BlockInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef BlockInfo_BlockType BlockType;
  static const BlockType DEFAULT = BlockInfo_BlockType_DEFAULT;
  static const BlockType UNWALKABLE = BlockInfo_BlockType_UNWALKABLE;
  static const BlockType UNWALKABLE_UNSKILL = BlockInfo_BlockType_UNWALKABLE_UNSKILL;
  static inline bool BlockType_IsValid(int value) {
    return BlockInfo_BlockType_IsValid(value);
  }
  static const BlockType BlockType_MIN =
    BlockInfo_BlockType_BlockType_MIN;
  static const BlockType BlockType_MAX =
    BlockInfo_BlockType_BlockType_MAX;
  static const int BlockType_ARRAYSIZE =
    BlockInfo_BlockType_BlockType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BlockType_descriptor() {
    return BlockInfo_BlockType_descriptor();
  }
  static inline const ::std::string& BlockType_Name(BlockType value) {
    return BlockInfo_BlockType_Name(value);
  }
  static inline bool BlockType_Parse(const ::std::string& name,
      BlockType* value) {
    return BlockInfo_BlockType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // repeated .BlockInfo.BlockType blockTypes = 2;
  inline int blockTypes_size() const;
  inline void clear_blockTypes();
  static const int kBlockTypesFieldNumber = 2;
  inline ::BlockInfo_BlockType blockTypes(int index) const;
  inline void set_blockTypes(int index, ::BlockInfo_BlockType value);
  inline void add_blockTypes(::BlockInfo_BlockType value);
  inline const ::google::protobuf::RepeatedField<int>& blockTypes() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_blockTypes();
  
  // optional int32 realLength = 3;
  inline bool has_realLength() const;
  inline void clear_realLength();
  static const int kRealLengthFieldNumber = 3;
  inline ::google::protobuf::int32 realLength() const;
  inline void set_realLength(::google::protobuf::int32 value);
  
  // optional int32 realWidth = 4;
  inline bool has_realWidth() const;
  inline void clear_realWidth();
  static const int kRealWidthFieldNumber = 4;
  inline ::google::protobuf::int32 realWidth() const;
  inline void set_realWidth(::google::protobuf::int32 value);
  
  // optional int32 logicLength = 5;
  inline bool has_logicLength() const;
  inline void clear_logicLength();
  static const int kLogicLengthFieldNumber = 5;
  inline ::google::protobuf::int32 logicLength() const;
  inline void set_logicLength(::google::protobuf::int32 value);
  
  // optional int32 logicWidth = 6;
  inline bool has_logicWidth() const;
  inline void clear_logicWidth();
  static const int kLogicWidthFieldNumber = 6;
  inline ::google::protobuf::int32 logicWidth() const;
  inline void set_logicWidth(::google::protobuf::int32 value);
  
  // repeated int32 obstacles = 7;
  inline int obstacles_size() const;
  inline void clear_obstacles();
  static const int kObstaclesFieldNumber = 7;
  inline ::google::protobuf::int32 obstacles(int index) const;
  inline void set_obstacles(int index, ::google::protobuf::int32 value);
  inline void add_obstacles(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      obstacles() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_obstacles();
  
  // @@protoc_insertion_point(class_scope:BlockInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_realLength();
  inline void clear_has_realLength();
  inline void set_has_realWidth();
  inline void clear_has_realWidth();
  inline void set_has_logicLength();
  inline void clear_has_logicLength();
  inline void set_has_logicWidth();
  inline void clear_has_logicWidth();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField<int> blockTypes_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 realLength_;
  ::google::protobuf::int32 realWidth_;
  ::google::protobuf::int32 logicLength_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > obstacles_;
  ::google::protobuf::int32 logicWidth_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_MapInfo_2eproto();
  friend void protobuf_AssignDesc_MapInfo_2eproto();
  friend void protobuf_ShutdownFile_MapInfo_2eproto();
  
  void InitAsDefaultInstance();
  static BlockInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// NPCSceneUnit

// optional int32 id = 1;
inline bool NPCSceneUnit::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NPCSceneUnit::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NPCSceneUnit::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NPCSceneUnit::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NPCSceneUnit::id() const {
  return id_;
}
inline void NPCSceneUnit::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .PB_Vector2i coord = 2;
inline bool NPCSceneUnit::has_coord() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NPCSceneUnit::set_has_coord() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NPCSceneUnit::clear_has_coord() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NPCSceneUnit::clear_coord() {
  if (coord_ != NULL) coord_->::PB_Vector2i::Clear();
  clear_has_coord();
}
inline const ::PB_Vector2i& NPCSceneUnit::coord() const {
  return coord_ != NULL ? *coord_ : *default_instance_->coord_;
}
inline ::PB_Vector2i* NPCSceneUnit::mutable_coord() {
  set_has_coord();
  if (coord_ == NULL) coord_ = new ::PB_Vector2i;
  return coord_;
}
inline ::PB_Vector2i* NPCSceneUnit::release_coord() {
  clear_has_coord();
  ::PB_Vector2i* temp = coord_;
  coord_ = NULL;
  return temp;
}

// optional int32 resID = 3;
inline bool NPCSceneUnit::has_resID() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NPCSceneUnit::set_has_resID() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NPCSceneUnit::clear_has_resID() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NPCSceneUnit::clear_resID() {
  resID_ = 0;
  clear_has_resID();
}
inline ::google::protobuf::int32 NPCSceneUnit::resID() const {
  return resID_;
}
inline void NPCSceneUnit::set_resID(::google::protobuf::int32 value) {
  set_has_resID();
  resID_ = value;
}

// optional .PB_Vector3f rotation = 4;
inline bool NPCSceneUnit::has_rotation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NPCSceneUnit::set_has_rotation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NPCSceneUnit::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NPCSceneUnit::clear_rotation() {
  if (rotation_ != NULL) rotation_->::PB_Vector3f::Clear();
  clear_has_rotation();
}
inline const ::PB_Vector3f& NPCSceneUnit::rotation() const {
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::PB_Vector3f* NPCSceneUnit::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::PB_Vector3f;
  return rotation_;
}
inline ::PB_Vector3f* NPCSceneUnit::release_rotation() {
  clear_has_rotation();
  ::PB_Vector3f* temp = rotation_;
  rotation_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// JumpPointInfo

// optional int32 id = 1;
inline bool JumpPointInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JumpPointInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JumpPointInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JumpPointInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 JumpPointInfo::id() const {
  return id_;
}
inline void JumpPointInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .PB_Vector2i enterCoord = 2;
inline bool JumpPointInfo::has_enterCoord() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JumpPointInfo::set_has_enterCoord() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JumpPointInfo::clear_has_enterCoord() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JumpPointInfo::clear_enterCoord() {
  if (enterCoord_ != NULL) enterCoord_->::PB_Vector2i::Clear();
  clear_has_enterCoord();
}
inline const ::PB_Vector2i& JumpPointInfo::enterCoord() const {
  return enterCoord_ != NULL ? *enterCoord_ : *default_instance_->enterCoord_;
}
inline ::PB_Vector2i* JumpPointInfo::mutable_enterCoord() {
  set_has_enterCoord();
  if (enterCoord_ == NULL) enterCoord_ = new ::PB_Vector2i;
  return enterCoord_;
}
inline ::PB_Vector2i* JumpPointInfo::release_enterCoord() {
  clear_has_enterCoord();
  ::PB_Vector2i* temp = enterCoord_;
  enterCoord_ = NULL;
  return temp;
}

// optional int32 nextMap = 3;
inline bool JumpPointInfo::has_nextMap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JumpPointInfo::set_has_nextMap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JumpPointInfo::clear_has_nextMap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JumpPointInfo::clear_nextMap() {
  nextMap_ = 0;
  clear_has_nextMap();
}
inline ::google::protobuf::int32 JumpPointInfo::nextMap() const {
  return nextMap_;
}
inline void JumpPointInfo::set_nextMap(::google::protobuf::int32 value) {
  set_has_nextMap();
  nextMap_ = value;
}

// optional int32 nextPoint = 4;
inline bool JumpPointInfo::has_nextPoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JumpPointInfo::set_has_nextPoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JumpPointInfo::clear_has_nextPoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JumpPointInfo::clear_nextPoint() {
  nextPoint_ = 0;
  clear_has_nextPoint();
}
inline ::google::protobuf::int32 JumpPointInfo::nextPoint() const {
  return nextPoint_;
}
inline void JumpPointInfo::set_nextPoint(::google::protobuf::int32 value) {
  set_has_nextPoint();
  nextPoint_ = value;
}

// optional .PB_Vector2i coord = 5;
inline bool JumpPointInfo::has_coord() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JumpPointInfo::set_has_coord() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JumpPointInfo::clear_has_coord() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JumpPointInfo::clear_coord() {
  if (coord_ != NULL) coord_->::PB_Vector2i::Clear();
  clear_has_coord();
}
inline const ::PB_Vector2i& JumpPointInfo::coord() const {
  return coord_ != NULL ? *coord_ : *default_instance_->coord_;
}
inline ::PB_Vector2i* JumpPointInfo::mutable_coord() {
  set_has_coord();
  if (coord_ == NULL) coord_ = new ::PB_Vector2i;
  return coord_;
}
inline ::PB_Vector2i* JumpPointInfo::release_coord() {
  clear_has_coord();
  ::PB_Vector2i* temp = coord_;
  coord_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// JumpTableInfo

// repeated .JumpPointInfo table = 1;
inline int JumpTableInfo::table_size() const {
  return table_.size();
}
inline void JumpTableInfo::clear_table() {
  table_.Clear();
}
inline const ::JumpPointInfo& JumpTableInfo::table(int index) const {
  return table_.Get(index);
}
inline ::JumpPointInfo* JumpTableInfo::mutable_table(int index) {
  return table_.Mutable(index);
}
inline ::JumpPointInfo* JumpTableInfo::add_table() {
  return table_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::JumpPointInfo >&
JumpTableInfo::table() const {
  return table_;
}
inline ::google::protobuf::RepeatedPtrField< ::JumpPointInfo >*
JumpTableInfo::mutable_table() {
  return &table_;
}

// -------------------------------------------------------------------

// AudioItemInfo

// optional string audioID = 1;
inline bool AudioItemInfo::has_audioID() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioItemInfo::set_has_audioID() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioItemInfo::clear_has_audioID() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioItemInfo::clear_audioID() {
  if (audioID_ != &::google::protobuf::internal::kEmptyString) {
    audioID_->clear();
  }
  clear_has_audioID();
}
inline const ::std::string& AudioItemInfo::audioID() const {
  return *audioID_;
}
inline void AudioItemInfo::set_audioID(const ::std::string& value) {
  set_has_audioID();
  if (audioID_ == &::google::protobuf::internal::kEmptyString) {
    audioID_ = new ::std::string;
  }
  audioID_->assign(value);
}
inline void AudioItemInfo::set_audioID(const char* value) {
  set_has_audioID();
  if (audioID_ == &::google::protobuf::internal::kEmptyString) {
    audioID_ = new ::std::string;
  }
  audioID_->assign(value);
}
inline void AudioItemInfo::set_audioID(const char* value, size_t size) {
  set_has_audioID();
  if (audioID_ == &::google::protobuf::internal::kEmptyString) {
    audioID_ = new ::std::string;
  }
  audioID_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioItemInfo::mutable_audioID() {
  set_has_audioID();
  if (audioID_ == &::google::protobuf::internal::kEmptyString) {
    audioID_ = new ::std::string;
  }
  return audioID_;
}
inline ::std::string* AudioItemInfo::release_audioID() {
  clear_has_audioID();
  if (audioID_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = audioID_;
    audioID_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float volume = 2;
inline bool AudioItemInfo::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioItemInfo::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioItemInfo::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioItemInfo::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline float AudioItemInfo::volume() const {
  return volume_;
}
inline void AudioItemInfo::set_volume(float value) {
  set_has_volume();
  volume_ = value;
}

// optional float maxDistance = 3;
inline bool AudioItemInfo::has_maxDistance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioItemInfo::set_has_maxDistance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioItemInfo::clear_has_maxDistance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioItemInfo::clear_maxDistance() {
  maxDistance_ = 0;
  clear_has_maxDistance();
}
inline float AudioItemInfo::maxDistance() const {
  return maxDistance_;
}
inline void AudioItemInfo::set_maxDistance(float value) {
  set_has_maxDistance();
  maxDistance_ = value;
}

// optional int32 number = 4;
inline bool AudioItemInfo::has_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioItemInfo::set_has_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioItemInfo::clear_has_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioItemInfo::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 AudioItemInfo::number() const {
  return number_;
}
inline void AudioItemInfo::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// optional int32 minInterval = 5;
inline bool AudioItemInfo::has_minInterval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioItemInfo::set_has_minInterval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AudioItemInfo::clear_has_minInterval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AudioItemInfo::clear_minInterval() {
  minInterval_ = 0;
  clear_has_minInterval();
}
inline ::google::protobuf::int32 AudioItemInfo::minInterval() const {
  return minInterval_;
}
inline void AudioItemInfo::set_minInterval(::google::protobuf::int32 value) {
  set_has_minInterval();
  minInterval_ = value;
}

// optional int32 delay = 6;
inline bool AudioItemInfo::has_delay() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AudioItemInfo::set_has_delay() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AudioItemInfo::clear_has_delay() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AudioItemInfo::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline ::google::protobuf::int32 AudioItemInfo::delay() const {
  return delay_;
}
inline void AudioItemInfo::set_delay(::google::protobuf::int32 value) {
  set_has_delay();
  delay_ = value;
}

// optional .PB_Vector3f position = 7;
inline bool AudioItemInfo::has_position() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AudioItemInfo::set_has_position() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AudioItemInfo::clear_has_position() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AudioItemInfo::clear_position() {
  if (position_ != NULL) position_->::PB_Vector3f::Clear();
  clear_has_position();
}
inline const ::PB_Vector3f& AudioItemInfo::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::PB_Vector3f* AudioItemInfo::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::PB_Vector3f;
  return position_;
}
inline ::PB_Vector3f* AudioItemInfo::release_position() {
  clear_has_position();
  ::PB_Vector3f* temp = position_;
  position_ = NULL;
  return temp;
}

// optional int32 maxInterval = 8;
inline bool AudioItemInfo::has_maxInterval() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AudioItemInfo::set_has_maxInterval() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AudioItemInfo::clear_has_maxInterval() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AudioItemInfo::clear_maxInterval() {
  maxInterval_ = 0;
  clear_has_maxInterval();
}
inline ::google::protobuf::int32 AudioItemInfo::maxInterval() const {
  return maxInterval_;
}
inline void AudioItemInfo::set_maxInterval(::google::protobuf::int32 value) {
  set_has_maxInterval();
  maxInterval_ = value;
}

// -------------------------------------------------------------------

// NPCPass

// repeated int32 npcs = 1;
inline int NPCPass::npcs_size() const {
  return npcs_.size();
}
inline void NPCPass::clear_npcs() {
  npcs_.Clear();
}
inline ::google::protobuf::int32 NPCPass::npcs(int index) const {
  return npcs_.Get(index);
}
inline void NPCPass::set_npcs(int index, ::google::protobuf::int32 value) {
  npcs_.Set(index, value);
}
inline void NPCPass::add_npcs(::google::protobuf::int32 value) {
  npcs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NPCPass::npcs() const {
  return npcs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NPCPass::mutable_npcs() {
  return &npcs_;
}

// optional int32 delay = 2;
inline bool NPCPass::has_delay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NPCPass::set_has_delay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NPCPass::clear_has_delay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NPCPass::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline ::google::protobuf::int32 NPCPass::delay() const {
  return delay_;
}
inline void NPCPass::set_delay(::google::protobuf::int32 value) {
  set_has_delay();
  delay_ = value;
}

// -------------------------------------------------------------------

// NPCGroup

// repeated .NPCPass pass = 1;
inline int NPCGroup::pass_size() const {
  return pass_.size();
}
inline void NPCGroup::clear_pass() {
  pass_.Clear();
}
inline const ::NPCPass& NPCGroup::pass(int index) const {
  return pass_.Get(index);
}
inline ::NPCPass* NPCGroup::mutable_pass(int index) {
  return pass_.Mutable(index);
}
inline ::NPCPass* NPCGroup::add_pass() {
  return pass_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NPCPass >&
NPCGroup::pass() const {
  return pass_;
}
inline ::google::protobuf::RepeatedPtrField< ::NPCPass >*
NPCGroup::mutable_pass() {
  return &pass_;
}

// -------------------------------------------------------------------

// PathNode

// optional int32 id = 1;
inline bool PathNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathNode::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 PathNode::id() const {
  return id_;
}
inline void PathNode::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .PathNode.Type type = 2;
inline bool PathNode::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathNode::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathNode::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathNode::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::PathNode_Type PathNode::type() const {
  return static_cast< ::PathNode_Type >(type_);
}
inline void PathNode::set_type(::PathNode_Type value) {
  GOOGLE_DCHECK(::PathNode_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated int32 next = 3;
inline int PathNode::next_size() const {
  return next_.size();
}
inline void PathNode::clear_next() {
  next_.Clear();
}
inline ::google::protobuf::int32 PathNode::next(int index) const {
  return next_.Get(index);
}
inline void PathNode::set_next(int index, ::google::protobuf::int32 value) {
  next_.Set(index, value);
}
inline void PathNode::add_next(::google::protobuf::int32 value) {
  next_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PathNode::next() const {
  return next_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PathNode::mutable_next() {
  return &next_;
}

// optional .PB_Vector3f pos = 4;
inline bool PathNode::has_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PathNode::set_has_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PathNode::clear_has_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PathNode::clear_pos() {
  if (pos_ != NULL) pos_->::PB_Vector3f::Clear();
  clear_has_pos();
}
inline const ::PB_Vector3f& PathNode::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::PB_Vector3f* PathNode::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::PB_Vector3f;
  return pos_;
}
inline ::PB_Vector3f* PathNode::release_pos() {
  clear_has_pos();
  ::PB_Vector3f* temp = pos_;
  pos_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ObstacleTriggerInfo

// optional int32 openType = 1;
inline bool ObstacleTriggerInfo::has_openType() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObstacleTriggerInfo::set_has_openType() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObstacleTriggerInfo::clear_has_openType() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObstacleTriggerInfo::clear_openType() {
  openType_ = 0;
  clear_has_openType();
}
inline ::google::protobuf::int32 ObstacleTriggerInfo::openType() const {
  return openType_;
}
inline void ObstacleTriggerInfo::set_openType(::google::protobuf::int32 value) {
  set_has_openType();
  openType_ = value;
}

// repeated int32 param = 2;
inline int ObstacleTriggerInfo::param_size() const {
  return param_.size();
}
inline void ObstacleTriggerInfo::clear_param() {
  param_.Clear();
}
inline ::google::protobuf::int32 ObstacleTriggerInfo::param(int index) const {
  return param_.Get(index);
}
inline void ObstacleTriggerInfo::set_param(int index, ::google::protobuf::int32 value) {
  param_.Set(index, value);
}
inline void ObstacleTriggerInfo::add_param(::google::protobuf::int32 value) {
  param_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ObstacleTriggerInfo::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ObstacleTriggerInfo::mutable_param() {
  return &param_;
}

// optional int32 id = 3;
inline bool ObstacleTriggerInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObstacleTriggerInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObstacleTriggerInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObstacleTriggerInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ObstacleTriggerInfo::id() const {
  return id_;
}
inline void ObstacleTriggerInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// MapUnit

// optional int32 id = 1;
inline bool MapUnit::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapUnit::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapUnit::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapUnit::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MapUnit::id() const {
  return id_;
}
inline void MapUnit::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .NPCSceneUnit npcs = 2;
inline int MapUnit::npcs_size() const {
  return npcs_.size();
}
inline void MapUnit::clear_npcs() {
  npcs_.Clear();
}
inline const ::NPCSceneUnit& MapUnit::npcs(int index) const {
  return npcs_.Get(index);
}
inline ::NPCSceneUnit* MapUnit::mutable_npcs(int index) {
  return npcs_.Mutable(index);
}
inline ::NPCSceneUnit* MapUnit::add_npcs() {
  return npcs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NPCSceneUnit >&
MapUnit::npcs() const {
  return npcs_;
}
inline ::google::protobuf::RepeatedPtrField< ::NPCSceneUnit >*
MapUnit::mutable_npcs() {
  return &npcs_;
}

// optional .JumpTableInfo jumpTable = 3;
inline bool MapUnit::has_jumpTable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapUnit::set_has_jumpTable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapUnit::clear_has_jumpTable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapUnit::clear_jumpTable() {
  if (jumpTable_ != NULL) jumpTable_->::JumpTableInfo::Clear();
  clear_has_jumpTable();
}
inline const ::JumpTableInfo& MapUnit::jumpTable() const {
  return jumpTable_ != NULL ? *jumpTable_ : *default_instance_->jumpTable_;
}
inline ::JumpTableInfo* MapUnit::mutable_jumpTable() {
  set_has_jumpTable();
  if (jumpTable_ == NULL) jumpTable_ = new ::JumpTableInfo;
  return jumpTable_;
}
inline ::JumpTableInfo* MapUnit::release_jumpTable() {
  clear_has_jumpTable();
  ::JumpTableInfo* temp = jumpTable_;
  jumpTable_ = NULL;
  return temp;
}

// repeated .AudioItemInfo audioItems = 4;
inline int MapUnit::audioItems_size() const {
  return audioItems_.size();
}
inline void MapUnit::clear_audioItems() {
  audioItems_.Clear();
}
inline const ::AudioItemInfo& MapUnit::audioItems(int index) const {
  return audioItems_.Get(index);
}
inline ::AudioItemInfo* MapUnit::mutable_audioItems(int index) {
  return audioItems_.Mutable(index);
}
inline ::AudioItemInfo* MapUnit::add_audioItems() {
  return audioItems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AudioItemInfo >&
MapUnit::audioItems() const {
  return audioItems_;
}
inline ::google::protobuf::RepeatedPtrField< ::AudioItemInfo >*
MapUnit::mutable_audioItems() {
  return &audioItems_;
}

// optional int32 resID = 5;
inline bool MapUnit::has_resID() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapUnit::set_has_resID() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapUnit::clear_has_resID() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapUnit::clear_resID() {
  resID_ = 0;
  clear_has_resID();
}
inline ::google::protobuf::int32 MapUnit::resID() const {
  return resID_;
}
inline void MapUnit::set_resID(::google::protobuf::int32 value) {
  set_has_resID();
  resID_ = value;
}

// repeated .NPCGroup npcGroups = 6;
inline int MapUnit::npcGroups_size() const {
  return npcGroups_.size();
}
inline void MapUnit::clear_npcGroups() {
  npcGroups_.Clear();
}
inline const ::NPCGroup& MapUnit::npcGroups(int index) const {
  return npcGroups_.Get(index);
}
inline ::NPCGroup* MapUnit::mutable_npcGroups(int index) {
  return npcGroups_.Mutable(index);
}
inline ::NPCGroup* MapUnit::add_npcGroups() {
  return npcGroups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NPCGroup >&
MapUnit::npcGroups() const {
  return npcGroups_;
}
inline ::google::protobuf::RepeatedPtrField< ::NPCGroup >*
MapUnit::mutable_npcGroups() {
  return &npcGroups_;
}

// optional int32 boss = 7 [default = -1];
inline bool MapUnit::has_boss() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapUnit::set_has_boss() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapUnit::clear_has_boss() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapUnit::clear_boss() {
  boss_ = -1;
  clear_has_boss();
}
inline ::google::protobuf::int32 MapUnit::boss() const {
  return boss_;
}
inline void MapUnit::set_boss(::google::protobuf::int32 value) {
  set_has_boss();
  boss_ = value;
}

// optional .MapUnit.SceneType sceneType = 8;
inline bool MapUnit::has_sceneType() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapUnit::set_has_sceneType() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapUnit::clear_has_sceneType() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapUnit::clear_sceneType() {
  sceneType_ = 0;
  clear_has_sceneType();
}
inline ::MapUnit_SceneType MapUnit::sceneType() const {
  return static_cast< ::MapUnit_SceneType >(sceneType_);
}
inline void MapUnit::set_sceneType(::MapUnit_SceneType value) {
  GOOGLE_DCHECK(::MapUnit_SceneType_IsValid(value));
  set_has_sceneType();
  sceneType_ = value;
}

// repeated .PathNode path = 9;
inline int MapUnit::path_size() const {
  return path_.size();
}
inline void MapUnit::clear_path() {
  path_.Clear();
}
inline const ::PathNode& MapUnit::path(int index) const {
  return path_.Get(index);
}
inline ::PathNode* MapUnit::mutable_path(int index) {
  return path_.Mutable(index);
}
inline ::PathNode* MapUnit::add_path() {
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PathNode >&
MapUnit::path() const {
  return path_;
}
inline ::google::protobuf::RepeatedPtrField< ::PathNode >*
MapUnit::mutable_path() {
  return &path_;
}

// optional int32 protectNPC = 10 [default = -1];
inline bool MapUnit::has_protectNPC() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MapUnit::set_has_protectNPC() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MapUnit::clear_has_protectNPC() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MapUnit::clear_protectNPC() {
  protectNPC_ = -1;
  clear_has_protectNPC();
}
inline ::google::protobuf::int32 MapUnit::protectNPC() const {
  return protectNPC_;
}
inline void MapUnit::set_protectNPC(::google::protobuf::int32 value) {
  set_has_protectNPC();
  protectNPC_ = value;
}

// optional int32 targetNode = 11 [default = -1];
inline bool MapUnit::has_targetNode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MapUnit::set_has_targetNode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MapUnit::clear_has_targetNode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MapUnit::clear_targetNode() {
  targetNode_ = -1;
  clear_has_targetNode();
}
inline ::google::protobuf::int32 MapUnit::targetNode() const {
  return targetNode_;
}
inline void MapUnit::set_targetNode(::google::protobuf::int32 value) {
  set_has_targetNode();
  targetNode_ = value;
}

// repeated .ObstacleTriggerInfo obstacleTriggerInfo = 12;
inline int MapUnit::obstacleTriggerInfo_size() const {
  return obstacleTriggerInfo_.size();
}
inline void MapUnit::clear_obstacleTriggerInfo() {
  obstacleTriggerInfo_.Clear();
}
inline const ::ObstacleTriggerInfo& MapUnit::obstacleTriggerInfo(int index) const {
  return obstacleTriggerInfo_.Get(index);
}
inline ::ObstacleTriggerInfo* MapUnit::mutable_obstacleTriggerInfo(int index) {
  return obstacleTriggerInfo_.Mutable(index);
}
inline ::ObstacleTriggerInfo* MapUnit::add_obstacleTriggerInfo() {
  return obstacleTriggerInfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ObstacleTriggerInfo >&
MapUnit::obstacleTriggerInfo() const {
  return obstacleTriggerInfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::ObstacleTriggerInfo >*
MapUnit::mutable_obstacleTriggerInfo() {
  return &obstacleTriggerInfo_;
}

// repeated int32 friendlyNpc = 13;
inline int MapUnit::friendlyNpc_size() const {
  return friendlyNpc_.size();
}
inline void MapUnit::clear_friendlyNpc() {
  friendlyNpc_.Clear();
}
inline ::google::protobuf::int32 MapUnit::friendlyNpc(int index) const {
  return friendlyNpc_.Get(index);
}
inline void MapUnit::set_friendlyNpc(int index, ::google::protobuf::int32 value) {
  friendlyNpc_.Set(index, value);
}
inline void MapUnit::add_friendlyNpc(::google::protobuf::int32 value) {
  friendlyNpc_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MapUnit::friendlyNpc() const {
  return friendlyNpc_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MapUnit::mutable_friendlyNpc() {
  return &friendlyNpc_;
}

// repeated .PB_Vector3f freeCoords = 14;
inline int MapUnit::freeCoords_size() const {
  return freeCoords_.size();
}
inline void MapUnit::clear_freeCoords() {
  freeCoords_.Clear();
}
inline const ::PB_Vector3f& MapUnit::freeCoords(int index) const {
  return freeCoords_.Get(index);
}
inline ::PB_Vector3f* MapUnit::mutable_freeCoords(int index) {
  return freeCoords_.Mutable(index);
}
inline ::PB_Vector3f* MapUnit::add_freeCoords() {
  return freeCoords_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PB_Vector3f >&
MapUnit::freeCoords() const {
  return freeCoords_;
}
inline ::google::protobuf::RepeatedPtrField< ::PB_Vector3f >*
MapUnit::mutable_freeCoords() {
  return &freeCoords_;
}

// optional int32 enemyTargetNode = 15;
inline bool MapUnit::has_enemyTargetNode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MapUnit::set_has_enemyTargetNode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MapUnit::clear_has_enemyTargetNode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MapUnit::clear_enemyTargetNode() {
  enemyTargetNode_ = 0;
  clear_has_enemyTargetNode();
}
inline ::google::protobuf::int32 MapUnit::enemyTargetNode() const {
  return enemyTargetNode_;
}
inline void MapUnit::set_enemyTargetNode(::google::protobuf::int32 value) {
  set_has_enemyTargetNode();
  enemyTargetNode_ = value;
}

// repeated int32 heroNPC = 16;
inline int MapUnit::heroNPC_size() const {
  return heroNPC_.size();
}
inline void MapUnit::clear_heroNPC() {
  heroNPC_.Clear();
}
inline ::google::protobuf::int32 MapUnit::heroNPC(int index) const {
  return heroNPC_.Get(index);
}
inline void MapUnit::set_heroNPC(int index, ::google::protobuf::int32 value) {
  heroNPC_.Set(index, value);
}
inline void MapUnit::add_heroNPC(::google::protobuf::int32 value) {
  heroNPC_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MapUnit::heroNPC() const {
  return heroNPC_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MapUnit::mutable_heroNPC() {
  return &heroNPC_;
}

// repeated int32 ourRecoverHPNode = 17;
inline int MapUnit::ourRecoverHPNode_size() const {
  return ourRecoverHPNode_.size();
}
inline void MapUnit::clear_ourRecoverHPNode() {
  ourRecoverHPNode_.Clear();
}
inline ::google::protobuf::int32 MapUnit::ourRecoverHPNode(int index) const {
  return ourRecoverHPNode_.Get(index);
}
inline void MapUnit::set_ourRecoverHPNode(int index, ::google::protobuf::int32 value) {
  ourRecoverHPNode_.Set(index, value);
}
inline void MapUnit::add_ourRecoverHPNode(::google::protobuf::int32 value) {
  ourRecoverHPNode_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MapUnit::ourRecoverHPNode() const {
  return ourRecoverHPNode_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MapUnit::mutable_ourRecoverHPNode() {
  return &ourRecoverHPNode_;
}

// repeated int32 enemyRecoverHPNode = 18;
inline int MapUnit::enemyRecoverHPNode_size() const {
  return enemyRecoverHPNode_.size();
}
inline void MapUnit::clear_enemyRecoverHPNode() {
  enemyRecoverHPNode_.Clear();
}
inline ::google::protobuf::int32 MapUnit::enemyRecoverHPNode(int index) const {
  return enemyRecoverHPNode_.Get(index);
}
inline void MapUnit::set_enemyRecoverHPNode(int index, ::google::protobuf::int32 value) {
  enemyRecoverHPNode_.Set(index, value);
}
inline void MapUnit::add_enemyRecoverHPNode(::google::protobuf::int32 value) {
  enemyRecoverHPNode_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MapUnit::enemyRecoverHPNode() const {
  return enemyRecoverHPNode_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MapUnit::mutable_enemyRecoverHPNode() {
  return &enemyRecoverHPNode_;
}

// -------------------------------------------------------------------

// MapInfo

// optional .MapInfo.MapType mapType = 1;
inline bool MapInfo::has_mapType() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapInfo::set_has_mapType() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapInfo::clear_has_mapType() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapInfo::clear_mapType() {
  mapType_ = 0;
  clear_has_mapType();
}
inline ::MapInfo_MapType MapInfo::mapType() const {
  return static_cast< ::MapInfo_MapType >(mapType_);
}
inline void MapInfo::set_mapType(::MapInfo_MapType value) {
  GOOGLE_DCHECK(::MapInfo_MapType_IsValid(value));
  set_has_mapType();
  mapType_ = value;
}

// optional int32 id = 2;
inline bool MapInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MapInfo::id() const {
  return id_;
}
inline void MapInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 3;
inline bool MapInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MapInfo::name() const {
  return *name_;
}
inline void MapInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MapInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MapInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MapInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string desc = 4;
inline bool MapInfo::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapInfo::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapInfo::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapInfo::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& MapInfo::desc() const {
  return *desc_;
}
inline void MapInfo::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void MapInfo::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void MapInfo::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapInfo::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* MapInfo::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 requireMission = 5;
inline bool MapInfo::has_requireMission() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapInfo::set_has_requireMission() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapInfo::clear_has_requireMission() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapInfo::clear_requireMission() {
  requireMission_ = 0;
  clear_has_requireMission();
}
inline ::google::protobuf::int32 MapInfo::requireMission() const {
  return requireMission_;
}
inline void MapInfo::set_requireMission(::google::protobuf::int32 value) {
  set_has_requireMission();
  requireMission_ = value;
}

// repeated int32 sceneAudio = 6;
inline int MapInfo::sceneAudio_size() const {
  return sceneAudio_.size();
}
inline void MapInfo::clear_sceneAudio() {
  sceneAudio_.Clear();
}
inline ::google::protobuf::int32 MapInfo::sceneAudio(int index) const {
  return sceneAudio_.Get(index);
}
inline void MapInfo::set_sceneAudio(int index, ::google::protobuf::int32 value) {
  sceneAudio_.Set(index, value);
}
inline void MapInfo::add_sceneAudio(::google::protobuf::int32 value) {
  sceneAudio_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MapInfo::sceneAudio() const {
  return sceneAudio_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MapInfo::mutable_sceneAudio() {
  return &sceneAudio_;
}

// optional int32 freeBox = 7;
inline bool MapInfo::has_freeBox() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapInfo::set_has_freeBox() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapInfo::clear_has_freeBox() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapInfo::clear_freeBox() {
  freeBox_ = 0;
  clear_has_freeBox();
}
inline ::google::protobuf::int32 MapInfo::freeBox() const {
  return freeBox_;
}
inline void MapInfo::set_freeBox(::google::protobuf::int32 value) {
  set_has_freeBox();
  freeBox_ = value;
}

// optional int32 gemBox = 8;
inline bool MapInfo::has_gemBox() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapInfo::set_has_gemBox() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapInfo::clear_has_gemBox() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapInfo::clear_gemBox() {
  gemBox_ = 0;
  clear_has_gemBox();
}
inline ::google::protobuf::int32 MapInfo::gemBox() const {
  return gemBox_;
}
inline void MapInfo::set_gemBox(::google::protobuf::int32 value) {
  set_has_gemBox();
  gemBox_ = value;
}

// optional int32 exp = 9;
inline bool MapInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MapInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MapInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MapInfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 MapInfo::exp() const {
  return exp_;
}
inline void MapInfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 honor = 10;
inline bool MapInfo::has_honor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MapInfo::set_has_honor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MapInfo::clear_has_honor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MapInfo::clear_honor() {
  honor_ = 0;
  clear_has_honor();
}
inline ::google::protobuf::int32 MapInfo::honor() const {
  return honor_;
}
inline void MapInfo::set_honor(::google::protobuf::int32 value) {
  set_has_honor();
  honor_ = value;
}

// optional int32 requiredPower = 11;
inline bool MapInfo::has_requiredPower() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MapInfo::set_has_requiredPower() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MapInfo::clear_has_requiredPower() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MapInfo::clear_requiredPower() {
  requiredPower_ = 0;
  clear_has_requiredPower();
}
inline ::google::protobuf::int32 MapInfo::requiredPower() const {
  return requiredPower_;
}
inline void MapInfo::set_requiredPower(::google::protobuf::int32 value) {
  set_has_requiredPower();
  requiredPower_ = value;
}

// optional int32 durability = 12;
inline bool MapInfo::has_durability() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MapInfo::set_has_durability() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MapInfo::clear_has_durability() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MapInfo::clear_durability() {
  durability_ = 0;
  clear_has_durability();
}
inline ::google::protobuf::int32 MapInfo::durability() const {
  return durability_;
}
inline void MapInfo::set_durability(::google::protobuf::int32 value) {
  set_has_durability();
  durability_ = value;
}

// optional .MapInfo.AwardType awardType = 13;
inline bool MapInfo::has_awardType() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MapInfo::set_has_awardType() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MapInfo::clear_has_awardType() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MapInfo::clear_awardType() {
  awardType_ = 0;
  clear_has_awardType();
}
inline ::MapInfo_AwardType MapInfo::awardType() const {
  return static_cast< ::MapInfo_AwardType >(awardType_);
}
inline void MapInfo::set_awardType(::MapInfo_AwardType value) {
  GOOGLE_DCHECK(::MapInfo_AwardType_IsValid(value));
  set_has_awardType();
  awardType_ = value;
}

// optional int32 money = 14;
inline bool MapInfo::has_money() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MapInfo::set_has_money() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MapInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MapInfo::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 MapInfo::money() const {
  return money_;
}
inline void MapInfo::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 rmb = 15;
inline bool MapInfo::has_rmb() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MapInfo::set_has_rmb() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MapInfo::clear_has_rmb() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MapInfo::clear_rmb() {
  rmb_ = 0;
  clear_has_rmb();
}
inline ::google::protobuf::int32 MapInfo::rmb() const {
  return rmb_;
}
inline void MapInfo::set_rmb(::google::protobuf::int32 value) {
  set_has_rmb();
  rmb_ = value;
}

// optional int32 soul = 16;
inline bool MapInfo::has_soul() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MapInfo::set_has_soul() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MapInfo::clear_has_soul() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MapInfo::clear_soul() {
  soul_ = 0;
  clear_has_soul();
}
inline ::google::protobuf::int32 MapInfo::soul() const {
  return soul_;
}
inline void MapInfo::set_soul(::google::protobuf::int32 value) {
  set_has_soul();
  soul_ = value;
}

// optional int32 showBox = 17;
inline bool MapInfo::has_showBox() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MapInfo::set_has_showBox() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MapInfo::clear_has_showBox() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MapInfo::clear_showBox() {
  showBox_ = 0;
  clear_has_showBox();
}
inline ::google::protobuf::int32 MapInfo::showBox() const {
  return showBox_;
}
inline void MapInfo::set_showBox(::google::protobuf::int32 value) {
  set_has_showBox();
  showBox_ = value;
}

// optional int32 smallSoulJade = 18;
inline bool MapInfo::has_smallSoulJade() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MapInfo::set_has_smallSoulJade() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MapInfo::clear_has_smallSoulJade() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MapInfo::clear_smallSoulJade() {
  smallSoulJade_ = 0;
  clear_has_smallSoulJade();
}
inline ::google::protobuf::int32 MapInfo::smallSoulJade() const {
  return smallSoulJade_;
}
inline void MapInfo::set_smallSoulJade(::google::protobuf::int32 value) {
  set_has_smallSoulJade();
  smallSoulJade_ = value;
}

// optional int32 soulStone = 19;
inline bool MapInfo::has_soulStone() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MapInfo::set_has_soulStone() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MapInfo::clear_has_soulStone() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MapInfo::clear_soulStone() {
  soulStone_ = 0;
  clear_has_soulStone();
}
inline ::google::protobuf::int32 MapInfo::soulStone() const {
  return soulStone_;
}
inline void MapInfo::set_soulStone(::google::protobuf::int32 value) {
  set_has_soulStone();
  soulStone_ = value;
}

// optional int32 parent = 20;
inline bool MapInfo::has_parent() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MapInfo::set_has_parent() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MapInfo::clear_has_parent() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MapInfo::clear_parent() {
  parent_ = 0;
  clear_has_parent();
}
inline ::google::protobuf::int32 MapInfo::parent() const {
  return parent_;
}
inline void MapInfo::set_parent(::google::protobuf::int32 value) {
  set_has_parent();
  parent_ = value;
}

// optional int32 child = 21;
inline bool MapInfo::has_child() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MapInfo::set_has_child() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MapInfo::clear_has_child() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MapInfo::clear_child() {
  child_ = 0;
  clear_has_child();
}
inline ::google::protobuf::int32 MapInfo::child() const {
  return child_;
}
inline void MapInfo::set_child(::google::protobuf::int32 value) {
  set_has_child();
  child_ = value;
}

// optional int32 sweepMoney = 22;
inline bool MapInfo::has_sweepMoney() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MapInfo::set_has_sweepMoney() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MapInfo::clear_has_sweepMoney() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MapInfo::clear_sweepMoney() {
  sweepMoney_ = 0;
  clear_has_sweepMoney();
}
inline ::google::protobuf::int32 MapInfo::sweepMoney() const {
  return sweepMoney_;
}
inline void MapInfo::set_sweepMoney(::google::protobuf::int32 value) {
  set_has_sweepMoney();
  sweepMoney_ = value;
}

// optional bool elite = 23;
inline bool MapInfo::has_elite() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MapInfo::set_has_elite() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MapInfo::clear_has_elite() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MapInfo::clear_elite() {
  elite_ = false;
  clear_has_elite();
}
inline bool MapInfo::elite() const {
  return elite_;
}
inline void MapInfo::set_elite(bool value) {
  set_has_elite();
  elite_ = value;
}

// optional int32 requiredLevel = 24;
inline bool MapInfo::has_requiredLevel() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MapInfo::set_has_requiredLevel() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MapInfo::clear_has_requiredLevel() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MapInfo::clear_requiredLevel() {
  requiredLevel_ = 0;
  clear_has_requiredLevel();
}
inline ::google::protobuf::int32 MapInfo::requiredLevel() const {
  return requiredLevel_;
}
inline void MapInfo::set_requiredLevel(::google::protobuf::int32 value) {
  set_has_requiredLevel();
  requiredLevel_ = value;
}

// optional .MapInfo.OpenNPCType openNpcType = 25;
inline bool MapInfo::has_openNpcType() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MapInfo::set_has_openNpcType() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MapInfo::clear_has_openNpcType() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MapInfo::clear_openNpcType() {
  openNpcType_ = 0;
  clear_has_openNpcType();
}
inline ::MapInfo_OpenNPCType MapInfo::openNpcType() const {
  return static_cast< ::MapInfo_OpenNPCType >(openNpcType_);
}
inline void MapInfo::set_openNpcType(::MapInfo_OpenNPCType value) {
  GOOGLE_DCHECK(::MapInfo_OpenNPCType_IsValid(value));
  set_has_openNpcType();
  openNpcType_ = value;
}

// optional int32 minTime = 26;
inline bool MapInfo::has_minTime() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MapInfo::set_has_minTime() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MapInfo::clear_has_minTime() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MapInfo::clear_minTime() {
  minTime_ = 0;
  clear_has_minTime();
}
inline ::google::protobuf::int32 MapInfo::minTime() const {
  return minTime_;
}
inline void MapInfo::set_minTime(::google::protobuf::int32 value) {
  set_has_minTime();
  minTime_ = value;
}

// optional int32 maxTime = 27;
inline bool MapInfo::has_maxTime() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MapInfo::set_has_maxTime() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MapInfo::clear_has_maxTime() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MapInfo::clear_maxTime() {
  maxTime_ = 0;
  clear_has_maxTime();
}
inline ::google::protobuf::int32 MapInfo::maxTime() const {
  return maxTime_;
}
inline void MapInfo::set_maxTime(::google::protobuf::int32 value) {
  set_has_maxTime();
  maxTime_ = value;
}

// -------------------------------------------------------------------

// AllMapInfo

// repeated .MapInfo mapInfo = 1;
inline int AllMapInfo::mapInfo_size() const {
  return mapInfo_.size();
}
inline void AllMapInfo::clear_mapInfo() {
  mapInfo_.Clear();
}
inline const ::MapInfo& AllMapInfo::mapInfo(int index) const {
  return mapInfo_.Get(index);
}
inline ::MapInfo* AllMapInfo::mutable_mapInfo(int index) {
  return mapInfo_.Mutable(index);
}
inline ::MapInfo* AllMapInfo::add_mapInfo() {
  return mapInfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapInfo >&
AllMapInfo::mapInfo() const {
  return mapInfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapInfo >*
AllMapInfo::mutable_mapInfo() {
  return &mapInfo_;
}

// -------------------------------------------------------------------

// BlockInfo

// optional int32 id = 1;
inline bool BlockInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BlockInfo::id() const {
  return id_;
}
inline void BlockInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .BlockInfo.BlockType blockTypes = 2;
inline int BlockInfo::blockTypes_size() const {
  return blockTypes_.size();
}
inline void BlockInfo::clear_blockTypes() {
  blockTypes_.Clear();
}
inline ::BlockInfo_BlockType BlockInfo::blockTypes(int index) const {
  return static_cast< ::BlockInfo_BlockType >(blockTypes_.Get(index));
}
inline void BlockInfo::set_blockTypes(int index, ::BlockInfo_BlockType value) {
  GOOGLE_DCHECK(::BlockInfo_BlockType_IsValid(value));
  blockTypes_.Set(index, value);
}
inline void BlockInfo::add_blockTypes(::BlockInfo_BlockType value) {
  GOOGLE_DCHECK(::BlockInfo_BlockType_IsValid(value));
  blockTypes_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
BlockInfo::blockTypes() const {
  return blockTypes_;
}
inline ::google::protobuf::RepeatedField<int>*
BlockInfo::mutable_blockTypes() {
  return &blockTypes_;
}

// optional int32 realLength = 3;
inline bool BlockInfo::has_realLength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockInfo::set_has_realLength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockInfo::clear_has_realLength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockInfo::clear_realLength() {
  realLength_ = 0;
  clear_has_realLength();
}
inline ::google::protobuf::int32 BlockInfo::realLength() const {
  return realLength_;
}
inline void BlockInfo::set_realLength(::google::protobuf::int32 value) {
  set_has_realLength();
  realLength_ = value;
}

// optional int32 realWidth = 4;
inline bool BlockInfo::has_realWidth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlockInfo::set_has_realWidth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlockInfo::clear_has_realWidth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlockInfo::clear_realWidth() {
  realWidth_ = 0;
  clear_has_realWidth();
}
inline ::google::protobuf::int32 BlockInfo::realWidth() const {
  return realWidth_;
}
inline void BlockInfo::set_realWidth(::google::protobuf::int32 value) {
  set_has_realWidth();
  realWidth_ = value;
}

// optional int32 logicLength = 5;
inline bool BlockInfo::has_logicLength() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlockInfo::set_has_logicLength() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlockInfo::clear_has_logicLength() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlockInfo::clear_logicLength() {
  logicLength_ = 0;
  clear_has_logicLength();
}
inline ::google::protobuf::int32 BlockInfo::logicLength() const {
  return logicLength_;
}
inline void BlockInfo::set_logicLength(::google::protobuf::int32 value) {
  set_has_logicLength();
  logicLength_ = value;
}

// optional int32 logicWidth = 6;
inline bool BlockInfo::has_logicWidth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlockInfo::set_has_logicWidth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlockInfo::clear_has_logicWidth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlockInfo::clear_logicWidth() {
  logicWidth_ = 0;
  clear_has_logicWidth();
}
inline ::google::protobuf::int32 BlockInfo::logicWidth() const {
  return logicWidth_;
}
inline void BlockInfo::set_logicWidth(::google::protobuf::int32 value) {
  set_has_logicWidth();
  logicWidth_ = value;
}

// repeated int32 obstacles = 7;
inline int BlockInfo::obstacles_size() const {
  return obstacles_.size();
}
inline void BlockInfo::clear_obstacles() {
  obstacles_.Clear();
}
inline ::google::protobuf::int32 BlockInfo::obstacles(int index) const {
  return obstacles_.Get(index);
}
inline void BlockInfo::set_obstacles(int index, ::google::protobuf::int32 value) {
  obstacles_.Set(index, value);
}
inline void BlockInfo::add_obstacles(::google::protobuf::int32 value) {
  obstacles_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BlockInfo::obstacles() const {
  return obstacles_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BlockInfo::mutable_obstacles() {
  return &obstacles_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PathNode_Type>() {
  return ::PathNode_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ObstacleTriggerInfo_OpenType>() {
  return ::ObstacleTriggerInfo_OpenType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MapUnit_SceneType>() {
  return ::MapUnit_SceneType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MapInfo_MapType>() {
  return ::MapInfo_MapType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MapInfo_AwardType>() {
  return ::MapInfo_AwardType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MapInfo_OpenNPCType>() {
  return ::MapInfo_OpenNPCType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BlockInfo_BlockType>() {
  return ::BlockInfo_BlockType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MapInfo_2eproto__INCLUDED
