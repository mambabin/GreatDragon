// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Combat.proto

#ifndef PROTOBUF_Combat_2eproto__INCLUDED
#define PROTOBUF_Combat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Math.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Combat_2eproto();
void protobuf_AssignDesc_Combat_2eproto();
void protobuf_ShutdownFile_Combat_2eproto();

class CombatTurn;
class CombatRecord;

enum CombatTurn_Type {
  CombatTurn_Type_ROLE_ATTACK = 0,
  CombatTurn_Type_PET_ATTACK = 1,
  CombatTurn_Type_ATTACKED_ENERMY = 2,
  CombatTurn_Type_ATTACKED_ENERMYPET = 3,
  CombatTurn_Type_ATTACKED_NPC = 4,
  CombatTurn_Type_TRANSFORM = 5
};
bool CombatTurn_Type_IsValid(int value);
const CombatTurn_Type CombatTurn_Type_Type_MIN = CombatTurn_Type_ROLE_ATTACK;
const CombatTurn_Type CombatTurn_Type_Type_MAX = CombatTurn_Type_TRANSFORM;
const int CombatTurn_Type_Type_ARRAYSIZE = CombatTurn_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* CombatTurn_Type_descriptor();
inline const ::std::string& CombatTurn_Type_Name(CombatTurn_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    CombatTurn_Type_descriptor(), value);
}
inline bool CombatTurn_Type_Parse(
    const ::std::string& name, CombatTurn_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CombatTurn_Type>(
    CombatTurn_Type_descriptor(), name, value);
}
// ===================================================================

class CombatTurn : public ::google::protobuf::Message {
 public:
  CombatTurn();
  virtual ~CombatTurn();
  
  CombatTurn(const CombatTurn& from);
  
  inline CombatTurn& operator=(const CombatTurn& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CombatTurn& default_instance();
  
  void Swap(CombatTurn* other);
  
  // implements Message ----------------------------------------------
  
  CombatTurn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CombatTurn& from);
  void MergeFrom(const CombatTurn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CombatTurn_Type Type;
  static const Type ROLE_ATTACK = CombatTurn_Type_ROLE_ATTACK;
  static const Type PET_ATTACK = CombatTurn_Type_PET_ATTACK;
  static const Type ATTACKED_ENERMY = CombatTurn_Type_ATTACKED_ENERMY;
  static const Type ATTACKED_ENERMYPET = CombatTurn_Type_ATTACKED_ENERMYPET;
  static const Type ATTACKED_NPC = CombatTurn_Type_ATTACKED_NPC;
  static const Type TRANSFORM = CombatTurn_Type_TRANSFORM;
  static inline bool Type_IsValid(int value) {
    return CombatTurn_Type_IsValid(value);
  }
  static const Type Type_MIN =
    CombatTurn_Type_Type_MIN;
  static const Type Type_MAX =
    CombatTurn_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    CombatTurn_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return CombatTurn_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return CombatTurn_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return CombatTurn_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .CombatTurn.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::CombatTurn_Type type() const;
  inline void set_type(::CombatTurn_Type value);
  
  // optional int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional .PB_Vector2i coord = 3;
  inline bool has_coord() const;
  inline void clear_coord();
  static const int kCoordFieldNumber = 3;
  inline const ::PB_Vector2i& coord() const;
  inline ::PB_Vector2i* mutable_coord();
  inline ::PB_Vector2i* release_coord();
  
  // optional int32 skillId = 4;
  inline bool has_skillId() const;
  inline void clear_skillId();
  static const int kSkillIdFieldNumber = 4;
  inline ::google::protobuf::int32 skillId() const;
  inline void set_skillId(::google::protobuf::int32 value);
  
  // optional int32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional int32 targetID = 6;
  inline bool has_targetID() const;
  inline void clear_targetID();
  static const int kTargetIDFieldNumber = 6;
  inline ::google::protobuf::int32 targetID() const;
  inline void set_targetID(::google::protobuf::int32 value);
  
  // optional int32 damage = 7;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 7;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:CombatTurn)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_coord();
  inline void clear_has_coord();
  inline void set_has_skillId();
  inline void clear_has_skillId();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_targetID();
  inline void clear_has_targetID();
  inline void set_has_damage();
  inline void clear_has_damage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 time_;
  int type_;
  ::google::protobuf::int32 skillId_;
  ::PB_Vector2i* coord_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 targetID_;
  ::google::protobuf::int32 damage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Combat_2eproto();
  friend void protobuf_AssignDesc_Combat_2eproto();
  friend void protobuf_ShutdownFile_Combat_2eproto();
  
  void InitAsDefaultInstance();
  static CombatTurn* default_instance_;
};
// -------------------------------------------------------------------

class CombatRecord : public ::google::protobuf::Message {
 public:
  CombatRecord();
  virtual ~CombatRecord();
  
  CombatRecord(const CombatRecord& from);
  
  inline CombatRecord& operator=(const CombatRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CombatRecord& default_instance();
  
  void Swap(CombatRecord* other);
  
  // implements Message ----------------------------------------------
  
  CombatRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CombatRecord& from);
  void MergeFrom(const CombatRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .CombatTurn combatTurns = 2;
  inline int combatTurns_size() const;
  inline void clear_combatTurns();
  static const int kCombatTurnsFieldNumber = 2;
  inline const ::CombatTurn& combatTurns(int index) const;
  inline ::CombatTurn* mutable_combatTurns(int index);
  inline ::CombatTurn* add_combatTurns();
  inline const ::google::protobuf::RepeatedPtrField< ::CombatTurn >&
      combatTurns() const;
  inline ::google::protobuf::RepeatedPtrField< ::CombatTurn >*
      mutable_combatTurns();
  
  // @@protoc_insertion_point(class_scope:CombatRecord)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::CombatTurn > combatTurns_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Combat_2eproto();
  friend void protobuf_AssignDesc_Combat_2eproto();
  friend void protobuf_ShutdownFile_Combat_2eproto();
  
  void InitAsDefaultInstance();
  static CombatRecord* default_instance_;
};
// ===================================================================


// ===================================================================

// CombatTurn

// optional .CombatTurn.Type type = 1;
inline bool CombatTurn::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CombatTurn::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CombatTurn::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CombatTurn::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::CombatTurn_Type CombatTurn::type() const {
  return static_cast< ::CombatTurn_Type >(type_);
}
inline void CombatTurn::set_type(::CombatTurn_Type value) {
  GOOGLE_DCHECK(::CombatTurn_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 time = 2;
inline bool CombatTurn::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CombatTurn::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CombatTurn::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CombatTurn::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 CombatTurn::time() const {
  return time_;
}
inline void CombatTurn::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional .PB_Vector2i coord = 3;
inline bool CombatTurn::has_coord() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CombatTurn::set_has_coord() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CombatTurn::clear_has_coord() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CombatTurn::clear_coord() {
  if (coord_ != NULL) coord_->::PB_Vector2i::Clear();
  clear_has_coord();
}
inline const ::PB_Vector2i& CombatTurn::coord() const {
  return coord_ != NULL ? *coord_ : *default_instance_->coord_;
}
inline ::PB_Vector2i* CombatTurn::mutable_coord() {
  set_has_coord();
  if (coord_ == NULL) coord_ = new ::PB_Vector2i;
  return coord_;
}
inline ::PB_Vector2i* CombatTurn::release_coord() {
  clear_has_coord();
  ::PB_Vector2i* temp = coord_;
  coord_ = NULL;
  return temp;
}

// optional int32 skillId = 4;
inline bool CombatTurn::has_skillId() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CombatTurn::set_has_skillId() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CombatTurn::clear_has_skillId() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CombatTurn::clear_skillId() {
  skillId_ = 0;
  clear_has_skillId();
}
inline ::google::protobuf::int32 CombatTurn::skillId() const {
  return skillId_;
}
inline void CombatTurn::set_skillId(::google::protobuf::int32 value) {
  set_has_skillId();
  skillId_ = value;
}

// optional int32 status = 5;
inline bool CombatTurn::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CombatTurn::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CombatTurn::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CombatTurn::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 CombatTurn::status() const {
  return status_;
}
inline void CombatTurn::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 targetID = 6;
inline bool CombatTurn::has_targetID() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CombatTurn::set_has_targetID() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CombatTurn::clear_has_targetID() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CombatTurn::clear_targetID() {
  targetID_ = 0;
  clear_has_targetID();
}
inline ::google::protobuf::int32 CombatTurn::targetID() const {
  return targetID_;
}
inline void CombatTurn::set_targetID(::google::protobuf::int32 value) {
  set_has_targetID();
  targetID_ = value;
}

// optional int32 damage = 7;
inline bool CombatTurn::has_damage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CombatTurn::set_has_damage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CombatTurn::clear_has_damage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CombatTurn::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 CombatTurn::damage() const {
  return damage_;
}
inline void CombatTurn::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// -------------------------------------------------------------------

// CombatRecord

// repeated .CombatTurn combatTurns = 2;
inline int CombatRecord::combatTurns_size() const {
  return combatTurns_.size();
}
inline void CombatRecord::clear_combatTurns() {
  combatTurns_.Clear();
}
inline const ::CombatTurn& CombatRecord::combatTurns(int index) const {
  return combatTurns_.Get(index);
}
inline ::CombatTurn* CombatRecord::mutable_combatTurns(int index) {
  return combatTurns_.Mutable(index);
}
inline ::CombatTurn* CombatRecord::add_combatTurns() {
  return combatTurns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CombatTurn >&
CombatRecord::combatTurns() const {
  return combatTurns_;
}
inline ::google::protobuf::RepeatedPtrField< ::CombatTurn >*
CombatRecord::mutable_combatTurns() {
  return &combatTurns_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CombatTurn_Type>() {
  return ::CombatTurn_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Combat_2eproto__INCLUDED
